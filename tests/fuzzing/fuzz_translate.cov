/home/vito/MASTER_CSI/S2/TER/fuzzing/liblouis/liblouis/commonTranslationFunctions.c:
    1|       |/* liblouis Braille Translation and Back-Translation Library
    2|       |
    3|       |   Based on the Linux screenreader BRLTTY, copyright (C) 1999-2006 by The
    4|       |   BRLTTY Team
    5|       |
    6|       |   Copyright (C) 2004, 2005, 2006 ViewPlus Technologies, Inc. www.viewplus.com
    7|       |   Copyright (C) 2004, 2005, 2006 JJB Software, Inc. www.jjb-software.com
    8|       |   Copyright (C) 2016 Mike Gray, American Printing House for the Blind
    9|       |   Copyright (C) 2016 Davy Kager, Dedicon
   10|       |
   11|       |   This file is part of liblouis.
   12|       |
   13|       |   liblouis is free software: you can redistribute it and/or modify it
   14|       |   under the terms of the GNU Lesser General Public License as published
   15|       |   by the Free Software Foundation, either version 2.1 of the License, or
   16|       |   (at your option) any later version.
   17|       |
   18|       |   liblouis is distributed in the hope that it will be useful, but
   19|       |   WITHOUT ANY WARRANTY; without even the implied warranty of
   20|       |   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
   21|       |   Lesser General Public License for more details.
   22|       |
   23|       |   You should have received a copy of the GNU Lesser General Public
   24|       |   License along with liblouis. If not, see <http://www.gnu.org/licenses/>.
   25|       |*/
   26|       |
   27|       |#include <string.h>
   28|       |#include "internal.h"
   29|       |
   30|       |static int passVariables[NUMVAR];
   31|       |
   32|       |void EXPORT_CALL
   33|      0|_lou_resetPassVariables(void) {
   34|      0|	memset(passVariables, 0, sizeof(passVariables[0]) * NUMVAR);
   35|      0|}
   36|       |
   37|       |int EXPORT_CALL
   38|      0|_lou_handlePassVariableTest(const widechar *instructions, int *IC, int *itsTrue) {
   39|      0|	switch (instructions[*IC]) {
   40|      0|	case pass_eq:
   41|      0|		if (passVariables[instructions[*IC + 1]] != instructions[*IC + 2]) *itsTrue = 0;
   42|      0|		*IC += 3;
   43|      0|		return 1;
   44|      0|
   45|      0|	case pass_lt:
   46|      0|		if (passVariables[instructions[*IC + 1]] >= instructions[*IC + 2]) *itsTrue = 0;
   47|      0|		*IC += 3;
   48|      0|		return 1;
   49|      0|
   50|      0|	case pass_gt:
   51|      0|		if (passVariables[instructions[*IC + 1]] <= instructions[*IC + 2]) *itsTrue = 0;
   52|      0|		*IC += 3;
   53|      0|		return 1;
   54|      0|
   55|      0|	case pass_lteq:
   56|      0|		if (passVariables[instructions[*IC + 1]] > instructions[*IC + 2]) *itsTrue = 0;
   57|      0|		*IC += 3;
   58|      0|		return 1;
   59|      0|
   60|      0|	case pass_gteq:
   61|      0|		if (passVariables[instructions[*IC + 1]] < instructions[*IC + 2]) *itsTrue = 0;
   62|      0|		*IC += 3;
   63|      0|		return 1;
   64|      0|
   65|      0|	default:
   66|      0|		return 0;
   67|      0|	}
   68|      0|}
   69|       |
   70|       |int EXPORT_CALL
   71|      0|_lou_handlePassVariableAction(const widechar *instructions, int *IC) {
   72|      0|	switch (instructions[*IC]) {
   73|      0|	case pass_eq:
   74|      0|		passVariables[instructions[*IC + 1]] = instructions[*IC + 2];
   75|      0|		*IC += 3;
   76|      0|		return 1;
   77|      0|
   78|      0|	case pass_hyphen:
   79|      0|		passVariables[instructions[*IC + 1]] -= 1;
   80|      0|		if (passVariables[instructions[*IC + 1]] < 0)
   81|      0|			passVariables[instructions[*IC + 1]] = 0;
   82|      0|		*IC += 2;
   83|      0|		return 1;
   84|      0|
   85|      0|	case pass_plus:
   86|      0|		passVariables[instructions[*IC + 1]] += 1;
   87|      0|		*IC += 2;
   88|      0|		return 1;
   89|      0|
   90|      0|	default:
   91|      0|		return 0;
   92|      0|	}
   93|      0|}

/home/vito/MASTER_CSI/S2/TER/fuzzing/liblouis/liblouis/compileTranslationTable.c:
    1|       |/* liblouis Braille Translation and Back-Translation Library
    2|       |
    3|       |   Based on the Linux screenreader BRLTTY, copyright (C) 1999-2006 by The
    4|       |   BRLTTY Team
    5|       |
    6|       |   Copyright (C) 2004, 2005, 2006 ViewPlus Technologies, Inc. www.viewplus.com
    7|       |   Copyright (C) 2004, 2005, 2006 JJB Software, Inc. www.jjb-software.com
    8|       |   Copyright (C) 2016 Mike Gray, American Printing House for the Blind
    9|       |   Copyright (C) 2016 Davy Kager, Dedicon
   10|       |
   11|       |   This file is part of liblouis.
   12|       |
   13|       |   liblouis is free software: you can redistribute it and/or modify it
   14|       |   under the terms of the GNU Lesser General Public License as published
   15|       |   by the Free Software Foundation, either version 2.1 of the License, or
   16|       |   (at your option) any later version.
   17|       |
   18|       |   liblouis is distributed in the hope that it will be useful, but
   19|       |   WITHOUT ANY WARRANTY; without even the implied warranty of
   20|       |   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
   21|       |   Lesser General Public License for more details.
   22|       |
   23|       |   You should have received a copy of the GNU Lesser General Public
   24|       |   License along with liblouis. If not, see <http://www.gnu.org/licenses/>.
   25|       |*/
   26|       |
   27|       |/**
   28|       | * @file
   29|       | * @brief Read and compile translation tables
   30|       | */
   31|       |
   32|       |#include <stddef.h>
   33|       |#include <stdlib.h>
   34|       |#include <stdio.h>
   35|       |#include <stdarg.h>
   36|       |#include <string.h>
   37|       |#include <ctype.h>
   38|       |#include <sys/stat.h>
   39|       |
   40|       |#include "internal.h"
   41|       |#include "config.h"
   42|       |
   43|      0|#define QUOTESUB 28 /* Stand-in for double quotes in strings */
   44|       |
   45|       |/* needed to make debuggin easier */
   46|       |#ifdef DEBUG
   47|       |wchar_t wchar;
   48|       |#endif
   49|       |
   50|       |/* The following variables and functions make it possible to specify the
   51|       | * path on which all tables for liblouis and all files for liblouisutdml,
   52|       | * in their proper directories, will be found.
   53|       | */
   54|       |
   55|       |static char *dataPathPtr;
   56|       |
   57|       |char *EXPORT_CALL
   58|      0|lou_setDataPath(const char *path) {
   59|      0|	static char dataPath[MAXSTRING];
   60|      0|	dataPathPtr = NULL;
   61|      0|	if (path == NULL) return NULL;
   62|      0|	strcpy(dataPath, path);
   63|      0|	dataPathPtr = dataPath;
   64|      0|	return dataPathPtr;
   65|      0|}
   66|       |
   67|       |char *EXPORT_CALL
   68|      0|lou_getDataPath(void) {
   69|      0|	return dataPathPtr;
   70|      0|}
   71|       |
   72|       |/* End of dataPath code. */
   73|       |
   74|       |static int
   75|      0|eqasc2uni(const unsigned char *a, const widechar *b, const int len) {
   76|      0|	int k;
   77|      0|	for (k = 0; k < len; k++)
   78|      0|		if ((widechar)a[k] != b[k]) return 0;
   79|      0|	return 1;
   80|      0|}
   81|       |
   82|       |typedef struct CharsString {
   83|       |	widechar length;
   84|       |	widechar chars[MAXSTRING];
   85|       |} CharsString;
   86|       |
   87|       |static int errorCount;
   88|       |static int warningCount;
   89|       |
   90|       |typedef struct TranslationTableChainEntry {
   91|       |	struct TranslationTableChainEntry *next;
   92|       |	TranslationTableHeader *table;
   93|       |	int tableListLength;
   94|       |	char tableList[1];
   95|       |} TranslationTableChainEntry;
   96|       |
   97|       |static TranslationTableChainEntry *translationTableChain = NULL;
   98|       |
   99|       |typedef struct DisplayTableChainEntry {
  100|       |	struct DisplayTableChainEntry *next;
  101|       |	DisplayTableHeader *table;
  102|       |	int tableListLength;
  103|       |	char tableList[1];
  104|       |} DisplayTableChainEntry;
  105|       |
  106|       |static DisplayTableChainEntry *displayTableChain = NULL;
  107|       |
  108|       |/* predefined character classes */
  109|       |static const char *characterClassNames[] = {
  110|       |	"space",
  111|       |	"letter",
  112|       |	"digit",
  113|       |	"punctuation",
  114|       |	"uppercase",
  115|       |	"lowercase",
  116|       |	"math",
  117|       |	"sign",
  118|       |	"litdigit",
  119|       |	NULL,
  120|       |};
  121|       |
  122|       |// names that may not be used for custom attributes
  123|       |static const char *reservedAttributeNames[] = {
  124|       |	"numericnocontchars",
  125|       |	"numericnocontchar",
  126|       |	"numericnocont",
  127|       |	"midendnumericmodechars",
  128|       |	"midendnumericmodechar",
  129|       |	"midendnumericmode",
  130|       |	"numericmodechars",
  131|       |	"numericmodechar",
  132|       |	"numericmode",
  133|       |	"capsmodechars",
  134|       |	"capsmodechar",
  135|       |	"capsmode",
  136|       |	"emphmodechars",
  137|       |	"emphmodechar",
  138|       |	"emphmode",
  139|       |	"noemphchars",
  140|       |	"noemphchar",
  141|       |	"noemph",
  142|       |	"seqdelimiter",
  143|       |	"seqbeforechars",
  144|       |	"seqbeforechar",
  145|       |	"seqbefore",
  146|       |	"seqafterchars",
  147|       |	"seqafterchar",
  148|       |	"seqafter",
  149|       |	"noletsign",
  150|       |	"noletsignbefore",
  151|       |	"noletsignafter",
  152|       |	NULL,
  153|       |};
  154|       |
  155|       |static const char *opcodeNames[CTO_None] = {
  156|       |	"include",
  157|       |	"locale",
  158|       |	"undefined",
  159|       |	"capsletter",
  160|       |	"begcapsword",
  161|       |	"endcapsword",
  162|       |	"begcaps",
  163|       |	"endcaps",
  164|       |	"begcapsphrase",
  165|       |	"endcapsphrase",
  166|       |	"lencapsphrase",
  167|       |	"modeletter",
  168|       |	"begmodeword",
  169|       |	"endmodeword",
  170|       |	"begmode",
  171|       |	"endmode",
  172|       |	"begmodephrase",
  173|       |	"endmodephrase",
  174|       |	"lenmodephrase",
  175|       |	"letsign",
  176|       |	"noletsignbefore",
  177|       |	"noletsign",
  178|       |	"noletsignafter",
  179|       |	"numsign",
  180|       |	"numericmodechars",
  181|       |	"midendnumericmodechars",
  182|       |	"numericnocontchars",
  183|       |	"seqdelimiter",
  184|       |	"seqbeforechars",
  185|       |	"seqafterchars",
  186|       |	"seqafterpattern",
  187|       |	"seqafterexpression",
  188|       |	"emphclass",
  189|       |	"emphletter",
  190|       |	"begemphword",
  191|       |	"endemphword",
  192|       |	"begemph",
  193|       |	"endemph",
  194|       |	"begemphphrase",
  195|       |	"endemphphrase",
  196|       |	"lenemphphrase",
  197|       |	"capsmodechars",
  198|       |	"emphmodechars",
  199|       |	"noemphchars",
  200|       |	"begcomp",
  201|       |	"endcomp",
  202|       |	"nocontractsign",
  203|       |	"multind",
  204|       |	"compdots",
  205|       |	"comp6",
  206|       |	"class",
  207|       |	"after",
  208|       |	"before",
  209|       |	"noback",
  210|       |	"nofor",
  211|       |	"empmatchbefore",
  212|       |	"empmatchafter",
  213|       |	"swapcc",
  214|       |	"swapcd",
  215|       |	"swapdd",
  216|       |	"space",
  217|       |	"digit",
  218|       |	"punctuation",
  219|       |	"math",
  220|       |	"sign",
  221|       |	"letter",
  222|       |	"uppercase",
  223|       |	"lowercase",
  224|       |	"grouping",
  225|       |	"uplow",
  226|       |	"litdigit",
  227|       |	"display",
  228|       |	"replace",
  229|       |	"context",
  230|       |	"correct",
  231|       |	"pass2",
  232|       |	"pass3",
  233|       |	"pass4",
  234|       |	"repeated",
  235|       |	"repword",
  236|       |	"rependword",
  237|       |	"capsnocont",
  238|       |	"always",
  239|       |	"exactdots",
  240|       |	"nocross",
  241|       |	"syllable",
  242|       |	"nocont",
  243|       |	"compbrl",
  244|       |	"literal",
  245|       |	"largesign",
  246|       |	"word",
  247|       |	"partword",
  248|       |	"joinnum",
  249|       |	"joinword",
  250|       |	"lowword",
  251|       |	"contraction",
  252|       |	"sufword",
  253|       |	"prfword",
  254|       |	"begword",
  255|       |	"begmidword",
  256|       |	"midword",
  257|       |	"midendword",
  258|       |	"endword",
  259|       |	"prepunc",
  260|       |	"postpunc",
  261|       |	"begnum",
  262|       |	"midnum",
  263|       |	"endnum",
  264|       |	"decpoint",
  265|       |	"hyphen",
  266|       |	// "apostrophe",
  267|       |	// "initial",
  268|       |	"nobreak",
  269|       |	"match",
  270|       |	"backmatch",
  271|       |	"attribute",
  272|       |	"base",
  273|       |	"macro",
  274|       |};
  275|       |
  276|       |static short opcodeLengths[CTO_None] = { 0 };
  277|       |
  278|       |static void
  279|       |compileError(const FileInfo *file, const char *format, ...);
  280|       |
  281|       |static void
  282|       |free_tablefiles(char **tables);
  283|       |
  284|       |static int
  285|      0|getAChar(FileInfo *file) {
  286|      0|	/* Read a big endian, little endian or ASCII 8 file and convert it to
  287|      0|	 * 16- or 32-bit unsigned integers */
  288|      0|	int ch1 = 0, ch2 = 0;
  289|      0|	widechar character;
  290|      0|	if (file->encoding == ascii8)
  291|      0|		if (file->status == 2) {
  292|      0|			file->status++;
  293|      0|			return file->checkencoding[1];
  294|      0|		}
  295|      0|	while ((ch1 = fgetc(file->in)) != EOF) {
  296|      0|		if (file->status < 2) file->checkencoding[file->status] = ch1;
  297|      0|		file->status++;
  298|      0|		if (file->status == 2) {
  299|      0|			if (file->checkencoding[0] == 0xfe && file->checkencoding[1] == 0xff)
  300|      0|				file->encoding = bigEndian;
  301|      0|			else if (file->checkencoding[0] == 0xff && file->checkencoding[1] == 0xfe)
  302|      0|				file->encoding = littleEndian;
  303|      0|			else if (file->checkencoding[0] < 128 && file->checkencoding[1] < 128) {
  304|      0|				file->encoding = ascii8;
  305|      0|				return file->checkencoding[0];
  306|      0|			} else {
  307|      0|				compileError(file,
  308|      0|						"encoding is neither big-endian, little-endian nor ASCII 8.");
  309|      0|				ch1 = EOF;
  310|      0|				break;
  311|      0|				;
  312|      0|			}
  313|      0|			continue;
  314|      0|		}
  315|      0|		switch (file->encoding) {
  316|      0|		case noEncoding:
  317|      0|			break;
  318|      0|		case ascii8:
  319|      0|			return ch1;
  320|      0|			break;
  321|      0|		case bigEndian:
  322|      0|			ch2 = fgetc(file->in);
  323|      0|			if (ch2 == EOF) break;
  324|      0|			character = (widechar)(ch1 << 8) | ch2;
  325|      0|			return (int)character;
  326|      0|			break;
  327|      0|		case littleEndian:
  328|      0|			ch2 = fgetc(file->in);
  329|      0|			if (ch2 == EOF) break;
  330|      0|			character = (widechar)(ch2 << 8) | ch1;
  331|      0|			return (int)character;
  332|      0|			break;
  333|      0|		}
  334|      0|		if (ch1 == EOF || ch2 == EOF) break;
  335|      0|	}
  336|      0|	return EOF;
  337|      0|}
  338|       |
  339|       |int EXPORT_CALL
  340|      0|_lou_getALine(FileInfo *file) {
  341|      0|	/* Read a line of widechar's from an input file */
  342|      0|	int ch;
  343|      0|	int pch = 0;
  344|      0|	file->linelen = 0;
  345|      0|	while ((ch = getAChar(file)) != EOF) {
  346|      0|		if (ch == 13) continue;
  347|      0|		if (pch == '\\' && ch == 10) {
  348|      0|			file->linelen--;
  349|      0|			pch = ch;
  350|      0|			continue;
  351|      0|		}
  352|      0|		if (ch == 10 || file->linelen >= MAXSTRING - 1) break;
  353|      0|		file->line[file->linelen++] = (widechar)ch;
  354|      0|		pch = ch;
  355|      0|	}
  356|      0|	file->line[file->linelen] = 0;
  357|      0|	file->linepos = 0;
  358|      0|	if (ch == EOF && !file->linelen) return 0;
  359|      0|	file->lineNumber++;
  360|      0|	return 1;
  361|      0|}
  362|       |
  363|       |static inline int
  364|      0|atEndOfLine(const FileInfo *file) {
  365|      0|	return file->linepos >= file->linelen;
  366|      0|}
  367|       |
  368|       |static inline int
  369|      0|atTokenDelimiter(const FileInfo *file) {
  370|      0|	return file->line[file->linepos] <= 32;
  371|      0|}
  372|       |
  373|       |static int
  374|      0|getToken(FileInfo *file, CharsString *result, const char *description) {
  375|      0|	/* Find the next string of contiguous non-whitespace characters. If this
  376|      0|	 * is the last token on the line, return 2 instead of 1. */
  377|      0|	while (!atEndOfLine(file) && atTokenDelimiter(file)) file->linepos++;
  378|      0|	result->length = 0;
  379|      0|	while (!atEndOfLine(file) && !atTokenDelimiter(file)) {
  380|      0|		int maxlen = MAXSTRING;
  381|      0|		if (result->length >= maxlen) {
  382|      0|			compileError(file, "more than %d characters (bytes)", maxlen);
  383|      0|			return 0;
  384|      0|		} else
  385|      0|			result->chars[result->length++] = file->line[file->linepos++];
  386|      0|	}
  387|      0|	if (!result->length) {
  388|      0|		/* Not enough tokens */
  389|      0|		if (description) compileError(file, "%s not specified.", description);
  390|      0|		return 0;
  391|      0|	}
  392|      0|	result->chars[result->length] = 0;
  393|      0|	while (!atEndOfLine(file) && atTokenDelimiter(file)) file->linepos++;
  394|      0|	return 1;
  395|      0|}
  396|       |
  397|       |static void
  398|      0|compileError(const FileInfo *file, const char *format, ...) {
  399|      0|#ifndef __SYMBIAN32__
  400|      0|	char buffer[MAXSTRING];
  401|      0|	va_list arguments;
  402|      0|	va_start(arguments, format);
  403|      0|	vsnprintf(buffer, sizeof(buffer), format, arguments);
  404|      0|	va_end(arguments);
  405|      0|	if (file)
  406|      0|		_lou_logMessage(LOU_LOG_ERROR, "%s:%d: error: %s", file->fileName,
  407|      0|				file->lineNumber, buffer);
  408|      0|	else
  409|      0|		_lou_logMessage(LOU_LOG_ERROR, "error: %s", buffer);
  410|      0|	errorCount++;
  411|      0|#endif
  412|      0|}
  413|       |
  414|       |static void
  415|      0|compileWarning(const FileInfo *file, const char *format, ...) {
  416|      0|#ifndef __SYMBIAN32__
  417|      0|	char buffer[MAXSTRING];
  418|      0|	va_list arguments;
  419|      0|	va_start(arguments, format);
  420|      0|	vsnprintf(buffer, sizeof(buffer), format, arguments);
  421|      0|	va_end(arguments);
  422|      0|	if (file)
  423|      0|		_lou_logMessage(LOU_LOG_WARN, "%s:%d: warning: %s", file->fileName,
  424|      0|				file->lineNumber, buffer);
  425|      0|	else
  426|      0|		_lou_logMessage(LOU_LOG_WARN, "warning: %s", buffer);
  427|      0|	warningCount++;
  428|      0|#endif
  429|      0|}
  430|       |
  431|       |static int
  432|       |allocateSpaceInTranslationTable(const FileInfo *file, TranslationTableOffset *offset,
  433|      0|		int size, TranslationTableHeader **table) {
  434|      0|	/* allocate memory for table and expand previously allocated memory if necessary */
  435|      0|	int spaceNeeded = ((size + OFFSETSIZE - 1) / OFFSETSIZE) * OFFSETSIZE;
  436|      0|	TranslationTableOffset newTableSize = (*table)->bytesUsed + spaceNeeded;
  437|      0|	TranslationTableOffset tableSize = (*table)->tableSize;
  438|      0|	if (newTableSize > tableSize) {
  439|      0|		TranslationTableHeader *newTable;
  440|      0|		newTableSize += (newTableSize / OFFSETSIZE);
  441|      0|		newTable = realloc(*table, newTableSize);
  442|      0|		if (!newTable) {
  443|      0|			compileError(file, "Not enough memory for translation table.");
  444|      0|			_lou_outOfMemory();
  445|      0|		}
  446|      0|		memset(((unsigned char *)newTable) + tableSize, 0, newTableSize - tableSize);
  447|      0|		/* update references to the old table */
  448|      0|		{
  449|      0|			TranslationTableChainEntry *entry;
  450|      0|			for (entry = translationTableChain; entry != NULL; entry = entry->next)
  451|      0|				if (entry->table == *table)
  452|      0|					entry->table = (TranslationTableHeader *)newTable;
  453|      0|		}
  454|      0|		newTable->tableSize = newTableSize;
  455|      0|		*table = newTable;
  456|      0|	}
  457|      0|	if (offset != NULL) {
  458|      0|		*offset = ((*table)->bytesUsed - sizeof(**table)) / OFFSETSIZE;
  459|      0|		(*table)->bytesUsed += spaceNeeded;
  460|      0|	}
  461|      0|	return 1;
  462|      0|}
  463|       |
  464|       |static int
  465|       |allocateSpaceInDisplayTable(const FileInfo *file, TranslationTableOffset *offset,
  466|      0|		int size, DisplayTableHeader **table) {
  467|      0|	/* allocate memory for table and expand previously allocated memory if necessary */
  468|      0|	int spaceNeeded = ((size + OFFSETSIZE - 1) / OFFSETSIZE) * OFFSETSIZE;
  469|      0|	TranslationTableOffset newTableSize = (*table)->bytesUsed + spaceNeeded;
  470|      0|	TranslationTableOffset tableSize = (*table)->tableSize;
  471|      0|	if (newTableSize > tableSize) {
  472|      0|		DisplayTableHeader *newTable;
  473|      0|		newTableSize += (newTableSize / OFFSETSIZE);
  474|      0|		newTable = realloc(*table, newTableSize);
  475|      0|		if (!newTable) {
  476|      0|			compileError(file, "Not enough memory for display table.");
  477|      0|			_lou_outOfMemory();
  478|      0|		}
  479|      0|		memset(((unsigned char *)newTable) + tableSize, 0, newTableSize - tableSize);
  480|      0|		/* update references to the old table */
  481|      0|		{
  482|      0|			DisplayTableChainEntry *entry;
  483|      0|			for (entry = displayTableChain; entry != NULL; entry = entry->next)
  484|      0|				if (entry->table == *table) entry->table = (DisplayTableHeader *)newTable;
  485|      0|		}
  486|      0|		newTable->tableSize = newTableSize;
  487|      0|		*table = newTable;
  488|      0|	}
  489|      0|	if (offset != NULL) {
  490|      0|		*offset = ((*table)->bytesUsed - sizeof(**table)) / OFFSETSIZE;
  491|      0|		(*table)->bytesUsed += spaceNeeded;
  492|      0|	}
  493|      0|	return 1;
  494|      0|}
  495|       |
  496|       |static int
  497|      0|allocateTranslationTable(const FileInfo *file, TranslationTableHeader **table) {
  498|      0|	/* Allocate memory for the table and a guess on the number of rules */
  499|      0|	const TranslationTableOffset startSize = 2 * sizeof(**table);
  500|      0|	if (*table) return 1;
  501|      0|	TranslationTableOffset bytesUsed =
  502|      0|			sizeof(**table) + OFFSETSIZE; /* So no offset is ever zero */
  503|      0|	if (!(*table = malloc(startSize))) {
  504|      0|		compileError(file, "Not enough memory");
  505|      0|		if (*table != NULL) free(*table);
  506|      0|		*table = NULL;
  507|      0|		_lou_outOfMemory();
  508|      0|	}
  509|      0|	memset(*table, 0, startSize);
  510|      0|	(*table)->tableSize = startSize;
  511|      0|	(*table)->bytesUsed = bytesUsed;
  512|      0|	return 1;
  513|      0|}
  514|       |
  515|       |static int
  516|      0|allocateDisplayTable(const FileInfo *file, DisplayTableHeader **table) {
  517|      0|	/* Allocate memory for the table and a guess on the number of rules */
  518|      0|	const TranslationTableOffset startSize = 2 * sizeof(**table);
  519|      0|	if (*table) return 1;
  520|      0|	TranslationTableOffset bytesUsed =
  521|      0|			sizeof(**table) + OFFSETSIZE; /* So no offset is ever zero */
  522|      0|	if (!(*table = malloc(startSize))) {
  523|      0|		compileError(file, "Not enough memory");
  524|      0|		if (*table != NULL) free(*table);
  525|      0|		*table = NULL;
  526|      0|		_lou_outOfMemory();
  527|      0|	}
  528|      0|	memset(*table, 0, startSize);
  529|      0|	(*table)->tableSize = startSize;
  530|      0|	(*table)->bytesUsed = bytesUsed;
  531|      0|	return 1;
  532|      0|}
  533|       |
  534|       |/* Look up a character or dot pattern. Although the algorithms are almost identical,
  535|       | * different tables are needed for characters and dots because of the possibility of
  536|       | * conflicts. */
  537|       |
  538|       |static TranslationTableCharacter *
  539|       |getChar(widechar c, TranslationTableHeader *table,
  540|      0|		TranslationTableOffset *characterOffset) {
  541|      0|	const TranslationTableOffset bucket = table->characters[_lou_charHash(c)];
  542|      0|	TranslationTableOffset offset = bucket;
  543|      0|	while (offset) {
  544|      0|		TranslationTableCharacter *character =
  545|      0|				(TranslationTableCharacter *)&table->ruleArea[offset];
  546|      0|		if (character->value == c) {
  547|      0|			if (characterOffset) *characterOffset = offset;
  548|      0|			return character;
  549|      0|		}
  550|      0|		offset = character->next;
  551|      0|	}
  552|      0|	return NULL;
  553|      0|}
  554|       |
  555|       |static TranslationTableCharacter *
  556|      0|getDots(widechar d, TranslationTableHeader *table) {
  557|      0|	const TranslationTableOffset bucket = table->dots[_lou_charHash(d)];
  558|      0|	TranslationTableOffset offset = bucket;
  559|      0|	while (offset) {
  560|      0|		TranslationTableCharacter *character =
  561|      0|				(TranslationTableCharacter *)&table->ruleArea[offset];
  562|      0|		if (character->value == d) return character;
  563|      0|		offset = character->next;
  564|      0|	}
  565|      0|	return NULL;
  566|      0|}
  567|       |
  568|       |static TranslationTableCharacter *
  569|       |putChar(const FileInfo *file, widechar c, TranslationTableHeader **table,
  570|      0|		TranslationTableOffset *characterOffset) {
  571|      0|	/* See if a character is in the appropriate table. If not, insert it. In either case,
  572|      0|	 * return a pointer to it. */
  573|      0|	TranslationTableCharacter *character;
  574|      0|	TranslationTableOffset offset;
  575|      0|	if ((character = getChar(c, *table, characterOffset))) return character;
  576|      0|	if (!allocateSpaceInTranslationTable(file, &offset, sizeof(*character), table))
  577|      0|		return NULL;
  578|      0|	character = (TranslationTableCharacter *)&(*table)->ruleArea[offset];
  579|      0|	memset(character, 0, sizeof(*character));
  580|      0|	character->sourceFile = file->sourceFile;
  581|      0|	character->sourceLine = file->lineNumber;
  582|      0|	character->value = c;
  583|      0|	const unsigned long int charHash = _lou_charHash(c);
  584|      0|	const TranslationTableOffset bucket = (*table)->characters[charHash];
  585|      0|	if (!bucket)
  586|      0|		(*table)->characters[charHash] = offset;
  587|      0|	else {
  588|      0|		TranslationTableCharacter *oldchar =
  589|      0|				(TranslationTableCharacter *)&(*table)->ruleArea[bucket];
  590|      0|		while (oldchar->next)
  591|      0|			oldchar = (TranslationTableCharacter *)&(*table)->ruleArea[oldchar->next];
  592|      0|		oldchar->next = offset;
  593|      0|	}
  594|      0|	if (characterOffset) *characterOffset = offset;
  595|      0|	return character;
  596|      0|}
  597|       |
  598|       |static TranslationTableCharacter *
  599|      0|putDots(const FileInfo *file, widechar d, TranslationTableHeader **table) {
  600|      0|	/* See if a dot pattern is in the appropriate table. If not, insert it. In either
  601|      0|	 * case, return a pointer to it. */
  602|      0|	TranslationTableCharacter *character;
  603|      0|	TranslationTableOffset offset;
  604|      0|	if ((character = getDots(d, *table))) return character;
  605|      0|	if (!allocateSpaceInTranslationTable(file, &offset, sizeof(*character), table))
  606|      0|		return NULL;
  607|      0|	character = (TranslationTableCharacter *)&(*table)->ruleArea[offset];
  608|      0|	memset(character, 0, sizeof(*character));
  609|      0|	character->sourceFile = file->sourceFile;
  610|      0|	character->sourceLine = file->lineNumber;
  611|      0|	character->value = d;
  612|      0|	const unsigned long int charHash = _lou_charHash(d);
  613|      0|	const TranslationTableOffset bucket = (*table)->dots[charHash];
  614|      0|	if (!bucket)
  615|      0|		(*table)->dots[charHash] = offset;
  616|      0|	else {
  617|      0|		TranslationTableCharacter *oldchar =
  618|      0|				(TranslationTableCharacter *)&(*table)->ruleArea[bucket];
  619|      0|		while (oldchar->next)
  620|      0|			oldchar = (TranslationTableCharacter *)&(*table)->ruleArea[oldchar->next];
  621|      0|		oldchar->next = offset;
  622|      0|	}
  623|      0|	return character;
  624|      0|}
  625|       |
  626|       |/* Look up a character-dots mapping in a display table. */
  627|       |
  628|       |static CharDotsMapping *
  629|      0|getDotsForChar(widechar c, const DisplayTableHeader *table) {
  630|      0|	CharDotsMapping *cdPtr;
  631|      0|	const TranslationTableOffset bucket = table->charToDots[_lou_charHash(c)];
  632|      0|	TranslationTableOffset offset = bucket;
  633|      0|	while (offset) {
  634|      0|		cdPtr = (CharDotsMapping *)&table->ruleArea[offset];
  635|      0|		if (cdPtr->lookFor == c) return cdPtr;
  636|      0|		offset = cdPtr->next;
  637|      0|	}
  638|      0|	return NULL;
  639|      0|}
  640|       |
  641|       |static CharDotsMapping *
  642|      0|getCharForDots(widechar d, const DisplayTableHeader *table) {
  643|      0|	CharDotsMapping *cdPtr;
  644|      0|	const TranslationTableOffset bucket = table->dotsToChar[_lou_charHash(d)];
  645|      0|	TranslationTableOffset offset = bucket;
  646|      0|	while (offset) {
  647|      0|		cdPtr = (CharDotsMapping *)&table->ruleArea[offset];
  648|      0|		if (cdPtr->lookFor == d) return cdPtr;
  649|      0|		offset = cdPtr->next;
  650|      0|	}
  651|      0|	return NULL;
  652|      0|}
  653|       |
  654|       |widechar EXPORT_CALL
  655|      0|_lou_getDotsForChar(widechar c, const DisplayTableHeader *table) {
  656|      0|	CharDotsMapping *cdPtr = getDotsForChar(c, table);
  657|      0|	if (cdPtr) return cdPtr->found;
  658|      0|	return LOU_DOTS;
  659|      0|}
  660|       |
  661|       |widechar EXPORT_CALL
  662|      0|_lou_getCharForDots(widechar d, const DisplayTableHeader *table) {
  663|      0|	CharDotsMapping *cdPtr = getCharForDots(d, table);
  664|      0|	if (cdPtr) return cdPtr->found;
  665|      0|	return '\0';
  666|      0|}
  667|       |
  668|       |static int
  669|       |putCharDotsMapping(
  670|      0|		const FileInfo *file, widechar c, widechar d, DisplayTableHeader **table) {
  671|      0|	if (!getDotsForChar(c, *table)) {
  672|      0|		CharDotsMapping *cdPtr;
  673|      0|		TranslationTableOffset offset;
  674|      0|		if (!allocateSpaceInDisplayTable(file, &offset, sizeof(*cdPtr), table)) return 0;
  675|      0|		cdPtr = (CharDotsMapping *)&(*table)->ruleArea[offset];
  676|      0|		cdPtr->next = 0;
  677|      0|		cdPtr->lookFor = c;
  678|      0|		cdPtr->found = d;
  679|      0|		const unsigned long int charHash = _lou_charHash(c);
  680|      0|		const TranslationTableOffset bucket = (*table)->charToDots[charHash];
  681|      0|		if (!bucket)
  682|      0|			(*table)->charToDots[charHash] = offset;
  683|      0|		else {
  684|      0|			CharDotsMapping *oldcdPtr = (CharDotsMapping *)&(*table)->ruleArea[bucket];
  685|      0|			while (oldcdPtr->next)
  686|      0|				oldcdPtr = (CharDotsMapping *)&(*table)->ruleArea[oldcdPtr->next];
  687|      0|			oldcdPtr->next = offset;
  688|      0|		}
  689|      0|	}
  690|      0|	if (!getCharForDots(d, *table)) {
  691|      0|		CharDotsMapping *cdPtr;
  692|      0|		TranslationTableOffset offset;
  693|      0|		if (!allocateSpaceInDisplayTable(file, &offset, sizeof(*cdPtr), table)) return 0;
  694|      0|		cdPtr = (CharDotsMapping *)&(*table)->ruleArea[offset];
  695|      0|		cdPtr->next = 0;
  696|      0|		cdPtr->lookFor = d;
  697|      0|		cdPtr->found = c;
  698|      0|		const unsigned long int charHash = _lou_charHash(d);
  699|      0|		const TranslationTableOffset bucket = (*table)->dotsToChar[charHash];
  700|      0|		if (!bucket)
  701|      0|			(*table)->dotsToChar[charHash] = offset;
  702|      0|		else {
  703|      0|			CharDotsMapping *oldcdPtr = (CharDotsMapping *)&(*table)->ruleArea[bucket];
  704|      0|			while (oldcdPtr->next)
  705|      0|				oldcdPtr = (CharDotsMapping *)&(*table)->ruleArea[oldcdPtr->next];
  706|      0|			oldcdPtr->next = offset;
  707|      0|		}
  708|      0|	}
  709|      0|	return 1;
  710|      0|}
  711|       |
  712|       |static inline const char *
  713|      0|getPartName(int actionPart) {
  714|      0|	return actionPart ? "action" : "test";
  715|      0|}
  716|       |
  717|       |static int
  718|       |passFindCharacters(const FileInfo *file, widechar *instructions, int end,
  719|      0|		widechar **characters, int *length) {
  720|      0|	int IC = 0;
  721|      0|	int lookback = 0;
  722|      0|
  723|      0|	*characters = NULL;
  724|      0|	*length = 0;
  725|      0|
  726|      0|	while (IC < end) {
  727|      0|		widechar instruction = instructions[IC];
  728|      0|
  729|      0|		switch (instruction) {
  730|      0|		case pass_string:
  731|      0|		case pass_dots: {
  732|      0|			int count = instructions[IC + 1];
  733|      0|			IC += 2;
  734|      0|			if (count > lookback) {
  735|      0|				*characters = &instructions[IC + lookback];
  736|      0|				*length = count - lookback;
  737|      0|				return 1;
  738|      0|			} else {
  739|      0|				lookback -= count;
  740|      0|			}
  741|      0|			IC += count;
  742|      0|			continue;
  743|      0|		}
  744|      0|
  745|      0|		case pass_attributes:
  746|      0|			IC += 7;
  747|      0|			if (instructions[IC - 2] == instructions[IC - 1] &&
  748|      0|					instructions[IC - 1] <= lookback) {
  749|      0|				lookback -= instructions[IC - 1];
  750|      0|				continue;
  751|      0|			}
  752|      0|			goto NO_CHARACTERS;
  753|      0|
  754|      0|		case pass_swap:
  755|      0|			IC += 2;
  756|      0|			/* fall through */
  757|      0|
  758|      0|		case pass_groupstart:
  759|      0|		case pass_groupend:
  760|      0|		case pass_groupreplace:
  761|      0|			IC += 3;
  762|      0|
  763|      0|		NO_CHARACTERS : { return 1; }
  764|      0|
  765|      0|		case pass_eq:
  766|      0|		case pass_lt:
  767|      0|		case pass_gt:
  768|      0|		case pass_lteq:
  769|      0|		case pass_gteq:
  770|      0|			IC += 3;
  771|      0|			continue;
  772|      0|
  773|      0|		case pass_lookback:
  774|      0|			lookback += instructions[IC + 1];
  775|      0|			IC += 2;
  776|      0|			continue;
  777|      0|
  778|      0|		case pass_not:
  779|      0|		case pass_startReplace:
  780|      0|		case pass_endReplace:
  781|      0|		case pass_first:
  782|      0|		case pass_last:
  783|      0|		case pass_copy:
  784|      0|		case pass_omit:
  785|      0|		case pass_plus:
  786|      0|		case pass_hyphen:
  787|      0|			IC += 1;
  788|      0|			continue;
  789|      0|
  790|      0|		case pass_endTest:
  791|      0|			goto NO_CHARACTERS;
  792|      0|
  793|      0|		default:
  794|      0|			compileError(file, "unhandled test suboperand: \\x%02x", instruction);
  795|      0|			return 0;
  796|      0|		}
  797|      0|	}
  798|      0|	goto NO_CHARACTERS;
  799|      0|}
  800|       |
  801|       |static const char *
  802|      0|printSource(const FileInfo *currentFile, const char *sourceFile, int sourceLine) {
  803|      0|	static char scratchBuf[MAXSTRING];
  804|      0|	if (sourceFile) {
  805|      0|		if (currentFile && currentFile->sourceFile &&
  806|      0|				strcmp(currentFile->sourceFile, sourceFile) == 0)
  807|      0|			snprintf(scratchBuf, MAXSTRING, "line %d", sourceLine);
  808|      0|		else
  809|      0|			snprintf(scratchBuf, MAXSTRING, "%s:%d", sourceFile, sourceLine);
  810|      0|	} else
  811|      0|		snprintf(scratchBuf, MAXSTRING, "source unknown");
  812|      0|	return scratchBuf;
  813|      0|}
  814|       |
  815|       |/* The following functions are called by addRule to handle various cases. */
  816|       |
  817|       |static void
  818|       |addForwardRuleWithSingleChar(const FileInfo *file, TranslationTableOffset ruleOffset,
  819|      0|		TranslationTableRule *rule, TranslationTableHeader **table) {
  820|      0|	/* direction = 0, rule->charslen = 1 */
  821|      0|	TranslationTableCharacter *character;
  822|      0|	// get the character from the table, or if the character is not defined yet, define it
  823|      0|	// (without adding attributes)
  824|      0|	if (rule->opcode >= CTO_Pass2 && rule->opcode <= CTO_Pass4) {
  825|      0|		character = putDots(file, rule->charsdots[0], table);
  826|      0|		// putDots may have moved table, so make sure rule is still valid
  827|      0|		rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];
  828|      0|	} else if (rule->opcode == CTO_CompDots || rule->opcode == CTO_Comp6) {
  829|      0|		character = putChar(file, rule->charsdots[0], table, NULL);
  830|      0|		// putChar may have moved table, so make sure rule is still valid
  831|      0|		rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];
  832|      0|		character->compRule = ruleOffset;
  833|      0|		return;
  834|      0|	} else {
  835|      0|		character = putChar(file, rule->charsdots[0], table, NULL);
  836|      0|		// putChar may have moved table, so make sure rule is still valid
  837|      0|		rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];
  838|      0|		// if the new rule is a character definition rule, set the main definition rule of
  839|      0|		// this character to it (possibly overwriting previous definition rules)
  840|      0|		// adding the attributes to the character has already been done elsewhere
  841|      0|		if (rule->opcode >= CTO_Space && rule->opcode < CTO_UpLow) {
  842|      0|			if (character->definitionRule) {
  843|      0|				TranslationTableRule *prevRule =
  844|      0|						(TranslationTableRule *)&(*table)
  845|      0|								->ruleArea[character->definitionRule];
  846|      0|				_lou_logMessage(LOU_LOG_DEBUG,
  847|      0|						"%s:%d: Character already defined (%s). The new definition will "
  848|      0|						"take precedence.",
  849|      0|						file->fileName, file->lineNumber,
  850|      0|						printSource(file, prevRule->sourceFile, prevRule->sourceLine));
  851|      0|			} else if (character->basechar) {
  852|      0|				_lou_logMessage(LOU_LOG_DEBUG,
  853|      0|						"%s:%d: A base rule already exists for this character (%s). The "
  854|      0|						"%s rule will take precedence.",
  855|      0|						file->fileName, file->lineNumber,
  856|      0|						printSource(file, character->sourceFile, character->sourceLine),
  857|      0|						_lou_findOpcodeName(rule->opcode));
  858|      0|				character->basechar = 0;
  859|      0|				character->mode = 0;
  860|      0|			}
  861|      0|			character->definitionRule = ruleOffset;
  862|      0|		}
  863|      0|	}
  864|      0|	// add the new rule to the list of rules associated with this character
  865|      0|	// if the new rule is a character definition rule, it is inserted at the end of the
  866|      0|	// list
  867|      0|	// otherwise it is inserted before the first character definition rule
  868|      0|	TranslationTableOffset *otherRule = &character->otherRules;
  869|      0|	while (*otherRule) {
  870|      0|		TranslationTableRule *r = (TranslationTableRule *)&(*table)->ruleArea[*otherRule];
  871|      0|		if (r->charslen == 0) break;
  872|      0|		if (r->opcode >= CTO_Space && r->opcode < CTO_UpLow)
  873|      0|			if (!(rule->opcode >= CTO_Space && rule->opcode < CTO_UpLow)) break;
  874|      0|		otherRule = &r->charsnext;
  875|      0|	}
  876|      0|	rule->charsnext = *otherRule;
  877|      0|	*otherRule = ruleOffset;
  878|      0|}
  879|       |
  880|       |static void
  881|       |addForwardRuleWithMultipleChars(TranslationTableOffset ruleOffset,
  882|      0|		TranslationTableRule *rule, TranslationTableHeader *table) {
  883|      0|	/* direction = 0 rule->charslen > 1 */
  884|      0|	TranslationTableOffset *forRule =
  885|      0|			&table->forRules[_lou_stringHash(&rule->charsdots[0], 0, NULL)];
  886|      0|	while (*forRule) {
  887|      0|		TranslationTableRule *r = (TranslationTableRule *)&table->ruleArea[*forRule];
  888|      0|		if (rule->charslen > r->charslen) break;
  889|      0|		if (rule->charslen == r->charslen)
  890|      0|			if ((r->opcode == CTO_Always) && (rule->opcode != CTO_Always)) break;
  891|      0|		forRule = &r->charsnext;
  892|      0|	}
  893|      0|	rule->charsnext = *forRule;
  894|      0|	*forRule = ruleOffset;
  895|      0|}
  896|       |
  897|       |static void
  898|       |addBackwardRuleWithSingleCell(const FileInfo *file, widechar cell,
  899|       |		TranslationTableOffset ruleOffset, TranslationTableRule *rule,
  900|      0|		TranslationTableHeader **table) {
  901|      0|	/* direction = 1, rule->dotslen = 1 */
  902|      0|	TranslationTableCharacter *dots;
  903|      0|	if (rule->opcode == CTO_SwapCc || rule->opcode == CTO_Repeated)
  904|      0|		return; /* too ambiguous */
  905|      0|	// get the cell from the table, or if the cell is not defined yet, define it (without
  906|      0|	// adding attributes)
  907|      0|	dots = putDots(file, cell, table);
  908|      0|	// putDots may have moved table, so make sure rule is still valid
  909|      0|	rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];
  910|      0|	if (rule->opcode >= CTO_Space && rule->opcode < CTO_UpLow)
  911|      0|		dots->definitionRule = ruleOffset;
  912|      0|	TranslationTableOffset *otherRule = &dots->otherRules;
  913|      0|	while (*otherRule) {
  914|      0|		TranslationTableRule *r = (TranslationTableRule *)&(*table)->ruleArea[*otherRule];
  915|      0|		if (rule->charslen > r->charslen || r->dotslen == 0) break;
  916|      0|		if (r->opcode >= CTO_Space && r->opcode < CTO_UpLow)
  917|      0|			if (!(rule->opcode >= CTO_Space && rule->opcode < CTO_UpLow)) break;
  918|      0|		otherRule = &r->dotsnext;
  919|      0|	}
  920|      0|	rule->dotsnext = *otherRule;
  921|      0|	*otherRule = ruleOffset;
  922|      0|}
  923|       |
  924|       |static void
  925|       |addBackwardRuleWithMultipleCells(widechar *cells, int dotslen,
  926|       |		TranslationTableOffset ruleOffset, TranslationTableRule *rule,
  927|      0|		TranslationTableHeader *table) {
  928|      0|	/* direction = 1, dotslen > 1 */
  929|      0|	TranslationTableOffset *backRule = &table->backRules[_lou_stringHash(cells, 0, NULL)];
  930|      0|	if (rule->opcode == CTO_SwapCc) return;
  931|      0|	int ruleLength = dotslen + rule->charslen;
  932|      0|	while (*backRule) {
  933|      0|		TranslationTableRule *r = (TranslationTableRule *)&table->ruleArea[*backRule];
  934|      0|		int rLength = r->dotslen + r->charslen;
  935|      0|		if (ruleLength > rLength) break;
  936|      0|		if (rLength == ruleLength)
  937|      0|			if ((r->opcode == CTO_Always) && (rule->opcode != CTO_Always)) break;
  938|      0|		backRule = &r->dotsnext;
  939|      0|	}
  940|      0|	rule->dotsnext = *backRule;
  941|      0|	*backRule = ruleOffset;
  942|      0|}
  943|       |
  944|       |static int
  945|       |addForwardPassRule(TranslationTableOffset ruleOffset, TranslationTableRule *rule,
  946|      0|		TranslationTableHeader *table) {
  947|      0|	TranslationTableOffset *forPassRule;
  948|      0|	switch (rule->opcode) {
  949|      0|	case CTO_Correct:
  950|      0|		forPassRule = &table->forPassRules[0];
  951|      0|		break;
  952|      0|	case CTO_Context:
  953|      0|		forPassRule = &table->forPassRules[1];
  954|      0|		break;
  955|      0|	case CTO_Pass2:
  956|      0|		forPassRule = &table->forPassRules[2];
  957|      0|		break;
  958|      0|	case CTO_Pass3:
  959|      0|		forPassRule = &table->forPassRules[3];
  960|      0|		break;
  961|      0|	case CTO_Pass4:
  962|      0|		forPassRule = &table->forPassRules[4];
  963|      0|		break;
  964|      0|	default:
  965|      0|		return 0;
  966|      0|	}
  967|      0|	while (*forPassRule) {
  968|      0|		TranslationTableRule *r = (TranslationTableRule *)&table->ruleArea[*forPassRule];
  969|      0|		if (rule->charslen > r->charslen) break;
  970|      0|		forPassRule = &r->charsnext;
  971|      0|	}
  972|      0|	rule->charsnext = *forPassRule;
  973|      0|	*forPassRule = ruleOffset;
  974|      0|	return 1;
  975|      0|}
  976|       |
  977|       |static int
  978|       |addBackwardPassRule(TranslationTableOffset ruleOffset, TranslationTableRule *rule,
  979|      0|		TranslationTableHeader *table) {
  980|      0|	TranslationTableOffset *backPassRule;
  981|      0|	switch (rule->opcode) {
  982|      0|	case CTO_Correct:
  983|      0|		backPassRule = &table->backPassRules[0];
  984|      0|		break;
  985|      0|	case CTO_Context:
  986|      0|		backPassRule = &table->backPassRules[1];
  987|      0|		break;
  988|      0|	case CTO_Pass2:
  989|      0|		backPassRule = &table->backPassRules[2];
  990|      0|		break;
  991|      0|	case CTO_Pass3:
  992|      0|		backPassRule = &table->backPassRules[3];
  993|      0|		break;
  994|      0|	case CTO_Pass4:
  995|      0|		backPassRule = &table->backPassRules[4];
  996|      0|		break;
  997|      0|	default:
  998|      0|		return 0;
  999|      0|	}
 1000|      0|	while (*backPassRule) {
 1001|      0|		TranslationTableRule *r = (TranslationTableRule *)&table->ruleArea[*backPassRule];
 1002|      0|		if (rule->charslen > r->charslen) break;
 1003|      0|		backPassRule = &r->dotsnext;
 1004|      0|	}
 1005|      0|	rule->dotsnext = *backPassRule;
 1006|      0|	*backPassRule = ruleOffset;
 1007|      0|	return 1;
 1008|      0|}
 1009|       |
 1010|       |static int
 1011|       |addRule(const FileInfo *file, TranslationTableOpcode opcode, CharsString *ruleChars,
 1012|       |		CharsString *ruleDots, TranslationTableCharacterAttributes after,
 1013|       |		TranslationTableCharacterAttributes before, TranslationTableOffset *ruleOffset,
 1014|       |		TranslationTableRule **rule, int noback, int nofor,
 1015|      0|		TranslationTableHeader **table) {
 1016|      0|	/* Add a rule to the table, using the hash function to find the start of
 1017|      0|	 * chains and chaining both the chars and dots strings */
 1018|      0|	TranslationTableOffset offset;
 1019|      0|	int ruleSize = sizeof(TranslationTableRule) - (DEFAULTRULESIZE * CHARSIZE);
 1020|      0|	if (ruleChars) ruleSize += CHARSIZE * ruleChars->length;
 1021|      0|	if (ruleDots) ruleSize += CHARSIZE * ruleDots->length;
 1022|      0|	if (!allocateSpaceInTranslationTable(file, &offset, ruleSize, table)) return 0;
 1023|      0|	TranslationTableRule *r = (TranslationTableRule *)&(*table)->ruleArea[offset];
 1024|      0|	if (rule) *rule = r;
 1025|      0|	if (ruleOffset) *ruleOffset = offset;
 1026|      0|	r->sourceFile = file->sourceFile;
 1027|      0|	r->sourceLine = file->lineNumber;
 1028|      0|	r->opcode = opcode;
 1029|      0|	r->after = after;
 1030|      0|	r->before = before;
 1031|      0|	r->nocross = 0;
 1032|      0|	if (ruleChars)
 1033|      0|		memcpy(&r->charsdots[0], &ruleChars->chars[0],
 1034|      0|				CHARSIZE * (r->charslen = ruleChars->length));
 1035|      0|	else
 1036|      0|		r->charslen = 0;
 1037|      0|	if (ruleDots)
 1038|      0|		memcpy(&r->charsdots[r->charslen], &ruleDots->chars[0],
 1039|      0|				CHARSIZE * (r->dotslen = ruleDots->length));
 1040|      0|	else
 1041|      0|		r->dotslen = 0;
 1042|      0|
 1043|      0|	/* link new rule into table. */
 1044|      0|	if (opcode == CTO_SwapCc || opcode == CTO_SwapCd || opcode == CTO_SwapDd) return 1;
 1045|      0|	if (opcode >= CTO_Context && opcode <= CTO_Pass4)
 1046|      0|		if (!(opcode == CTO_Context && r->charslen > 0)) {
 1047|      0|			if (!nofor)
 1048|      0|				if (!addForwardPassRule(offset, r, *table)) return 0;
 1049|      0|			if (!noback)
 1050|      0|				if (!addBackwardPassRule(offset, r, *table)) return 0;
 1051|      0|			return 1;
 1052|      0|		}
 1053|      0|	if (!nofor) {
 1054|      0|		if (r->charslen == 1) {
 1055|      0|			addForwardRuleWithSingleChar(file, offset, r, table);
 1056|      0|			// addForwardRuleWithSingleChar may have moved table, so make sure rule is
 1057|      0|			// still valid
 1058|      0|			r = (TranslationTableRule *)&(*table)->ruleArea[offset];
 1059|      0|			if (rule) *rule = r;
 1060|      0|		} else if (r->charslen > 1)
 1061|      0|			addForwardRuleWithMultipleChars(offset, r, *table);
 1062|      0|	}
 1063|      0|	if (!noback) {
 1064|      0|		widechar *cells;
 1065|      0|		int dotslen;
 1066|      0|
 1067|      0|		if (r->opcode == CTO_Context) {
 1068|      0|			cells = &r->charsdots[0];
 1069|      0|			dotslen = r->charslen;
 1070|      0|		} else {
 1071|      0|			cells = &r->charsdots[r->charslen];
 1072|      0|			dotslen = r->dotslen;
 1073|      0|		}
 1074|      0|		if (dotslen == 1) {
 1075|      0|			addBackwardRuleWithSingleCell(file, *cells, offset, r, table);
 1076|      0|			// addBackwardRuleWithSingleCell may have moved table, so make sure rule is
 1077|      0|			// still valid
 1078|      0|			r = (TranslationTableRule *)&(*table)->ruleArea[offset];
 1079|      0|			if (rule) *rule = r;
 1080|      0|		} else if (dotslen > 1)
 1081|      0|			addBackwardRuleWithMultipleCells(cells, dotslen, offset, r, *table);
 1082|      0|	}
 1083|      0|	return 1;
 1084|      0|}
 1085|       |
 1086|       |static const CharacterClass *
 1087|      0|findCharacterClass(const CharsString *name, const TranslationTableHeader *table) {
 1088|      0|	/* Find a character class, whether predefined or user-defined */
 1089|      0|	const CharacterClass *class = table->characterClasses;
 1090|      0|	while (class) {
 1091|      0|		if ((name->length == class->length) &&
 1092|      0|				(memcmp(&name->chars[0], class->name, CHARSIZE * name->length) == 0))
 1093|      0|			return class;
 1094|      0|		class = class->next;
 1095|      0|	}
 1096|      0|	return NULL;
 1097|      0|}
 1098|       |
 1099|       |static TranslationTableCharacterAttributes
 1100|      0|getNextNumberedAttribute(TranslationTableHeader *table) {
 1101|      0|	/* Get the next attribute value for numbered attributes, or 0 if there is no more
 1102|      0|	 * space in the table. */
 1103|      0|	TranslationTableCharacterAttributes next = table->nextNumberedCharacterClassAttribute;
 1104|      0|	if (next > CTC_UserDefined8) return 0;
 1105|      0|	table->nextNumberedCharacterClassAttribute <<= 1;
 1106|      0|	return next;
 1107|      0|}
 1108|       |
 1109|       |static TranslationTableCharacterAttributes
 1110|      0|getNextAttribute(TranslationTableHeader *table) {
 1111|      0|	/* Get the next attribute value, or 0 if there is no more space in the table. */
 1112|      0|	TranslationTableCharacterAttributes next = table->nextCharacterClassAttribute;
 1113|      0|	if (next) {
 1114|      0|		if (next == CTC_LitDigit)
 1115|      0|			table->nextCharacterClassAttribute = CTC_UserDefined9;
 1116|      0|		else
 1117|      0|			table->nextCharacterClassAttribute <<= 1;
 1118|      0|		return next;
 1119|      0|	} else
 1120|      0|		return getNextNumberedAttribute(table);
 1121|      0|}
 1122|       |
 1123|       |static CharacterClass *
 1124|       |addCharacterClass(const FileInfo *file, const widechar *name, int length,
 1125|      0|		TranslationTableHeader *table, int validate) {
 1126|      0|	/* Define a character class, Whether predefined or user-defined */
 1127|      0|	if (validate) {
 1128|      0|		for (int i = 0; i < length; i++) {
 1129|      0|			if (!((name[i] >= 'a' && name[i] <= 'z') ||
 1130|      0|						(name[i] >= 'A' && name[i] <= 'Z'))) {
 1131|      0|				// don't abort because in some cases (before/after rules)
 1132|      0|				// this will work fine, but it will not work in multipass
 1133|      0|				// expressions
 1134|      0|				compileWarning(file,
 1135|      0|						"Invalid attribute name: must be a digit between "
 1136|      0|						"0 and 7 or a word containing only letters");
 1137|      0|			}
 1138|      0|		}
 1139|      0|		// check that name is not reserved
 1140|      0|		int k = 0;
 1141|      0|		while (reservedAttributeNames[k]) {
 1142|      0|			if (strlen(reservedAttributeNames[k]) == length) {
 1143|      0|				int i;
 1144|      0|				for (i = 0; i < length; i++)
 1145|      0|					if (reservedAttributeNames[k][i] != name[i]) break;
 1146|      0|				if (i == length) {
 1147|      0|					compileError(file, "Attribute name is reserved: %s",
 1148|      0|							reservedAttributeNames[k]);
 1149|      0|					return NULL;
 1150|      0|				}
 1151|      0|			}
 1152|      0|			k++;
 1153|      0|		}
 1154|      0|	}
 1155|      0|	CharacterClass **classes = &table->characterClasses;
 1156|      0|	TranslationTableCharacterAttributes attribute = getNextAttribute(table);
 1157|      0|	CharacterClass *class;
 1158|      0|	if (attribute) {
 1159|      0|		if (!(class = malloc(sizeof(*class) + CHARSIZE * (length - 1))))
 1160|      0|			_lou_outOfMemory();
 1161|      0|		else {
 1162|      0|			memset(class, 0, sizeof(*class));
 1163|      0|			memcpy(class->name, name, CHARSIZE * (class->length = length));
 1164|      0|			class->attribute = attribute;
 1165|      0|			class->next = *classes;
 1166|      0|			*classes = class;
 1167|      0|			return class;
 1168|      0|		}
 1169|      0|	}
 1170|      0|	compileError(file, "character class table overflow.");
 1171|      0|	return NULL;
 1172|      0|}
 1173|       |
 1174|       |static void
 1175|      0|deallocateCharacterClasses(TranslationTableHeader *table) {
 1176|      0|	CharacterClass **classes = &table->characterClasses;
 1177|      0|	while (*classes) {
 1178|      0|		CharacterClass *class = *classes;
 1179|      0|		*classes = (*classes)->next;
 1180|      0|		if (class) free(class);
 1181|      0|	}
 1182|      0|}
 1183|       |
 1184|       |static int
 1185|      0|allocateCharacterClasses(TranslationTableHeader *table) {
 1186|      0|	/* Allocate memory for predefined character classes */
 1187|      0|	int k = 0;
 1188|      0|	table->characterClasses = NULL;
 1189|      0|	table->nextCharacterClassAttribute = 1;	 // CTC_Space
 1190|      0|	table->nextNumberedCharacterClassAttribute = CTC_UserDefined1;
 1191|      0|	while (characterClassNames[k]) {
 1192|      0|		widechar wname[MAXSTRING];
 1193|      0|		int length = (int)strlen(characterClassNames[k]);
 1194|      0|		int kk;
 1195|      0|		for (kk = 0; kk < length; kk++) wname[kk] = (widechar)characterClassNames[k][kk];
 1196|      0|		if (!addCharacterClass(NULL, wname, length, table, 0)) {
 1197|      0|			deallocateCharacterClasses(table);
 1198|      0|			return 0;
 1199|      0|		}
 1200|      0|		k++;
 1201|      0|	}
 1202|      0|	return 1;
 1203|      0|}
 1204|       |
 1205|       |static TranslationTableOpcode
 1206|      0|getOpcode(const FileInfo *file, const CharsString *token) {
 1207|      0|	static TranslationTableOpcode lastOpcode = 0;
 1208|      0|	TranslationTableOpcode opcode = lastOpcode;
 1209|      0|
 1210|      0|	do {
 1211|      0|		if (token->length == opcodeLengths[opcode])
 1212|      0|			if (eqasc2uni((unsigned char *)opcodeNames[opcode], &token->chars[0],
 1213|      0|						token->length)) {
 1214|      0|				lastOpcode = opcode;
 1215|      0|				return opcode;
 1216|      0|			}
 1217|      0|		opcode++;
 1218|      0|		if (opcode >= CTO_None) opcode = 0;
 1219|      0|	} while (opcode != lastOpcode);
 1220|      0|	return CTO_None;
 1221|      0|}
 1222|       |
 1223|       |TranslationTableOpcode EXPORT_CALL
 1224|      0|_lou_findOpcodeNumber(const char *toFind) {
 1225|      0|	/* Used by tools such as lou_debug */
 1226|      0|	static TranslationTableOpcode lastOpcode = 0;
 1227|      0|	TranslationTableOpcode opcode = lastOpcode;
 1228|      0|	int length = (int)strlen(toFind);
 1229|      0|	do {
 1230|      0|		if (length == opcodeLengths[opcode] &&
 1231|      0|				strcasecmp(toFind, opcodeNames[opcode]) == 0) {
 1232|      0|			lastOpcode = opcode;
 1233|      0|			return opcode;
 1234|      0|		}
 1235|      0|		opcode++;
 1236|      0|		if (opcode >= CTO_None) opcode = 0;
 1237|      0|	} while (opcode != lastOpcode);
 1238|      0|	return CTO_None;
 1239|      0|}
 1240|       |
 1241|       |const char *EXPORT_CALL
 1242|      0|_lou_findOpcodeName(TranslationTableOpcode opcode) {
 1243|      0|	static char scratchBuf[MAXSTRING];
 1244|      0|	/* Used by tools such as lou_debug */
 1245|      0|	if (opcode < 0 || opcode >= CTO_None) {
 1246|      0|		sprintf(scratchBuf, "%u", opcode);
 1247|      0|		return scratchBuf;
 1248|      0|	}
 1249|      0|	return opcodeNames[opcode];
 1250|      0|}
 1251|       |
 1252|       |static widechar
 1253|      0|hexValue(const FileInfo *file, const widechar *digits, int length) {
 1254|      0|	int k;
 1255|      0|	unsigned int binaryValue = 0;
 1256|      0|	for (k = 0; k < length; k++) {
 1257|      0|		unsigned int hexDigit = 0;
 1258|      0|		if (digits[k] >= '0' && digits[k] <= '9')
 1259|      0|			hexDigit = digits[k] - '0';
 1260|      0|		else if (digits[k] >= 'a' && digits[k] <= 'f')
 1261|      0|			hexDigit = digits[k] - 'a' + 10;
 1262|      0|		else if (digits[k] >= 'A' && digits[k] <= 'F')
 1263|      0|			hexDigit = digits[k] - 'A' + 10;
 1264|      0|		else {
 1265|      0|			compileError(file, "invalid %d-digit hexadecimal number", length);
 1266|      0|			return (widechar)0xffffffff;
 1267|      0|		}
 1268|      0|		binaryValue |= hexDigit << (4 * (length - 1 - k));
 1269|      0|	}
 1270|      0|	return (widechar)binaryValue;
 1271|      0|}
 1272|       |
 1273|      0|#define MAXBYTES 7
 1274|       |static const unsigned int first0Bit[MAXBYTES] = { 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC,
 1275|       |	0XFE };
 1276|       |
 1277|       |static int
 1278|      0|parseChars(const FileInfo *file, CharsString *result, CharsString *token) {
 1279|      0|	int in = 0;
 1280|      0|	int out = 0;
 1281|      0|	int lastOutSize = 0;
 1282|      0|	int lastIn;
 1283|      0|	unsigned int ch = 0;
 1284|      0|	int numBytes = 0;
 1285|      0|	unsigned int utf32 = 0;
 1286|      0|	int k;
 1287|      0|	while (in < token->length) {
 1288|      0|		ch = token->chars[in++] & 0xff;
 1289|      0|		if (ch < 128) {
 1290|      0|			if (ch == '\\') { /* escape sequence */
 1291|      0|				switch (ch = token->chars[in]) {
 1292|      0|				case '\\':
 1293|      0|					break;
 1294|      0|				case 'e':
 1295|      0|					ch = 0x1b;
 1296|      0|					break;
 1297|      0|				case 'f':
 1298|      0|					ch = 12;
 1299|      0|					break;
 1300|      0|				case 'n':
 1301|      0|					ch = 10;
 1302|      0|					break;
 1303|      0|				case 'r':
 1304|      0|					ch = 13;
 1305|      0|					break;
 1306|      0|				case 's':
 1307|      0|					ch = ' ';
 1308|      0|					break;
 1309|      0|				case 't':
 1310|      0|					ch = 9;
 1311|      0|					break;
 1312|      0|				case 'v':
 1313|      0|					ch = 11;
 1314|      0|					break;
 1315|      0|				case 'w':
 1316|      0|					ch = LOU_ENDSEGMENT;
 1317|      0|					break;
 1318|      0|				case 34:
 1319|      0|					ch = QUOTESUB;
 1320|      0|					break;
 1321|      0|				case 'X':
 1322|      0|					compileWarning(file, "\\Xhhhh (with a capital 'X') is deprecated.");
 1323|      0|				case 'x':
 1324|      0|					if (token->length - in > 4) {
 1325|      0|						ch = hexValue(file, &token->chars[in + 1], 4);
 1326|      0|						in += 4;
 1327|      0|					}
 1328|      0|					break;
 1329|      0|				case 'Y':
 1330|      0|					compileWarning(file, "\\Yhhhhh (with a capital 'Y') is deprecated.");
 1331|      0|				case 'y':
 1332|      0|					if (CHARSIZE == 2) {
 1333|      0|					not32:
 1334|      0|						compileError(file,
 1335|      0|								"liblouis has not been compiled for 32-bit Unicode");
 1336|      0|						break;
 1337|      0|					}
 1338|      0|					if (token->length - in > 5) {
 1339|      0|						ch = hexValue(file, &token->chars[in + 1], 5);
 1340|      0|						in += 5;
 1341|      0|					}
 1342|      0|					break;
 1343|      0|				case 'Z':
 1344|      0|					compileWarning(
 1345|      0|							file, "\\Zhhhhhhhh (with a capital 'Z') is deprecated.");
 1346|      0|				case 'z':
 1347|      0|					if (CHARSIZE == 2) goto not32;
 1348|      0|					if (token->length - in > 8) {
 1349|      0|						ch = hexValue(file, &token->chars[in + 1], 8);
 1350|      0|						in += 8;
 1351|      0|					}
 1352|      0|					break;
 1353|      0|				default:
 1354|      0|					compileError(file, "invalid escape sequence '\\%c'", ch);
 1355|      0|					break;
 1356|      0|				}
 1357|      0|				in++;
 1358|      0|			}
 1359|      0|			if (out >= MAXSTRING - 1) {
 1360|      0|				compileError(file, "Token too long");
 1361|      0|				result->length = MAXSTRING - 1;
 1362|      0|				return 1;
 1363|      0|			}
 1364|      0|			result->chars[out++] = (widechar)ch;
 1365|      0|			continue;
 1366|      0|		}
 1367|      0|		lastOutSize = out;
 1368|      0|		lastIn = in;
 1369|      0|		for (numBytes = MAXBYTES - 1; numBytes > 0; numBytes--)
 1370|      0|			if (ch >= first0Bit[numBytes]) break;
 1371|      0|		utf32 = ch & (0XFF - first0Bit[numBytes]);
 1372|      0|		for (k = 0; k < numBytes; k++) {
 1373|      0|			if (in >= MAXSTRING - 1) break;
 1374|      0|			if (out >= MAXSTRING - 1) {
 1375|      0|				compileError(file, "Token too long");
 1376|      0|				result->length = lastOutSize;
 1377|      0|				return 1;
 1378|      0|			}
 1379|      0|			if (token->chars[in] < 128 || (token->chars[in] & 0x0040)) {
 1380|      0|				compileWarning(file, "invalid UTF-8. Assuming Latin-1.");
 1381|      0|				result->chars[out++] = token->chars[lastIn];
 1382|      0|				in = lastIn + 1;
 1383|      0|				continue;
 1384|      0|			}
 1385|      0|			utf32 = (utf32 << 6) + (token->chars[in++] & 0x3f);
 1386|      0|		}
 1387|      0|		if (out >= MAXSTRING - 1) {
 1388|      0|			compileError(file, "Token too long");
 1389|      0|			result->length = lastOutSize;
 1390|      0|			return 1;
 1391|      0|		}
 1392|      0|		if (CHARSIZE == 2 && utf32 > 0xffff) utf32 = 0xffff;
 1393|      0|		result->chars[out++] = (widechar)utf32;
 1394|      0|	}
 1395|      0|	result->length = out;
 1396|      0|	return 1;
 1397|      0|}
 1398|       |
 1399|       |int EXPORT_CALL
 1400|      0|_lou_extParseChars(const char *inString, widechar *outString) {
 1401|      0|	/* Parse external character strings */
 1402|      0|	CharsString wideIn;
 1403|      0|	CharsString result;
 1404|      0|	int k;
 1405|      0|	for (k = 0; inString[k] && k < MAXSTRING - 1; k++) wideIn.chars[k] = inString[k];
 1406|      0|	wideIn.chars[k] = 0;
 1407|      0|	wideIn.length = k;
 1408|      0|	parseChars(NULL, &result, &wideIn);
 1409|      0|	if (errorCount) {
 1410|      0|		errorCount = 0;
 1411|      0|		return 0;
 1412|      0|	}
 1413|      0|	for (k = 0; k < result.length; k++) outString[k] = result.chars[k];
 1414|      0|	return result.length;
 1415|      0|}
 1416|       |
 1417|       |static int
 1418|      0|parseDots(const FileInfo *file, CharsString *cells, const CharsString *token) {
 1419|      0|	/* get dot patterns */
 1420|      0|	widechar cell = 0; /* assembly place for dots */
 1421|      0|	int cellCount = 0;
 1422|      0|	int index;
 1423|      0|	int start = 0;
 1424|      0|
 1425|      0|	for (index = 0; index < token->length; index++) {
 1426|      0|		int started = index != start;
 1427|      0|		widechar character = token->chars[index];
 1428|      0|		switch (character) { /* or dots to make up Braille cell */
 1429|      0|			{
 1430|      0|				int dot;
 1431|      0|			case '1':
 1432|      0|				dot = LOU_DOT_1;
 1433|      0|				goto haveDot;
 1434|      0|			case '2':
 1435|      0|				dot = LOU_DOT_2;
 1436|      0|				goto haveDot;
 1437|      0|			case '3':
 1438|      0|				dot = LOU_DOT_3;
 1439|      0|				goto haveDot;
 1440|      0|			case '4':
 1441|      0|				dot = LOU_DOT_4;
 1442|      0|				goto haveDot;
 1443|      0|			case '5':
 1444|      0|				dot = LOU_DOT_5;
 1445|      0|				goto haveDot;
 1446|      0|			case '6':
 1447|      0|				dot = LOU_DOT_6;
 1448|      0|				goto haveDot;
 1449|      0|			case '7':
 1450|      0|				dot = LOU_DOT_7;
 1451|      0|				goto haveDot;
 1452|      0|			case '8':
 1453|      0|				dot = LOU_DOT_8;
 1454|      0|				goto haveDot;
 1455|      0|			case '9':
 1456|      0|				dot = LOU_DOT_9;
 1457|      0|				goto haveDot;
 1458|      0|			case 'a':
 1459|      0|			case 'A':
 1460|      0|				dot = LOU_DOT_10;
 1461|      0|				goto haveDot;
 1462|      0|			case 'b':
 1463|      0|			case 'B':
 1464|      0|				dot = LOU_DOT_11;
 1465|      0|				goto haveDot;
 1466|      0|			case 'c':
 1467|      0|			case 'C':
 1468|      0|				dot = LOU_DOT_12;
 1469|      0|				goto haveDot;
 1470|      0|			case 'd':
 1471|      0|			case 'D':
 1472|      0|				dot = LOU_DOT_13;
 1473|      0|				goto haveDot;
 1474|      0|			case 'e':
 1475|      0|			case 'E':
 1476|      0|				dot = LOU_DOT_14;
 1477|      0|				goto haveDot;
 1478|      0|			case 'f':
 1479|      0|			case 'F':
 1480|      0|				dot = LOU_DOT_15;
 1481|      0|			haveDot:
 1482|      0|				if (started && !cell) goto invalid;
 1483|      0|				if (cell & dot) {
 1484|      0|					compileError(file, "dot specified more than once.");
 1485|      0|					return 0;
 1486|      0|				}
 1487|      0|				cell |= dot;
 1488|      0|				break;
 1489|      0|			}
 1490|      0|		case '0': /* blank */
 1491|      0|			if (started) goto invalid;
 1492|      0|			break;
 1493|      0|		case '-': /* got all dots for this cell */
 1494|      0|			if (!started) {
 1495|      0|				compileError(file, "missing cell specification.");
 1496|      0|				return 0;
 1497|      0|			}
 1498|      0|			cells->chars[cellCount++] = cell | LOU_DOTS;
 1499|      0|			cell = 0;
 1500|      0|			start = index + 1;
 1501|      0|			break;
 1502|      0|		default:
 1503|      0|		invalid:
 1504|      0|			compileError(
 1505|      0|					file, "invalid dot number %s.", _lou_showString(&character, 1, 0));
 1506|      0|			return 0;
 1507|      0|		}
 1508|      0|	}
 1509|      0|	if (index == start) {
 1510|      0|		compileError(file, "missing cell specification.");
 1511|      0|		return 0;
 1512|      0|	}
 1513|      0|	cells->chars[cellCount++] = cell | LOU_DOTS; /* last cell */
 1514|      0|	cells->length = cellCount;
 1515|      0|	return 1;
 1516|      0|}
 1517|       |
 1518|       |int EXPORT_CALL
 1519|      0|_lou_extParseDots(const char *inString, widechar *outString) {
 1520|      0|	/* Parse external dot patterns */
 1521|      0|	CharsString wideIn;
 1522|      0|	CharsString result;
 1523|      0|	int k;
 1524|      0|	for (k = 0; inString[k] && k < MAXSTRING - 1; k++) wideIn.chars[k] = inString[k];
 1525|      0|	wideIn.chars[k] = 0;
 1526|      0|	wideIn.length = k;
 1527|      0|	parseDots(NULL, &result, &wideIn);
 1528|      0|	if (errorCount) {
 1529|      0|		errorCount = 0;
 1530|      0|		return 0;
 1531|      0|	}
 1532|      0|	for (k = 0; k < result.length; k++) outString[k] = result.chars[k];
 1533|      0|	outString[k] = 0;
 1534|      0|	return result.length;
 1535|      0|}
 1536|       |
 1537|       |static int
 1538|      0|getCharacters(FileInfo *file, CharsString *characters) {
 1539|      0|	/* Get ruleChars string */
 1540|      0|	CharsString token;
 1541|      0|	if (!getToken(file, &token, "characters")) return 0;
 1542|      0|	return parseChars(file, characters, &token);
 1543|      0|}
 1544|       |
 1545|       |static int
 1546|      0|getRuleCharsText(FileInfo *file, CharsString *ruleChars) {
 1547|      0|	CharsString token;
 1548|      0|	if (!getToken(file, &token, "Characters operand")) return 0;
 1549|      0|	return parseChars(file, ruleChars, &token);
 1550|      0|}
 1551|       |
 1552|       |static int
 1553|      0|getRuleDotsText(FileInfo *file, CharsString *ruleDots) {
 1554|      0|	CharsString token;
 1555|      0|	if (!getToken(file, &token, "characters")) return 0;
 1556|      0|	return parseChars(file, ruleDots, &token);
 1557|      0|}
 1558|       |
 1559|       |static int
 1560|      0|getRuleDotsPattern(FileInfo *file, CharsString *ruleDots) {
 1561|      0|	/* Interpret the dets operand */
 1562|      0|	CharsString token;
 1563|      0|	if (!getToken(file, &token, "Dots operand")) return 0;
 1564|      0|	if (token.length == 1 && token.chars[0] == '=') {
 1565|      0|		ruleDots->length = 0;
 1566|      0|		return 1;
 1567|      0|	} else
 1568|      0|		return parseDots(file, ruleDots, &token);
 1569|      0|}
 1570|       |
 1571|       |static int
 1572|       |includeFile(const FileInfo *file, CharsString *includedFile,
 1573|       |		TranslationTableHeader **table, DisplayTableHeader **displayTable);
 1574|       |
 1575|       |static TranslationTableOffset
 1576|      0|findRuleName(const CharsString *name, const TranslationTableHeader *table) {
 1577|      0|	const RuleName *ruleName = table->ruleNames;
 1578|      0|	while (ruleName) {
 1579|      0|		if ((name->length == ruleName->length) &&
 1580|      0|				(memcmp(&name->chars[0], ruleName->name, CHARSIZE * name->length) == 0))
 1581|      0|			return ruleName->ruleOffset;
 1582|      0|		ruleName = ruleName->next;
 1583|      0|	}
 1584|      0|	return 0;
 1585|      0|}
 1586|       |
 1587|       |static int
 1588|       |addRuleName(const FileInfo *file, CharsString *name, TranslationTableOffset ruleOffset,
 1589|      0|		TranslationTableHeader *table) {
 1590|      0|	int k;
 1591|      0|	RuleName *ruleName;
 1592|      0|	if (!(ruleName = malloc(sizeof(*ruleName) + CHARSIZE * (name->length - 1)))) {
 1593|      0|		compileError(file, "not enough memory");
 1594|      0|		_lou_outOfMemory();
 1595|      0|	}
 1596|      0|	memset(ruleName, 0, sizeof(*ruleName));
 1597|      0|	// a name is a sequence of characters in the ranges 'a'..'z' and 'A'..'Z'
 1598|      0|	for (k = 0; k < name->length; k++) {
 1599|      0|		widechar c = name->chars[k];
 1600|      0|		if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
 1601|      0|			ruleName->name[k] = c;
 1602|      0|		else {
 1603|      0|			compileError(file, "a name may contain only letters");
 1604|      0|			free(ruleName);
 1605|      0|			return 0;
 1606|      0|		}
 1607|      0|	}
 1608|      0|	ruleName->length = name->length;
 1609|      0|	ruleName->ruleOffset = ruleOffset;
 1610|      0|	ruleName->next = table->ruleNames;
 1611|      0|	table->ruleNames = ruleName;
 1612|      0|	return 1;
 1613|      0|}
 1614|       |
 1615|       |static void
 1616|      0|deallocateRuleNames(TranslationTableHeader *table) {
 1617|      0|	RuleName **ruleName = &table->ruleNames;
 1618|      0|	while (*ruleName) {
 1619|      0|		RuleName *rn = *ruleName;
 1620|      0|		*ruleName = rn->next;
 1621|      0|		free(rn);
 1622|      0|	}
 1623|      0|}
 1624|       |
 1625|       |static int
 1626|      0|compileSwapDots(const FileInfo *file, CharsString *source, CharsString *dest) {
 1627|      0|	int k = 0;
 1628|      0|	int kk = 0;
 1629|      0|	CharsString dotsSource;
 1630|      0|	CharsString dotsDest;
 1631|      0|	dest->length = 0;
 1632|      0|	dotsSource.length = 0;
 1633|      0|	while (k <= source->length) {
 1634|      0|		if (source->chars[k] != ',' && k != source->length)
 1635|      0|			dotsSource.chars[dotsSource.length++] = source->chars[k];
 1636|      0|		else {
 1637|      0|			if (!parseDots(file, &dotsDest, &dotsSource)) return 0;
 1638|      0|			dest->chars[dest->length++] = dotsDest.length + 1;
 1639|      0|			for (kk = 0; kk < dotsDest.length; kk++)
 1640|      0|				dest->chars[dest->length++] = dotsDest.chars[kk];
 1641|      0|			dotsSource.length = 0;
 1642|      0|		}
 1643|      0|		k++;
 1644|      0|	}
 1645|      0|	return 1;
 1646|      0|}
 1647|       |
 1648|       |static int
 1649|       |compileSwap(FileInfo *file, TranslationTableOpcode opcode, int noback, int nofor,
 1650|      0|		TranslationTableHeader **table) {
 1651|      0|	CharsString ruleChars;
 1652|      0|	CharsString ruleDots;
 1653|      0|	CharsString name;
 1654|      0|	CharsString matches;
 1655|      0|	CharsString replacements;
 1656|      0|	TranslationTableOffset ruleOffset;
 1657|      0|	if (!getToken(file, &name, "name operand")) return 0;
 1658|      0|	if (!getToken(file, &matches, "matches operand")) return 0;
 1659|      0|	if (!getToken(file, &replacements, "replacements operand")) return 0;
 1660|      0|	if (opcode == CTO_SwapCc || opcode == CTO_SwapCd) {
 1661|      0|		if (!parseChars(file, &ruleChars, &matches)) return 0;
 1662|      0|	} else {
 1663|      0|		if (!compileSwapDots(file, &matches, &ruleChars)) return 0;
 1664|      0|	}
 1665|      0|	if (opcode == CTO_SwapCc) {
 1666|      0|		if (!parseChars(file, &ruleDots, &replacements)) return 0;
 1667|      0|	} else {
 1668|      0|		if (!compileSwapDots(file, &replacements, &ruleDots)) return 0;
 1669|      0|	}
 1670|      0|	if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, NULL, noback,
 1671|      0|				nofor, table))
 1672|      0|		return 0;
 1673|      0|	if (!addRuleName(file, &name, ruleOffset, *table)) return 0;
 1674|      0|	return 1;
 1675|      0|}
 1676|       |
 1677|       |static int
 1678|      0|getNumber(widechar *string, widechar *number) {
 1679|      0|	/* Convert a string of wide character digits to an integer */
 1680|      0|	int k = 0;
 1681|      0|	*number = 0;
 1682|      0|	while (string[k] >= '0' && string[k] <= '9')
 1683|      0|		*number = 10 * *number + (string[k++] - '0');
 1684|      0|	return k;
 1685|      0|}
 1686|       |
 1687|       |/* Start of multipass compiler */
 1688|       |
 1689|       |static int
 1690|       |passGetAttributes(CharsString *passLine, int *passLinepos,
 1691|      0|		TranslationTableCharacterAttributes *attributes, const FileInfo *file) {
 1692|      0|	int more = 1;
 1693|      0|	*attributes = 0;
 1694|      0|	while (more) {
 1695|      0|		switch (passLine->chars[*passLinepos]) {
 1696|      0|		case pass_any:
 1697|      0|			*attributes = 0xffffffff;
 1698|      0|			break;
 1699|      0|		case pass_digit:
 1700|      0|			*attributes |= CTC_Digit;
 1701|      0|			break;
 1702|      0|		case pass_litDigit:
 1703|      0|			*attributes |= CTC_LitDigit;
 1704|      0|			break;
 1705|      0|		case pass_letter:
 1706|      0|			*attributes |= CTC_Letter;
 1707|      0|			break;
 1708|      0|		case pass_math:
 1709|      0|			*attributes |= CTC_Math;
 1710|      0|			break;
 1711|      0|		case pass_punctuation:
 1712|      0|			*attributes |= CTC_Punctuation;
 1713|      0|			break;
 1714|      0|		case pass_sign:
 1715|      0|			*attributes |= CTC_Sign;
 1716|      0|			break;
 1717|      0|		case pass_space:
 1718|      0|			*attributes |= CTC_Space;
 1719|      0|			break;
 1720|      0|		case pass_uppercase:
 1721|      0|			*attributes |= CTC_UpperCase;
 1722|      0|			break;
 1723|      0|		case pass_lowercase:
 1724|      0|			*attributes |= CTC_LowerCase;
 1725|      0|			break;
 1726|      0|		case pass_class1:
 1727|      0|			*attributes |= CTC_UserDefined9;
 1728|      0|			break;
 1729|      0|		case pass_class2:
 1730|      0|			*attributes |= CTC_UserDefined10;
 1731|      0|			break;
 1732|      0|		case pass_class3:
 1733|      0|			*attributes |= CTC_UserDefined11;
 1734|      0|			break;
 1735|      0|		case pass_class4:
 1736|      0|			*attributes |= CTC_UserDefined12;
 1737|      0|			break;
 1738|      0|		default:
 1739|      0|			more = 0;
 1740|      0|			break;
 1741|      0|		}
 1742|      0|		if (more) (*passLinepos)++;
 1743|      0|	}
 1744|      0|	if (!*attributes) {
 1745|      0|		compileError(file, "missing attribute");
 1746|      0|		(*passLinepos)--;
 1747|      0|		return 0;
 1748|      0|	}
 1749|      0|	return 1;
 1750|      0|}
 1751|       |
 1752|       |static int
 1753|       |passGetDots(CharsString *passLine, int *passLinepos, CharsString *dots,
 1754|      0|		const FileInfo *file) {
 1755|      0|	CharsString collectDots;
 1756|      0|	collectDots.length = 0;
 1757|      0|	while (*passLinepos < passLine->length &&
 1758|      0|			(passLine->chars[*passLinepos] == '-' ||
 1759|      0|					(passLine->chars[*passLinepos] >= '0' &&
 1760|      0|							passLine->chars[*passLinepos] <= '9') ||
 1761|      0|					((passLine->chars[*passLinepos] | 32) >= 'a' &&
 1762|      0|							(passLine->chars[*passLinepos] | 32) <= 'f')))
 1763|      0|		collectDots.chars[collectDots.length++] = passLine->chars[(*passLinepos)++];
 1764|      0|	if (!parseDots(file, dots, &collectDots)) return 0;
 1765|      0|	return 1;
 1766|      0|}
 1767|       |
 1768|       |static int
 1769|       |passGetString(CharsString *passLine, int *passLinepos, CharsString *string,
 1770|      0|		const FileInfo *file) {
 1771|      0|	string->length = 0;
 1772|      0|	while (1) {
 1773|      0|		if ((*passLinepos >= passLine->length) || !passLine->chars[*passLinepos]) {
 1774|      0|			compileError(file, "unterminated string");
 1775|      0|			return 0;
 1776|      0|		}
 1777|      0|		if (passLine->chars[*passLinepos] == 34) break;
 1778|      0|		if (passLine->chars[*passLinepos] == QUOTESUB)
 1779|      0|			string->chars[string->length++] = 34;
 1780|      0|		else
 1781|      0|			string->chars[string->length++] = passLine->chars[*passLinepos];
 1782|      0|		(*passLinepos)++;
 1783|      0|	}
 1784|      0|	string->chars[string->length] = 0;
 1785|      0|	(*passLinepos)++;
 1786|      0|	return 1;
 1787|      0|}
 1788|       |
 1789|       |static int
 1790|      0|passGetNumber(CharsString *passLine, int *passLinepos, widechar *number) {
 1791|      0|	/* Convert a string of wide character digits to an integer */
 1792|      0|	*number = 0;
 1793|      0|	while ((*passLinepos < passLine->length) && (passLine->chars[*passLinepos] >= '0') &&
 1794|      0|			(passLine->chars[*passLinepos] <= '9'))
 1795|      0|		*number = 10 * (*number) + (passLine->chars[(*passLinepos)++] - '0');
 1796|      0|	return 1;
 1797|      0|}
 1798|       |
 1799|       |static int
 1800|       |passGetVariableNumber(
 1801|      0|		const FileInfo *file, CharsString *passLine, int *passLinepos, widechar *number) {
 1802|      0|	if (!passGetNumber(passLine, passLinepos, number)) {
 1803|      0|		compileError(file, "missing variable number");
 1804|      0|		return 0;
 1805|      0|	}
 1806|      0|	if ((*number >= 0) && (*number < NUMVAR)) return 1;
 1807|      0|	compileError(file, "variable number out of range");
 1808|      0|	return 0;
 1809|      0|}
 1810|       |
 1811|       |static int
 1812|      0|passGetName(CharsString *passLine, int *passLinepos, CharsString *name) {
 1813|      0|	name->length = 0;
 1814|      0|	// a name is a sequence of characters in the ranges 'a'..'z' and 'A'..'Z'
 1815|      0|	do {
 1816|      0|		widechar c = passLine->chars[*passLinepos];
 1817|      0|		if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
 1818|      0|			name->chars[name->length++] = c;
 1819|      0|			(*passLinepos)++;
 1820|      0|		} else {
 1821|      0|			break;
 1822|      0|		}
 1823|      0|	} while (*passLinepos < passLine->length);
 1824|      0|	return 1;
 1825|      0|}
 1826|       |
 1827|       |static inline int
 1828|      0|wantsString(TranslationTableOpcode opcode, int actionPart, int nofor) {
 1829|      0|	if (opcode == CTO_Correct) return 1;
 1830|      0|	if (opcode != CTO_Context) return 0;
 1831|      0|	return !nofor == !actionPart;
 1832|      0|}
 1833|       |
 1834|       |static int
 1835|       |verifyStringOrDots(const FileInfo *file, TranslationTableOpcode opcode, int isString,
 1836|      0|		int actionPart, int nofor) {
 1837|      0|	if (!wantsString(opcode, actionPart, nofor) == !isString) return 1;
 1838|      0|
 1839|      0|	compileError(file, "%s are not allowed in the %s part of a %s translation %s rule.",
 1840|      0|			isString ? "strings" : "dots", getPartName(actionPart),
 1841|      0|			nofor ? "backward" : "forward", _lou_findOpcodeName(opcode));
 1842|      0|
 1843|      0|	return 0;
 1844|      0|}
 1845|       |
 1846|       |static int
 1847|       |compilePassOpcode(const FileInfo *file, TranslationTableOpcode opcode, int noback,
 1848|      0|		int nofor, TranslationTableHeader **table) {
 1849|      0|	static CharsString passRuleChars;
 1850|      0|	static CharsString passRuleDots;
 1851|      0|	/* Compile the operands of a pass opcode */
 1852|      0|	widechar passSubOp;
 1853|      0|	const CharacterClass *class;
 1854|      0|	TranslationTableRule *rule = NULL;
 1855|      0|	int k;
 1856|      0|	int kk = 0;
 1857|      0|	int endTest = 0;
 1858|      0|	widechar *passInstructions = passRuleDots.chars;
 1859|      0|	int passIC = 0; /* Instruction counter */
 1860|      0|	passRuleChars.length = 0;
 1861|      0|	CharsString passHoldString;
 1862|      0|	widechar passHoldNumber;
 1863|      0|	CharsString passLine;
 1864|      0|	int passLinepos = 0;
 1865|      0|	TranslationTableCharacterAttributes passAttributes;
 1866|      0|	passHoldString.length = 0;
 1867|      0|	for (k = file->linepos; k < file->linelen; k++)
 1868|      0|		passHoldString.chars[passHoldString.length++] = file->line[k];
 1869|      0|#define SEPCHAR 0x0001
 1870|      0|	for (k = 0; k < passHoldString.length && passHoldString.chars[k] > 32; k++)
 1871|      0|		;
 1872|      0|	if (k < passHoldString.length)
 1873|      0|		passHoldString.chars[k] = SEPCHAR;
 1874|      0|	else {
 1875|      0|		compileError(file, "Invalid multipass operands");
 1876|      0|		return 0;
 1877|      0|	}
 1878|      0|	parseChars(file, &passLine, &passHoldString);
 1879|      0|	/* Compile test part */
 1880|      0|	for (k = 0; k < passLine.length && passLine.chars[k] != SEPCHAR; k++)
 1881|      0|		;
 1882|      0|	endTest = k;
 1883|      0|	passLine.chars[endTest] = pass_endTest;
 1884|      0|	passLinepos = 0;
 1885|      0|	while (passLinepos <= endTest) {
 1886|      0|		if (passIC >= MAXSTRING) {
 1887|      0|			compileError(file, "Test part in multipass operand too long");
 1888|      0|			return 0;
 1889|      0|		}
 1890|      0|		switch ((passSubOp = passLine.chars[passLinepos])) {
 1891|      0|		case pass_lookback:
 1892|      0|			passInstructions[passIC++] = pass_lookback;
 1893|      0|			passLinepos++;
 1894|      0|			passGetNumber(&passLine, &passLinepos, &passHoldNumber);
 1895|      0|			if (passHoldNumber == 0) passHoldNumber = 1;
 1896|      0|			passInstructions[passIC++] = passHoldNumber;
 1897|      0|			break;
 1898|      0|		case pass_not:
 1899|      0|			passInstructions[passIC++] = pass_not;
 1900|      0|			passLinepos++;
 1901|      0|			break;
 1902|      0|		case pass_first:
 1903|      0|			passInstructions[passIC++] = pass_first;
 1904|      0|			passLinepos++;
 1905|      0|			break;
 1906|      0|		case pass_last:
 1907|      0|			passInstructions[passIC++] = pass_last;
 1908|      0|			passLinepos++;
 1909|      0|			break;
 1910|      0|		case pass_search:
 1911|      0|			passInstructions[passIC++] = pass_search;
 1912|      0|			passLinepos++;
 1913|      0|			break;
 1914|      0|		case pass_string:
 1915|      0|			if (!verifyStringOrDots(file, opcode, 1, 0, nofor)) {
 1916|      0|				return 0;
 1917|      0|			}
 1918|      0|			passLinepos++;
 1919|      0|			passInstructions[passIC++] = pass_string;
 1920|      0|			passGetString(&passLine, &passLinepos, &passHoldString, file);
 1921|      0|			if (passHoldString.length == 0) {
 1922|      0|				compileError(file, "empty string in test part");
 1923|      0|				return 0;
 1924|      0|			}
 1925|      0|			goto testDoCharsDots;
 1926|      0|		case pass_dots:
 1927|      0|			if (!verifyStringOrDots(file, opcode, 0, 0, nofor)) {
 1928|      0|				return 0;
 1929|      0|			}
 1930|      0|			passLinepos++;
 1931|      0|			passInstructions[passIC++] = pass_dots;
 1932|      0|			passGetDots(&passLine, &passLinepos, &passHoldString, file);
 1933|      0|			if (passHoldString.length == 0) {
 1934|      0|				compileError(file, "expected dot pattern after @ operand in test part");
 1935|      0|				return 0;
 1936|      0|			}
 1937|      0|		testDoCharsDots:
 1938|      0|			if (passIC >= MAXSTRING) {
 1939|      0|				compileError(
 1940|      0|						file, "@ operand in test part of multipass operand too long");
 1941|      0|				return 0;
 1942|      0|			}
 1943|      0|			passInstructions[passIC++] = passHoldString.length;
 1944|      0|			for (kk = 0; kk < passHoldString.length; kk++) {
 1945|      0|				if (passIC >= MAXSTRING) {
 1946|      0|					compileError(
 1947|      0|							file, "@ operand in test part of multipass operand too long");
 1948|      0|					return 0;
 1949|      0|				}
 1950|      0|				passInstructions[passIC++] = passHoldString.chars[kk];
 1951|      0|			}
 1952|      0|			break;
 1953|      0|		case pass_startReplace:
 1954|      0|			passInstructions[passIC++] = pass_startReplace;
 1955|      0|			passLinepos++;
 1956|      0|			break;
 1957|      0|		case pass_endReplace:
 1958|      0|			passInstructions[passIC++] = pass_endReplace;
 1959|      0|			passLinepos++;
 1960|      0|			break;
 1961|      0|		case pass_variable:
 1962|      0|			passLinepos++;
 1963|      0|			if (!passGetVariableNumber(file, &passLine, &passLinepos, &passHoldNumber))
 1964|      0|				return 0;
 1965|      0|			switch (passLine.chars[passLinepos]) {
 1966|      0|			case pass_eq:
 1967|      0|				passInstructions[passIC++] = pass_eq;
 1968|      0|				goto doComp;
 1969|      0|			case pass_lt:
 1970|      0|				if (passLine.chars[passLinepos + 1] == pass_eq) {
 1971|      0|					passLinepos++;
 1972|      0|					passInstructions[passIC++] = pass_lteq;
 1973|      0|				} else
 1974|      0|					passInstructions[passIC++] = pass_lt;
 1975|      0|				goto doComp;
 1976|      0|			case pass_gt:
 1977|      0|				if (passLine.chars[passLinepos + 1] == pass_eq) {
 1978|      0|					passLinepos++;
 1979|      0|					passInstructions[passIC++] = pass_gteq;
 1980|      0|				} else
 1981|      0|					passInstructions[passIC++] = pass_gt;
 1982|      0|			doComp:
 1983|      0|				passInstructions[passIC++] = passHoldNumber;
 1984|      0|				passLinepos++;
 1985|      0|				passGetNumber(&passLine, &passLinepos, &passHoldNumber);
 1986|      0|				passInstructions[passIC++] = passHoldNumber;
 1987|      0|				break;
 1988|      0|			default:
 1989|      0|				compileError(file, "incorrect comparison operator");
 1990|      0|				return 0;
 1991|      0|			}
 1992|      0|			break;
 1993|      0|		case pass_attributes:
 1994|      0|			passLinepos++;
 1995|      0|			if (!passGetAttributes(&passLine, &passLinepos, &passAttributes, file))
 1996|      0|				return 0;
 1997|      0|		insertAttributes:
 1998|      0|			passInstructions[passIC++] = pass_attributes;
 1999|      0|			passInstructions[passIC++] = (passAttributes >> 48) & 0xffff;
 2000|      0|			passInstructions[passIC++] = (passAttributes >> 32) & 0xffff;
 2001|      0|			passInstructions[passIC++] = (passAttributes >> 16) & 0xffff;
 2002|      0|			passInstructions[passIC++] = passAttributes & 0xffff;
 2003|      0|		getRange:
 2004|      0|			if (passLine.chars[passLinepos] == pass_until) {
 2005|      0|				passLinepos++;
 2006|      0|				passInstructions[passIC++] = 1;
 2007|      0|				passInstructions[passIC++] = 0xffff;
 2008|      0|				break;
 2009|      0|			}
 2010|      0|			passGetNumber(&passLine, &passLinepos, &passHoldNumber);
 2011|      0|			if (passHoldNumber == 0) {
 2012|      0|				passHoldNumber = passInstructions[passIC++] = 1;
 2013|      0|				passInstructions[passIC++] = 1; /* This is not an error */
 2014|      0|				break;
 2015|      0|			}
 2016|      0|			passInstructions[passIC++] = passHoldNumber;
 2017|      0|			if (passLine.chars[passLinepos] != pass_hyphen) {
 2018|      0|				passInstructions[passIC++] = passHoldNumber;
 2019|      0|				break;
 2020|      0|			}
 2021|      0|			passLinepos++;
 2022|      0|			passGetNumber(&passLine, &passLinepos, &passHoldNumber);
 2023|      0|			if (passHoldNumber == 0) {
 2024|      0|				compileError(file, "invalid range");
 2025|      0|				return 0;
 2026|      0|			}
 2027|      0|			passInstructions[passIC++] = passHoldNumber;
 2028|      0|			break;
 2029|      0|		case pass_groupstart:
 2030|      0|		case pass_groupend: {
 2031|      0|			passLinepos++;
 2032|      0|			passGetName(&passLine, &passLinepos, &passHoldString);
 2033|      0|			TranslationTableOffset ruleOffset = findRuleName(&passHoldString, *table);
 2034|      0|			if (ruleOffset)
 2035|      0|				rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];
 2036|      0|			if (rule && rule->opcode == CTO_Grouping) {
 2037|      0|				passInstructions[passIC++] = passSubOp;
 2038|      0|				passInstructions[passIC++] = ruleOffset >> 16;
 2039|      0|				passInstructions[passIC++] = ruleOffset & 0xffff;
 2040|      0|				break;
 2041|      0|			} else {
 2042|      0|				compileError(file, "%s is not a grouping name",
 2043|      0|						_lou_showString(
 2044|      0|								&passHoldString.chars[0], passHoldString.length, 0));
 2045|      0|				return 0;
 2046|      0|			}
 2047|      0|			break;
 2048|      0|		}
 2049|      0|		case pass_swap: {
 2050|      0|			passLinepos++;
 2051|      0|			passGetName(&passLine, &passLinepos, &passHoldString);
 2052|      0|			if ((class = findCharacterClass(&passHoldString, *table))) {
 2053|      0|				passAttributes = class->attribute;
 2054|      0|				goto insertAttributes;
 2055|      0|			}
 2056|      0|			TranslationTableOffset ruleOffset = findRuleName(&passHoldString, *table);
 2057|      0|			if (ruleOffset)
 2058|      0|				rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];
 2059|      0|			if (rule &&
 2060|      0|					(rule->opcode == CTO_SwapCc || rule->opcode == CTO_SwapCd ||
 2061|      0|							rule->opcode == CTO_SwapDd)) {
 2062|      0|				passInstructions[passIC++] = pass_swap;
 2063|      0|				passInstructions[passIC++] = ruleOffset >> 16;
 2064|      0|				passInstructions[passIC++] = ruleOffset & 0xffff;
 2065|      0|				goto getRange;
 2066|      0|			}
 2067|      0|			compileError(file, "%s is neither a class name nor a swap name.",
 2068|      0|					_lou_showString(&passHoldString.chars[0], passHoldString.length, 0));
 2069|      0|			return 0;
 2070|      0|		}
 2071|      0|		case pass_endTest:
 2072|      0|			passInstructions[passIC++] = pass_endTest;
 2073|      0|			passLinepos++;
 2074|      0|			break;
 2075|      0|		default:
 2076|      0|			compileError(file, "incorrect operator '%c ' in test part",
 2077|      0|					passLine.chars[passLinepos]);
 2078|      0|			return 0;
 2079|      0|		}
 2080|      0|
 2081|      0|	} /* Compile action part */
 2082|      0|
 2083|      0|	/* Compile action part */
 2084|      0|	while (passLinepos < passLine.length && passLine.chars[passLinepos] <= 32)
 2085|      0|		passLinepos++;
 2086|      0|	while (passLinepos < passLine.length && passLine.chars[passLinepos] > 32) {
 2087|      0|		if (passIC >= MAXSTRING) {
 2088|      0|			compileError(file, "Action part in multipass operand too long");
 2089|      0|			return 0;
 2090|      0|		}
 2091|      0|		switch ((passSubOp = passLine.chars[passLinepos])) {
 2092|      0|		case pass_string:
 2093|      0|			if (!verifyStringOrDots(file, opcode, 1, 1, nofor)) {
 2094|      0|				return 0;
 2095|      0|			}
 2096|      0|			passLinepos++;
 2097|      0|			passInstructions[passIC++] = pass_string;
 2098|      0|			passGetString(&passLine, &passLinepos, &passHoldString, file);
 2099|      0|			goto actionDoCharsDots;
 2100|      0|		case pass_dots:
 2101|      0|			if (!verifyStringOrDots(file, opcode, 0, 1, nofor)) {
 2102|      0|				return 0;
 2103|      0|			}
 2104|      0|			passLinepos++;
 2105|      0|			passGetDots(&passLine, &passLinepos, &passHoldString, file);
 2106|      0|			passInstructions[passIC++] = pass_dots;
 2107|      0|			if (passHoldString.length == 0) {
 2108|      0|				compileError(file, "expected dot pattern after @ operand in action part");
 2109|      0|				return 0;
 2110|      0|			}
 2111|      0|		actionDoCharsDots:
 2112|      0|			if (passIC >= MAXSTRING) {
 2113|      0|				compileError(
 2114|      0|						file, "@ operand in action part of multipass operand too long");
 2115|      0|				return 0;
 2116|      0|			}
 2117|      0|			passInstructions[passIC++] = passHoldString.length;
 2118|      0|			for (kk = 0; kk < passHoldString.length; kk++) {
 2119|      0|				if (passIC >= MAXSTRING) {
 2120|      0|					compileError(file,
 2121|      0|							"@ operand in action part of multipass operand too long");
 2122|      0|					return 0;
 2123|      0|				}
 2124|      0|				passInstructions[passIC++] = passHoldString.chars[kk];
 2125|      0|			}
 2126|      0|			break;
 2127|      0|		case pass_variable:
 2128|      0|			passLinepos++;
 2129|      0|			if (!passGetVariableNumber(file, &passLine, &passLinepos, &passHoldNumber))
 2130|      0|				return 0;
 2131|      0|			switch (passLine.chars[passLinepos]) {
 2132|      0|			case pass_eq:
 2133|      0|				passInstructions[passIC++] = pass_eq;
 2134|      0|				passInstructions[passIC++] = passHoldNumber;
 2135|      0|				passLinepos++;
 2136|      0|				passGetNumber(&passLine, &passLinepos, &passHoldNumber);
 2137|      0|				passInstructions[passIC++] = passHoldNumber;
 2138|      0|				break;
 2139|      0|			case pass_plus:
 2140|      0|			case pass_hyphen:
 2141|      0|				passInstructions[passIC++] = passLine.chars[passLinepos++];
 2142|      0|				passInstructions[passIC++] = passHoldNumber;
 2143|      0|				break;
 2144|      0|			default:
 2145|      0|				compileError(file, "incorrect variable operator in action part");
 2146|      0|				return 0;
 2147|      0|			}
 2148|      0|			break;
 2149|      0|		case pass_copy:
 2150|      0|			passInstructions[passIC++] = pass_copy;
 2151|      0|			passLinepos++;
 2152|      0|			break;
 2153|      0|		case pass_omit:
 2154|      0|			passInstructions[passIC++] = pass_omit;
 2155|      0|			passLinepos++;
 2156|      0|			break;
 2157|      0|		case pass_groupreplace:
 2158|      0|		case pass_groupstart:
 2159|      0|		case pass_groupend: {
 2160|      0|			passLinepos++;
 2161|      0|			passGetName(&passLine, &passLinepos, &passHoldString);
 2162|      0|			TranslationTableOffset ruleOffset = findRuleName(&passHoldString, *table);
 2163|      0|			if (ruleOffset)
 2164|      0|				rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];
 2165|      0|			if (rule && rule->opcode == CTO_Grouping) {
 2166|      0|				passInstructions[passIC++] = passSubOp;
 2167|      0|				passInstructions[passIC++] = ruleOffset >> 16;
 2168|      0|				passInstructions[passIC++] = ruleOffset & 0xffff;
 2169|      0|				break;
 2170|      0|			}
 2171|      0|			compileError(file, "%s is not a grouping name",
 2172|      0|					_lou_showString(&passHoldString.chars[0], passHoldString.length, 0));
 2173|      0|			return 0;
 2174|      0|		}
 2175|      0|		case pass_swap: {
 2176|      0|			passLinepos++;
 2177|      0|			passGetName(&passLine, &passLinepos, &passHoldString);
 2178|      0|			TranslationTableOffset ruleOffset = findRuleName(&passHoldString, *table);
 2179|      0|			if (ruleOffset)
 2180|      0|				rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];
 2181|      0|			if (rule &&
 2182|      0|					(rule->opcode == CTO_SwapCc || rule->opcode == CTO_SwapCd ||
 2183|      0|							rule->opcode == CTO_SwapDd)) {
 2184|      0|				passInstructions[passIC++] = pass_swap;
 2185|      0|				passInstructions[passIC++] = ruleOffset >> 16;
 2186|      0|				passInstructions[passIC++] = ruleOffset & 0xffff;
 2187|      0|				break;
 2188|      0|			}
 2189|      0|			compileError(file, "%s is not a swap name.",
 2190|      0|					_lou_showString(&passHoldString.chars[0], passHoldString.length, 0));
 2191|      0|			return 0;
 2192|      0|			break;
 2193|      0|		}
 2194|      0|		default:
 2195|      0|			compileError(file, "incorrect operator in action part");
 2196|      0|			return 0;
 2197|      0|		}
 2198|      0|	}
 2199|      0|
 2200|      0|	/* Analyze and add rule */
 2201|      0|	passRuleDots.length = passIC;
 2202|      0|
 2203|      0|	{
 2204|      0|		widechar *characters;
 2205|      0|		int length;
 2206|      0|		int found = passFindCharacters(
 2207|      0|				file, passInstructions, passRuleDots.length, &characters, &length);
 2208|      0|
 2209|      0|		if (!found) return 0;
 2210|      0|
 2211|      0|		if (characters) {
 2212|      0|			for (k = 0; k < length; k += 1) passRuleChars.chars[k] = characters[k];
 2213|      0|			passRuleChars.length = k;
 2214|      0|		}
 2215|      0|	}
 2216|      0|
 2217|      0|	if (!addRule(file, opcode, &passRuleChars, &passRuleDots, 0, 0, NULL, NULL, noback,
 2218|      0|				nofor, table))
 2219|      0|		return 0;
 2220|      0|	return 1;
 2221|      0|}
 2222|       |
 2223|       |/* End of multipass compiler */
 2224|       |
 2225|       |static int
 2226|       |compileBrailleIndicator(FileInfo *file, const char *ermsg, TranslationTableOpcode opcode,
 2227|       |		TranslationTableOffset *ruleOffset, int noback, int nofor,
 2228|      0|		TranslationTableHeader **table) {
 2229|      0|	CharsString token;
 2230|      0|	CharsString cells;
 2231|      0|	if (!getToken(file, &token, ermsg)) return 0;
 2232|      0|	if (!parseDots(file, &cells, &token)) return 0;
 2233|      0|	return addRule(
 2234|      0|			file, opcode, NULL, &cells, 0, 0, ruleOffset, NULL, noback, nofor, table);
 2235|      0|}
 2236|       |
 2237|       |static int
 2238|      0|compileNumber(FileInfo *file) {
 2239|      0|	CharsString token;
 2240|      0|	widechar number;
 2241|      0|	if (!getToken(file, &token, "number")) return 0;
 2242|      0|	getNumber(&token.chars[0], &number);
 2243|      0|	if (!(number > 0)) {
 2244|      0|		compileError(file, "a nonzero positive number is required");
 2245|      0|		return 0;
 2246|      0|	}
 2247|      0|	return number;
 2248|      0|}
 2249|       |
 2250|       |static int
 2251|       |compileGrouping(FileInfo *file, int noback, int nofor, TranslationTableHeader **table,
 2252|      0|		DisplayTableHeader **displayTable) {
 2253|      0|	int k;
 2254|      0|	CharsString name;
 2255|      0|	CharsString groupChars;
 2256|      0|	CharsString groupDots;
 2257|      0|	CharsString dotsParsed;
 2258|      0|	if (!getToken(file, &name, "name operand")) return 0;
 2259|      0|	if (!getRuleCharsText(file, &groupChars)) return 0;
 2260|      0|	if (!getToken(file, &groupDots, "dots operand")) return 0;
 2261|      0|	for (k = 0; k < groupDots.length && groupDots.chars[k] != ','; k++)
 2262|      0|		;
 2263|      0|	if (k == groupDots.length) {
 2264|      0|		compileError(file, "Dots operand must consist of two cells separated by a comma");
 2265|      0|		return 0;
 2266|      0|	}
 2267|      0|	groupDots.chars[k] = '-';
 2268|      0|	if (!parseDots(file, &dotsParsed, &groupDots)) return 0;
 2269|      0|	if (groupChars.length != 2 || dotsParsed.length != 2) {
 2270|      0|		compileError(file,
 2271|      0|				"two Unicode characters and two cells separated by a comma are needed.");
 2272|      0|		return 0;
 2273|      0|	}
 2274|      0|	if (table) {
 2275|      0|		TranslationTableOffset ruleOffset;
 2276|      0|		TranslationTableCharacter *charsDotsPtr;
 2277|      0|		charsDotsPtr = putChar(file, groupChars.chars[0], table, NULL);
 2278|      0|		charsDotsPtr->attributes |= CTC_Math;
 2279|      0|		charsDotsPtr = putChar(file, groupChars.chars[1], table, NULL);
 2280|      0|		charsDotsPtr->attributes |= CTC_Math;
 2281|      0|		charsDotsPtr = putDots(file, dotsParsed.chars[0], table);
 2282|      0|		charsDotsPtr->attributes |= CTC_Math;
 2283|      0|		charsDotsPtr = putDots(file, dotsParsed.chars[1], table);
 2284|      0|		charsDotsPtr->attributes |= CTC_Math;
 2285|      0|		if (!addRule(file, CTO_Grouping, &groupChars, &dotsParsed, 0, 0, &ruleOffset,
 2286|      0|					NULL, noback, nofor, table))
 2287|      0|			return 0;
 2288|      0|		if (!addRuleName(file, &name, ruleOffset, *table)) return 0;
 2289|      0|	}
 2290|      0|	if (displayTable) {
 2291|      0|		putCharDotsMapping(file, groupChars.chars[0], dotsParsed.chars[0], displayTable);
 2292|      0|		putCharDotsMapping(file, groupChars.chars[1], dotsParsed.chars[1], displayTable);
 2293|      0|	}
 2294|      0|	if (table) {
 2295|      0|		widechar endChar;
 2296|      0|		widechar endDots;
 2297|      0|		endChar = groupChars.chars[1];
 2298|      0|		endDots = dotsParsed.chars[1];
 2299|      0|		groupChars.length = dotsParsed.length = 1;
 2300|      0|		if (!addRule(file, CTO_Math, &groupChars, &dotsParsed, 0, 0, NULL, NULL, noback,
 2301|      0|					nofor, table))
 2302|      0|			return 0;
 2303|      0|		groupChars.chars[0] = endChar;
 2304|      0|		dotsParsed.chars[0] = endDots;
 2305|      0|		if (!addRule(file, CTO_Math, &groupChars, &dotsParsed, 0, 0, NULL, NULL, noback,
 2306|      0|					nofor, table))
 2307|      0|			return 0;
 2308|      0|	}
 2309|      0|	return 1;
 2310|      0|}
 2311|       |
 2312|       |/* Functions for compiling hyphenation tables */
 2313|       |
 2314|       |typedef struct HyphenDict { /* hyphenation dictionary: finite state machine */
 2315|       |	int numStates;
 2316|       |	HyphenationState *states;
 2317|       |} HyphenDict;
 2318|       |
 2319|      0|#define DEFAULTSTATE 0xffff
 2320|      0|#define HYPHENHASHSIZE 8191
 2321|       |
 2322|       |typedef struct HyphenHashEntry {
 2323|       |	struct HyphenHashEntry *next;
 2324|       |	CharsString *key;
 2325|       |	int val;
 2326|       |} HyphenHashEntry;
 2327|       |
 2328|       |typedef struct HyphenHashTab {
 2329|       |	HyphenHashEntry *entries[HYPHENHASHSIZE];
 2330|       |} HyphenHashTab;
 2331|       |
 2332|       |/* a hash function from ASU - adapted from Gtk+ */
 2333|       |static unsigned int
 2334|      0|hyphenStringHash(const CharsString *s) {
 2335|      0|	int k;
 2336|      0|	unsigned int h = 0, g;
 2337|      0|	for (k = 0; k < s->length; k++) {
 2338|      0|		h = (h << 4) + s->chars[k];
 2339|      0|		if ((g = h & 0xf0000000)) {
 2340|      0|			h = h ^ (g >> 24);
 2341|      0|			h = h ^ g;
 2342|      0|		}
 2343|      0|	}
 2344|      0|	return h;
 2345|      0|}
 2346|       |
 2347|       |static HyphenHashTab *
 2348|      0|hyphenHashNew(void) {
 2349|      0|	HyphenHashTab *hashTab;
 2350|      0|	if (!(hashTab = malloc(sizeof(HyphenHashTab)))) _lou_outOfMemory();
 2351|      0|	memset(hashTab, 0, sizeof(HyphenHashTab));
 2352|      0|	return hashTab;
 2353|      0|}
 2354|       |
 2355|       |static void
 2356|      0|hyphenHashFree(HyphenHashTab *hashTab) {
 2357|      0|	int i;
 2358|      0|	HyphenHashEntry *e, *next;
 2359|      0|	for (i = 0; i < HYPHENHASHSIZE; i++)
 2360|      0|		for (e = hashTab->entries[i]; e; e = next) {
 2361|      0|			next = e->next;
 2362|      0|			free(e->key);
 2363|      0|			free(e);
 2364|      0|		}
 2365|      0|	free(hashTab);
 2366|      0|}
 2367|       |
 2368|       |/* assumes that key is not already present! */
 2369|       |static void
 2370|      0|hyphenHashInsert(HyphenHashTab *hashTab, const CharsString *key, int val) {
 2371|      0|	int i, j;
 2372|      0|	HyphenHashEntry *e;
 2373|      0|	i = hyphenStringHash(key) % HYPHENHASHSIZE;
 2374|      0|	if (!(e = malloc(sizeof(HyphenHashEntry)))) _lou_outOfMemory();
 2375|      0|	e->next = hashTab->entries[i];
 2376|      0|	e->key = malloc((key->length + 1) * CHARSIZE);
 2377|      0|	if (!e->key) _lou_outOfMemory();
 2378|      0|	e->key->length = key->length;
 2379|      0|	for (j = 0; j < key->length; j++) e->key->chars[j] = key->chars[j];
 2380|      0|	e->val = val;
 2381|      0|	hashTab->entries[i] = e;
 2382|      0|}
 2383|       |
 2384|       |/* return val if found, otherwise DEFAULTSTATE */
 2385|       |static int
 2386|      0|hyphenHashLookup(HyphenHashTab *hashTab, const CharsString *key) {
 2387|      0|	int i, j;
 2388|      0|	HyphenHashEntry *e;
 2389|      0|	if (key->length == 0) return 0;
 2390|      0|	i = hyphenStringHash(key) % HYPHENHASHSIZE;
 2391|      0|	for (e = hashTab->entries[i]; e; e = e->next) {
 2392|      0|		if (key->length != e->key->length) continue;
 2393|      0|		for (j = 0; j < key->length; j++)
 2394|      0|			if (key->chars[j] != e->key->chars[j]) break;
 2395|      0|		if (j == key->length) return e->val;
 2396|      0|	}
 2397|      0|	return DEFAULTSTATE;
 2398|      0|}
 2399|       |
 2400|       |static int
 2401|      0|hyphenGetNewState(HyphenDict *dict, HyphenHashTab *hashTab, const CharsString *string) {
 2402|      0|	hyphenHashInsert(hashTab, string, dict->numStates);
 2403|      0|	/* predicate is true if dict->numStates is a power of two */
 2404|      0|	if (!(dict->numStates & (dict->numStates - 1)))
 2405|      0|		dict->states =
 2406|      0|				realloc(dict->states, (dict->numStates << 1) * sizeof(HyphenationState));
 2407|      0|	if (!dict->states) _lou_outOfMemory();
 2408|      0|	dict->states[dict->numStates].hyphenPattern = 0;
 2409|      0|	dict->states[dict->numStates].fallbackState = DEFAULTSTATE;
 2410|      0|	dict->states[dict->numStates].numTrans = 0;
 2411|      0|	dict->states[dict->numStates].trans.pointer = NULL;
 2412|      0|	return dict->numStates++;
 2413|      0|}
 2414|       |
 2415|       |/* add a transition from state1 to state2 through ch - assumes that the
 2416|       | * transition does not already exist */
 2417|       |static void
 2418|      0|hyphenAddTrans(HyphenDict *dict, int state1, int state2, widechar ch) {
 2419|      0|	int numTrans;
 2420|      0|	numTrans = dict->states[state1].numTrans;
 2421|      0|	if (numTrans == 0)
 2422|      0|		dict->states[state1].trans.pointer = malloc(sizeof(HyphenationTrans));
 2423|      0|	else if (!(numTrans & (numTrans - 1)))
 2424|      0|		dict->states[state1].trans.pointer = realloc(dict->states[state1].trans.pointer,
 2425|      0|				(numTrans << 1) * sizeof(HyphenationTrans));
 2426|      0|	dict->states[state1].trans.pointer[numTrans].ch = ch;
 2427|      0|	dict->states[state1].trans.pointer[numTrans].newState = state2;
 2428|      0|	dict->states[state1].numTrans++;
 2429|      0|}
 2430|       |
 2431|       |static int
 2432|       |compileHyphenation(
 2433|      0|		FileInfo *file, CharsString *encoding, TranslationTableHeader **table) {
 2434|      0|	CharsString hyph;
 2435|      0|	HyphenationTrans *holdPointer;
 2436|      0|	HyphenHashTab *hashTab;
 2437|      0|	CharsString word;
 2438|      0|	char pattern[MAXSTRING + 1];
 2439|      0|	unsigned int stateNum = 0, lastState = 0;
 2440|      0|	int i, j, k = encoding->length;
 2441|      0|	widechar ch;
 2442|      0|	int found;
 2443|      0|	HyphenHashEntry *e;
 2444|      0|	HyphenDict dict;
 2445|      0|	TranslationTableOffset holdOffset;
 2446|      0|	/* Set aside enough space for hyphenation states and transitions in
 2447|      0|	 * translation table. Must be done before anything else */
 2448|      0|	allocateSpaceInTranslationTable(file, NULL, 250000, table);
 2449|      0|	hashTab = hyphenHashNew();
 2450|      0|	dict.numStates = 1;
 2451|      0|	dict.states = malloc(sizeof(HyphenationState));
 2452|      0|	if (!dict.states) _lou_outOfMemory();
 2453|      0|	dict.states[0].hyphenPattern = 0;
 2454|      0|	dict.states[0].fallbackState = DEFAULTSTATE;
 2455|      0|	dict.states[0].numTrans = 0;
 2456|      0|	dict.states[0].trans.pointer = NULL;
 2457|      0|	do {
 2458|      0|		if (encoding->chars[0] == 'I') {
 2459|      0|			if (!getToken(file, &hyph, NULL)) continue;
 2460|      0|		} else {
 2461|      0|			/* UTF-8 */
 2462|      0|			if (!getToken(file, &word, NULL)) continue;
 2463|      0|			parseChars(file, &hyph, &word);
 2464|      0|		}
 2465|      0|		if (hyph.length == 0 || hyph.chars[0] == '#' || hyph.chars[0] == '%' ||
 2466|      0|				hyph.chars[0] == '<')
 2467|      0|			continue; /* comment */
 2468|      0|		j = 0;
 2469|      0|		pattern[j] = '0';
 2470|      0|		for (i = 0; i < hyph.length; i++) {
 2471|      0|			if (hyph.chars[i] >= '0' && hyph.chars[i] <= '9')
 2472|      0|				pattern[j] = (char)hyph.chars[i];
 2473|      0|			else {
 2474|      0|				word.chars[j] = hyph.chars[i];
 2475|      0|				pattern[++j] = '0';
 2476|      0|			}
 2477|      0|		}
 2478|      0|		word.chars[j] = 0;
 2479|      0|		word.length = j;
 2480|      0|		pattern[j + 1] = 0;
 2481|      0|		for (i = 0; pattern[i] == '0'; i++)
 2482|      0|			;
 2483|      0|		found = hyphenHashLookup(hashTab, &word);
 2484|      0|		if (found != DEFAULTSTATE)
 2485|      0|			stateNum = found;
 2486|      0|		else
 2487|      0|			stateNum = hyphenGetNewState(&dict, hashTab, &word);
 2488|      0|		k = j + 2 - i;
 2489|      0|		if (k > 0) {
 2490|      0|			allocateSpaceInTranslationTable(
 2491|      0|					file, &dict.states[stateNum].hyphenPattern, k, table);
 2492|      0|			memcpy(&(*table)->ruleArea[dict.states[stateNum].hyphenPattern], &pattern[i],
 2493|      0|					k);
 2494|      0|		}
 2495|      0|		/* now, put in the prefix transitions */
 2496|      0|		while (found == DEFAULTSTATE) {
 2497|      0|			lastState = stateNum;
 2498|      0|			ch = word.chars[word.length-- - 1];
 2499|      0|			found = hyphenHashLookup(hashTab, &word);
 2500|      0|			if (found != DEFAULTSTATE)
 2501|      0|				stateNum = found;
 2502|      0|			else
 2503|      0|				stateNum = hyphenGetNewState(&dict, hashTab, &word);
 2504|      0|			hyphenAddTrans(&dict, stateNum, lastState, ch);
 2505|      0|		}
 2506|      0|	} while (_lou_getALine(file));
 2507|      0|	/* put in the fallback states */
 2508|      0|	for (i = 0; i < HYPHENHASHSIZE; i++) {
 2509|      0|		for (e = hashTab->entries[i]; e; e = e->next) {
 2510|      0|			for (j = 1; j <= e->key->length; j++) {
 2511|      0|				word.length = 0;
 2512|      0|				for (k = j; k < e->key->length; k++)
 2513|      0|					word.chars[word.length++] = e->key->chars[k];
 2514|      0|				stateNum = hyphenHashLookup(hashTab, &word);
 2515|      0|				if (stateNum != DEFAULTSTATE) break;
 2516|      0|			}
 2517|      0|			if (e->val) dict.states[e->val].fallbackState = stateNum;
 2518|      0|		}
 2519|      0|	}
 2520|      0|	hyphenHashFree(hashTab);
 2521|      0|	/* Transfer hyphenation information to table */
 2522|      0|	for (i = 0; i < dict.numStates; i++) {
 2523|      0|		if (dict.states[i].numTrans == 0)
 2524|      0|			dict.states[i].trans.offset = 0;
 2525|      0|		else {
 2526|      0|			holdPointer = dict.states[i].trans.pointer;
 2527|      0|			allocateSpaceInTranslationTable(file, &dict.states[i].trans.offset,
 2528|      0|					dict.states[i].numTrans * sizeof(HyphenationTrans), table);
 2529|      0|			memcpy(&(*table)->ruleArea[dict.states[i].trans.offset], holdPointer,
 2530|      0|					dict.states[i].numTrans * sizeof(HyphenationTrans));
 2531|      0|			free(holdPointer);
 2532|      0|		}
 2533|      0|	}
 2534|      0|	allocateSpaceInTranslationTable(
 2535|      0|			file, &holdOffset, dict.numStates * sizeof(HyphenationState), table);
 2536|      0|	(*table)->hyphenStatesArray = holdOffset;
 2537|      0|	/* Prevents segmentation fault if table is reallocated */
 2538|      0|	memcpy(&(*table)->ruleArea[(*table)->hyphenStatesArray], &dict.states[0],
 2539|      0|			dict.numStates * sizeof(HyphenationState));
 2540|      0|	free(dict.states);
 2541|      0|	return 1;
 2542|      0|}
 2543|       |
 2544|       |static int
 2545|       |compileCharDef(FileInfo *file, TranslationTableOpcode opcode,
 2546|       |		TranslationTableCharacterAttributes attributes, int noback, int nofor,
 2547|      0|		TranslationTableHeader **table, DisplayTableHeader **displayTable) {
 2548|      0|	CharsString ruleChars;
 2549|      0|	CharsString ruleDots;
 2550|      0|	if (!getRuleCharsText(file, &ruleChars)) return 0;
 2551|      0|	if (!getRuleDotsPattern(file, &ruleDots)) return 0;
 2552|      0|	if (ruleChars.length != 1) {
 2553|      0|		compileError(file, "Exactly one character is required.");
 2554|      0|		return 0;
 2555|      0|	}
 2556|      0|	if (ruleDots.length < 1) {
 2557|      0|		compileError(file, "At least one cell is required.");
 2558|      0|		return 0;
 2559|      0|	}
 2560|      0|	if (table) {
 2561|      0|		TranslationTableCharacter *character;
 2562|      0|		TranslationTableCharacter *cell = NULL;
 2563|      0|		int k;
 2564|      0|		if (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;
 2565|      0|		character = putChar(file, ruleChars.chars[0], table, NULL);
 2566|      0|		character->attributes |= attributes;
 2567|      0|		for (k = ruleDots.length - 1; k >= 0; k -= 1) {
 2568|      0|			cell = getDots(ruleDots.chars[k], *table);
 2569|      0|			if (!cell) cell = putDots(file, ruleDots.chars[k], table);
 2570|      0|		}
 2571|      0|		if (ruleDots.length == 1) cell->attributes |= attributes;
 2572|      0|	}
 2573|      0|	if (displayTable && ruleDots.length == 1)
 2574|      0|		putCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);
 2575|      0|	if (table)
 2576|      0|		if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,
 2577|      0|					table))
 2578|      0|			return 0;
 2579|      0|	return 1;
 2580|      0|}
 2581|       |
 2582|       |static int
 2583|      0|compileBeforeAfter(FileInfo *file) {
 2584|      0|	/* 1=before, 2=after, 0=error */
 2585|      0|	CharsString token;
 2586|      0|	CharsString tmp;
 2587|      0|	if (!getToken(file, &token, "last word before or after")) return 0;
 2588|      0|	if (!parseChars(file, &tmp, &token)) return 0;
 2589|      0|	if (eqasc2uni((unsigned char *)"before", tmp.chars, 6))
 2590|      0|		return 1;
 2591|      0|	else if (eqasc2uni((unsigned char *)"after", tmp.chars, 5))
 2592|      0|		return 2;
 2593|      0|	return 0;
 2594|      0|}
 2595|       |
 2596|       |/**
 2597|       | * Macro
 2598|       | */
 2599|       |typedef struct {
 2600|       |	const char *name;
 2601|       |	const widechar *definition;	 // fixed part
 2602|       |	int definition_length;
 2603|       |	const int *substitutions;  // variable part: position and argument index of each
 2604|       |							   // variable substitution
 2605|       |	int substitution_count;
 2606|       |	int argument_count;	 // number of expected arguments
 2607|       |} Macro;
 2608|       |
 2609|       |/**
 2610|       | * List of in-scope macros
 2611|       | */
 2612|       |typedef struct MacroList {
 2613|       |	const Macro *head;
 2614|       |	const struct MacroList *tail;
 2615|       |} MacroList;
 2616|       |
 2617|       |/**
 2618|       | * Create new macro.
 2619|       | */
 2620|       |static const Macro *
 2621|       |create_macro(const char *name, const widechar *definition, int definition_length,
 2622|      0|		const int *substitutions, int substitution_count, int argument_count) {
 2623|      0|	Macro *m = malloc(sizeof(Macro));
 2624|      0|	m->name = strdup(name);
 2625|      0|	widechar *definition_copy = malloc(definition_length * sizeof(widechar));
 2626|      0|	memcpy(definition_copy, definition, definition_length * sizeof(widechar));
 2627|      0|	m->definition = definition_copy;
 2628|      0|	m->definition_length = definition_length;
 2629|      0|	int *substitutions_copy = malloc(2 * substitution_count * sizeof(int));
 2630|      0|	memcpy(substitutions_copy, substitutions, 2 * substitution_count * sizeof(int));
 2631|      0|	m->substitutions = substitutions_copy;
 2632|      0|	m->substitution_count = substitution_count;
 2633|      0|	m->argument_count = argument_count;
 2634|      0|	return m;
 2635|      0|}
 2636|       |
 2637|       |/**
 2638|       | * Create new macro list from "head" macro and "tail" list.
 2639|       | */
 2640|       |static const MacroList *
 2641|      0|cons_macro(const Macro *head, const MacroList *tail) {
 2642|      0|	MacroList *list = malloc(sizeof(MacroList));
 2643|      0|	list->head = head;
 2644|      0|	list->tail = tail;
 2645|      0|	return list;
 2646|      0|}
 2647|       |
 2648|       |/**
 2649|       | * Free macro returned by create_macro.
 2650|       | */
 2651|       |static void
 2652|      0|free_macro(const Macro *macro) {
 2653|      0|	if (macro) {
 2654|      0|		free((char *)macro->name);
 2655|      0|		free((char *)macro->definition);
 2656|      0|		free((int *)macro->substitutions);
 2657|      0|		free((Macro *)macro);
 2658|      0|	}
 2659|      0|}
 2660|       |
 2661|       |/**
 2662|       | * Free macro list returned by cons_macro.
 2663|       | */
 2664|       |static void
 2665|      0|free_macro_list(const MacroList *list) {
 2666|      0|	if (list) {
 2667|      0|		free_macro((Macro *)list->head);
 2668|      0|		free_macro_list((MacroList *)list->tail);
 2669|      0|		free((MacroList *)list);
 2670|      0|	}
 2671|      0|}
 2672|       |
 2673|       |/**
 2674|       | * Compile macro
 2675|       | */
 2676|       |static int
 2677|      0|compileMacro(FileInfo *file, const Macro **macro) {
 2678|      0|
 2679|      0|	// parse name
 2680|      0|	CharsString token;
 2681|      0|	if (!getToken(file, &token, "macro name")) return 0;
 2682|      0|	switch (getOpcode(file, &token)) {
 2683|      0|	case CTO_UpLow:	 // deprecated so "uplow" may be used as macro name
 2684|      0|	case CTO_None:
 2685|      0|		break;
 2686|      0|	default:
 2687|      0|		compileError(file, "Invalid macro name: already taken by an opcode");
 2688|      0|		return 0;
 2689|      0|	}
 2690|      0|	for (int i = 0; i < token.length; i++) {
 2691|      0|		if (!((token.chars[i] >= 'a' && token.chars[i] <= 'z') ||
 2692|      0|					(token.chars[i] >= 'A' && token.chars[i] <= 'Z') ||
 2693|      0|					(token.chars[i] >= '0' && token.chars[i] <= '9'))) {
 2694|      0|			compileError(file,
 2695|      0|					"Invalid macro name: must be a word containing only letters and "
 2696|      0|					"digits");
 2697|      0|			return 0;
 2698|      0|		}
 2699|      0|	}
 2700|      0|	static char name[MAXSTRING + 1];
 2701|      0|	int name_length;
 2702|      0|	for (name_length = 0; name_length < token.length;
 2703|      0|			name_length++)	// we know token can not be longer than MAXSTRING
 2704|      0|		name[name_length] = (char)token.chars[name_length];
 2705|      0|	name[name_length] = '\0';
 2706|      0|
 2707|      0|	// parse body
 2708|      0|	static widechar definition[MAXSTRING];
 2709|      0|	static int substitutions[2 * MAX_MACRO_VAR];
 2710|      0|	int definition_length = 0;
 2711|      0|	int substitution_count = 0;
 2712|      0|	int argument_count = 0;
 2713|      0|	int dollar = 0;
 2714|      0|
 2715|      0|	// ignore rest of line after name and read lines until "eom" is encountered
 2716|      0|	while (_lou_getALine(file)) {
 2717|      0|		if (file->linelen >= 3 && file->line[0] == 'e' && file->line[1] == 'o' &&
 2718|      0|				file->line[2] == 'm') {
 2719|      0|			*macro = create_macro(name, definition, definition_length, substitutions,
 2720|      0|					substitution_count, argument_count);
 2721|      0|			return 1;
 2722|      0|		}
 2723|      0|		while (!atEndOfLine(file)) {
 2724|      0|			widechar c = file->line[file->linepos++];
 2725|      0|			if (dollar) {
 2726|      0|				dollar = 0;
 2727|      0|				if (c >= '0' && c <= '9') {
 2728|      0|					if (substitution_count >= MAX_MACRO_VAR) {
 2729|      0|						compileError(file,
 2730|      0|								"Macro can not have more than %d variable substitutions",
 2731|      0|								MAXSTRING);
 2732|      0|						return 0;
 2733|      0|					}
 2734|      0|					substitutions[2 * substitution_count] = definition_length;
 2735|      0|					int arg = c - '0';
 2736|      0|					substitutions[2 * substitution_count + 1] = arg;
 2737|      0|					if (arg > argument_count) argument_count = arg;
 2738|      0|					substitution_count++;
 2739|      0|					continue;
 2740|      0|				}
 2741|      0|			} else if (c == '$') {
 2742|      0|				dollar = 1;
 2743|      0|				continue;
 2744|      0|			}
 2745|      0|			if (definition_length >= MAXSTRING) {
 2746|      0|				compileError(file, "Macro exceeds %d characters", MAXSTRING);
 2747|      0|				return 0;
 2748|      0|			} else
 2749|      0|				definition[definition_length++] = c;
 2750|      0|		}
 2751|      0|		dollar = 0;
 2752|      0|		if (definition_length >= MAXSTRING) {
 2753|      0|			compileError(file, "Macro exceeds %d characters", MAXSTRING);
 2754|      0|			return 0;
 2755|      0|		}
 2756|      0|		definition[definition_length++] = '\n';
 2757|      0|	}
 2758|      0|	compileError(file, "macro must be terminated with 'eom'");
 2759|      0|	return 0;
 2760|      0|}
 2761|       |
 2762|       |static int
 2763|       |compileRule(FileInfo *file, TranslationTableHeader **table,
 2764|      0|		DisplayTableHeader **displayTable, const MacroList **inScopeMacros) {
 2765|      0|	CharsString token;
 2766|      0|	TranslationTableOpcode opcode;
 2767|      0|	CharsString ruleChars;
 2768|      0|	CharsString ruleDots;
 2769|      0|	CharsString cells;
 2770|      0|	CharsString scratchPad;
 2771|      0|	CharsString emphClass;
 2772|      0|	TranslationTableCharacterAttributes after = 0;
 2773|      0|	TranslationTableCharacterAttributes before = 0;
 2774|      0|	int noback, nofor, nocross;
 2775|      0|	noback = nofor = nocross = 0;
 2776|      0|doOpcode:
 2777|      0|	if (!getToken(file, &token, NULL)) return 1;				  /* blank line */
 2778|      0|	if (token.chars[0] == '#' || token.chars[0] == '<') return 1; /* comment */
 2779|      0|	if (file->lineNumber == 1 &&
 2780|      0|			(eqasc2uni((unsigned char *)"ISO", token.chars, 3) ||
 2781|      0|					eqasc2uni((unsigned char *)"UTF-8", token.chars, 5))) {
 2782|      0|		if (table)
 2783|      0|			compileHyphenation(file, &token, table);
 2784|      0|		else
 2785|      0|			/* ignore the whole file */
 2786|      0|			while (_lou_getALine(file))
 2787|      0|				;
 2788|      0|		return 1;
 2789|      0|	}
 2790|      0|	opcode = getOpcode(file, &token);
 2791|      0|	switch (opcode) {
 2792|      0|	case CTO_Macro: {
 2793|      0|		const Macro *macro;
 2794|       |#ifdef ENABLE_MACROS
 2795|       |		if (!inScopeMacros) {
 2796|       |			compileError(file, "Defining macros only allowed in table files.");
 2797|       |			return 0;
 2798|       |		}
 2799|       |		if (compileMacro(file, &macro)) {
 2800|       |			*inScopeMacros = cons_macro(macro, *inScopeMacros);
 2801|       |			return 1;
 2802|       |		}
 2803|       |		return 0;
 2804|       |#else
 2805|       |		compileError(file, "Macro feature is disabled.");
 2806|      0|		return 0;
 2807|      0|#endif
 2808|      0|	}
 2809|      0|	case CTO_IncludeFile: {
 2810|      0|		CharsString includedFile;
 2811|      0|		if (!getToken(file, &token, "include file name")) return 0;
 2812|      0|		if (!parseChars(file, &includedFile, &token)) return 0;
 2813|      0|		return includeFile(file, &includedFile, table, displayTable);
 2814|      0|	}
 2815|      0|	case CTO_NoBack:
 2816|      0|		if (nofor) {
 2817|      0|			compileError(file, "%s already specified.", _lou_findOpcodeName(CTO_NoFor));
 2818|      0|			return 0;
 2819|      0|		}
 2820|      0|		noback = 1;
 2821|      0|		goto doOpcode;
 2822|      0|	case CTO_NoFor:
 2823|      0|		if (noback) {
 2824|      0|			compileError(file, "%s already specified.", _lou_findOpcodeName(CTO_NoBack));
 2825|      0|			return 0;
 2826|      0|		}
 2827|      0|		nofor = 1;
 2828|      0|		goto doOpcode;
 2829|      0|	case CTO_Space:
 2830|      0|		return compileCharDef(
 2831|      0|				file, opcode, CTC_Space, noback, nofor, table, displayTable);
 2832|      0|	case CTO_Digit:
 2833|      0|		return compileCharDef(
 2834|      0|				file, opcode, CTC_Digit, noback, nofor, table, displayTable);
 2835|      0|	case CTO_LitDigit:
 2836|      0|		return compileCharDef(
 2837|      0|				file, opcode, CTC_LitDigit, noback, nofor, table, displayTable);
 2838|      0|	case CTO_Punctuation:
 2839|      0|		return compileCharDef(
 2840|      0|				file, opcode, CTC_Punctuation, noback, nofor, table, displayTable);
 2841|      0|	case CTO_Math:
 2842|      0|		return compileCharDef(file, opcode, CTC_Math, noback, nofor, table, displayTable);
 2843|      0|	case CTO_Sign:
 2844|      0|		return compileCharDef(file, opcode, CTC_Sign, noback, nofor, table, displayTable);
 2845|      0|	case CTO_Letter:
 2846|      0|		return compileCharDef(
 2847|      0|				file, opcode, CTC_Letter, noback, nofor, table, displayTable);
 2848|      0|	case CTO_UpperCase:
 2849|      0|		return compileCharDef(
 2850|      0|				file, opcode, CTC_UpperCase, noback, nofor, table, displayTable);
 2851|      0|	case CTO_LowerCase:
 2852|      0|		return compileCharDef(
 2853|      0|				file, opcode, CTC_LowerCase, noback, nofor, table, displayTable);
 2854|      0|	case CTO_Grouping:
 2855|      0|		return compileGrouping(file, noback, nofor, table, displayTable);
 2856|      0|	case CTO_Display:
 2857|      0|		if (!displayTable) return 1;  // ignore
 2858|      0|		if (!getRuleCharsText(file, &ruleChars)) return 0;
 2859|      0|		if (!getRuleDotsPattern(file, &ruleDots)) return 0;
 2860|      0|		if (ruleChars.length != 1 || ruleDots.length != 1) {
 2861|      0|			compileError(file, "Exactly one character and one cell are required.");
 2862|      0|			return 0;
 2863|      0|		}
 2864|      0|		return putCharDotsMapping(
 2865|      0|				file, ruleChars.chars[0], ruleDots.chars[0], displayTable);
 2866|      0|	case CTO_UpLow:
 2867|      0|	case CTO_None: {
 2868|      0|		// check if token is a macro name
 2869|      0|		if (inScopeMacros) {
 2870|      0|			const MacroList *macros = *inScopeMacros;
 2871|      0|			while (macros) {
 2872|      0|				const Macro *m = macros->head;
 2873|      0|				if (token.length == strlen(m->name) &&
 2874|      0|						eqasc2uni((unsigned char *)m->name, token.chars, token.length)) {
 2875|      0|					if (!inScopeMacros) {
 2876|      0|						compileError(file, "Calling macros only allowed in table files.");
 2877|      0|						return 0;
 2878|      0|					}
 2879|      0|					FileInfo tmpFile;
 2880|      0|					memset(&tmpFile, 0, sizeof(tmpFile));
 2881|      0|					tmpFile.fileName = file->fileName;
 2882|      0|					tmpFile.sourceFile = file->sourceFile;
 2883|      0|					tmpFile.lineNumber = file->lineNumber;
 2884|      0|					tmpFile.encoding = noEncoding;
 2885|      0|					tmpFile.status = 0;
 2886|      0|					tmpFile.linepos = 0;
 2887|      0|					tmpFile.linelen = 0;
 2888|      0|					int argument_count = 0;
 2889|      0|					CharsString *arguments =
 2890|      0|							malloc(m->argument_count * sizeof(CharsString));
 2891|      0|					while (argument_count < m->argument_count) {
 2892|      0|						if (getToken(file, &token, "macro argument"))
 2893|      0|							arguments[argument_count++] = token;
 2894|      0|						else
 2895|      0|							break;
 2896|      0|					}
 2897|      0|					if (argument_count < m->argument_count) {
 2898|      0|						compileError(file, "Expected %d arguments", m->argument_count);
 2899|      0|						return 0;
 2900|      0|					}
 2901|      0|					int i = 0;
 2902|      0|					int subst = 0;
 2903|      0|					int next = subst < m->substitution_count ? m->substitutions[2 * subst]
 2904|      0|															 : m->definition_length;
 2905|      0|					for (;;) {
 2906|      0|						while (i < next) {
 2907|      0|							widechar c = m->definition[i++];
 2908|      0|							if (c == '\n') {
 2909|      0|								if (!compileRule(&tmpFile, table, displayTable,
 2910|      0|											inScopeMacros)) {
 2911|      0|									_lou_logMessage(LOU_LOG_ERROR,
 2912|      0|											"result of macro expansion was: %s",
 2913|      0|											_lou_showString(
 2914|      0|													tmpFile.line, tmpFile.linelen, 0));
 2915|      0|									return 0;
 2916|      0|								}
 2917|      0|								tmpFile.linepos = 0;
 2918|      0|								tmpFile.linelen = 0;
 2919|      0|							} else if (tmpFile.linelen >= MAXSTRING) {
 2920|      0|								compileError(file,
 2921|      0|										"Line exceeds %d characters (post macro "
 2922|      0|										"expansion)",
 2923|      0|										MAXSTRING);
 2924|      0|								return 0;
 2925|      0|							} else
 2926|      0|								tmpFile.line[tmpFile.linelen++] = c;
 2927|      0|						}
 2928|      0|						if (subst < m->substitution_count) {
 2929|      0|							CharsString arg =
 2930|      0|									arguments[m->substitutions[2 * subst + 1] - 1];
 2931|      0|							for (int j = 0; j < arg.length; j++)
 2932|      0|								tmpFile.line[tmpFile.linelen++] = arg.chars[j];
 2933|      0|							subst++;
 2934|      0|							next = subst < m->substitution_count
 2935|      0|									? m->substitutions[2 * subst]
 2936|      0|									: m->definition_length;
 2937|      0|						} else {
 2938|      0|							if (!compileRule(
 2939|      0|										&tmpFile, table, displayTable, inScopeMacros)) {
 2940|      0|								_lou_logMessage(LOU_LOG_ERROR,
 2941|      0|										"result of macro expansion was: %s",
 2942|      0|										_lou_showString(
 2943|      0|												tmpFile.line, tmpFile.linelen, 0));
 2944|      0|								return 0;
 2945|      0|							}
 2946|      0|							break;
 2947|      0|						}
 2948|      0|					}
 2949|      0|					return 1;
 2950|      0|				}
 2951|      0|				macros = macros->tail;
 2952|      0|			}
 2953|      0|		}
 2954|      0|		if (opcode == CTO_UpLow) {
 2955|      0|			compileError(file, "The uplow opcode is deprecated.");
 2956|      0|			return 0;
 2957|      0|		}
 2958|      0|		compileError(file, "opcode %s not defined.",
 2959|      0|				_lou_showString(token.chars, token.length, 0));
 2960|      0|		return 0;
 2961|      0|	}
 2962|      0|
 2963|      0|	/* now only opcodes follow that don't modify the display table */
 2964|      0|	default:
 2965|      0|		if (!table) return 1;
 2966|      0|		switch (opcode) {
 2967|      0|		case CTO_Locale:
 2968|      0|			compileWarning(file,
 2969|      0|					"The locale opcode is not implemented. Use the locale meta data "
 2970|      0|					"instead.");
 2971|      0|			return 1;
 2972|      0|		case CTO_Undefined: {
 2973|      0|			// not passing pointer because compileBrailleIndicator may reallocate table
 2974|      0|			TranslationTableOffset ruleOffset = (*table)->undefined;
 2975|      0|			if (!compileBrailleIndicator(file, "undefined character opcode",
 2976|      0|						CTO_Undefined, &ruleOffset, noback, nofor, table))
 2977|      0|				return 0;
 2978|      0|			(*table)->undefined = ruleOffset;
 2979|      0|			return 1;
 2980|      0|		}
 2981|      0|		case CTO_Match: {
 2982|      0|			int ok = 0;
 2983|      0|			widechar *patterns = NULL;
 2984|      0|			TranslationTableRule *rule;
 2985|      0|			TranslationTableOffset ruleOffset;
 2986|      0|			CharsString ptn_before, ptn_after;
 2987|      0|			TranslationTableOffset patternsOffset;
 2988|      0|			int len, mrk;
 2989|      0|			size_t patternsByteSize = sizeof(*patterns) * 27720;
 2990|      0|			patterns = (widechar *)malloc(patternsByteSize);
 2991|      0|			if (!patterns) _lou_outOfMemory();
 2992|      0|			memset(patterns, 0xffff, patternsByteSize);
 2993|      0|			noback = 1;
 2994|      0|			getCharacters(file, &ptn_before);
 2995|      0|			getRuleCharsText(file, &ruleChars);
 2996|      0|			getCharacters(file, &ptn_after);
 2997|      0|			getRuleDotsPattern(file, &ruleDots);
 2998|      0|			if (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,
 2999|      0|						&rule, noback, nofor, table))
 3000|      0|				goto CTO_Match_cleanup;
 3001|      0|			if (ptn_before.chars[0] == '-' && ptn_before.length == 1)
 3002|      0|				len = _lou_pattern_compile(
 3003|      0|						&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);
 3004|      0|			else
 3005|      0|				len = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,
 3006|      0|						&patterns[1], 13841, *table, file);
 3007|      0|			if (!len) goto CTO_Match_cleanup;
 3008|      0|			mrk = patterns[0] = len + 1;
 3009|      0|			_lou_pattern_reverse(&patterns[1]);
 3010|      0|			if (ptn_after.chars[0] == '-' && ptn_after.length == 1)
 3011|      0|				len = _lou_pattern_compile(
 3012|      0|						&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);
 3013|      0|			else
 3014|      0|				len = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,
 3015|      0|						&patterns[mrk], 13841, *table, file);
 3016|      0|			if (!len) goto CTO_Match_cleanup;
 3017|      0|			len += mrk;
 3018|      0|			if (!allocateSpaceInTranslationTable(
 3019|      0|						file, &patternsOffset, len * sizeof(widechar), table))
 3020|      0|				goto CTO_Match_cleanup;
 3021|      0|			// allocateSpaceInTranslationTable may have moved table, so make sure rule is
 3022|      0|			// still valid
 3023|      0|			rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];
 3024|      0|			memcpy(&(*table)->ruleArea[patternsOffset], patterns, len * sizeof(widechar));
 3025|      0|			rule->patterns = patternsOffset;
 3026|      0|			ok = 1;
 3027|      0|		CTO_Match_cleanup:
 3028|      0|			free(patterns);
 3029|      0|			return ok;
 3030|      0|		}
 3031|      0|
 3032|      0|		case CTO_BackMatch: {
 3033|      0|			int ok = 0;
 3034|      0|			widechar *patterns = NULL;
 3035|      0|			TranslationTableRule *rule;
 3036|      0|			TranslationTableOffset ruleOffset;
 3037|      0|			CharsString ptn_before, ptn_after;
 3038|      0|			TranslationTableOffset patternOffset;
 3039|      0|			int len, mrk;
 3040|      0|			size_t patternsByteSize = sizeof(*patterns) * 27720;
 3041|      0|			patterns = (widechar *)malloc(patternsByteSize);
 3042|      0|			if (!patterns) _lou_outOfMemory();
 3043|      0|			memset(patterns, 0xffff, patternsByteSize);
 3044|      0|			nofor = 1;
 3045|      0|			getCharacters(file, &ptn_before);
 3046|      0|			getRuleCharsText(file, &ruleChars);
 3047|      0|			getCharacters(file, &ptn_after);
 3048|      0|			getRuleDotsPattern(file, &ruleDots);
 3049|      0|			if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, &rule,
 3050|      0|						noback, nofor, table))
 3051|      0|				goto CTO_BackMatch_cleanup;
 3052|      0|			if (ptn_before.chars[0] == '-' && ptn_before.length == 1)
 3053|      0|				len = _lou_pattern_compile(
 3054|      0|						&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);
 3055|      0|			else
 3056|      0|				len = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,
 3057|      0|						&patterns[1], 13841, *table, file);
 3058|      0|			if (!len) goto CTO_BackMatch_cleanup;
 3059|      0|			mrk = patterns[0] = len + 1;
 3060|      0|			_lou_pattern_reverse(&patterns[1]);
 3061|      0|			if (ptn_after.chars[0] == '-' && ptn_after.length == 1)
 3062|      0|				len = _lou_pattern_compile(
 3063|      0|						&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);
 3064|      0|			else
 3065|      0|				len = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,
 3066|      0|						&patterns[mrk], 13841, *table, file);
 3067|      0|			if (!len) goto CTO_BackMatch_cleanup;
 3068|      0|			len += mrk;
 3069|      0|			if (!allocateSpaceInTranslationTable(
 3070|      0|						file, &patternOffset, len * sizeof(widechar), table))
 3071|      0|				goto CTO_BackMatch_cleanup;
 3072|      0|			// allocateSpaceInTranslationTable may have moved table, so make sure rule is
 3073|      0|			// still valid
 3074|      0|			rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];
 3075|      0|			memcpy(&(*table)->ruleArea[patternOffset], patterns, len * sizeof(widechar));
 3076|      0|			rule->patterns = patternOffset;
 3077|      0|			ok = 1;
 3078|      0|		CTO_BackMatch_cleanup:
 3079|      0|			free(patterns);
 3080|      0|			return ok;
 3081|      0|		}
 3082|      0|
 3083|      0|		case CTO_CapsLetter:
 3084|      0|		case CTO_BegCapsWord:
 3085|      0|		case CTO_EndCapsWord:
 3086|      0|		case CTO_BegCaps:
 3087|      0|		case CTO_EndCaps:
 3088|      0|		case CTO_BegCapsPhrase:
 3089|      0|		case CTO_EndCapsPhrase:
 3090|      0|		case CTO_LenCapsPhrase:
 3091|      0|		/* these 8 general purpose opcodes are compiled further down to more specific
 3092|      0|		 * internal opcodes:
 3093|      0|		 * - modeletter
 3094|      0|		 * - begmodeword
 3095|      0|		 * - endmodeword
 3096|      0|		 * - begmode
 3097|      0|		 * - endmode
 3098|      0|		 * - begmodephrase
 3099|      0|		 * - endmodephrase
 3100|      0|		 * - lenmodephrase
 3101|      0|		 */
 3102|      0|		case CTO_ModeLetter:
 3103|      0|		case CTO_BegModeWord:
 3104|      0|		case CTO_EndModeWord:
 3105|      0|		case CTO_BegMode:
 3106|      0|		case CTO_EndMode:
 3107|      0|		case CTO_BegModePhrase:
 3108|      0|		case CTO_EndModePhrase:
 3109|      0|		case CTO_LenModePhrase: {
 3110|      0|			TranslationTableCharacterAttributes mode;
 3111|      0|			int i;
 3112|      0|			switch (opcode) {
 3113|      0|			case CTO_CapsLetter:
 3114|      0|			case CTO_BegCapsWord:
 3115|      0|			case CTO_EndCapsWord:
 3116|      0|			case CTO_BegCaps:
 3117|      0|			case CTO_EndCaps:
 3118|      0|			case CTO_BegCapsPhrase:
 3119|      0|			case CTO_EndCapsPhrase:
 3120|      0|			case CTO_LenCapsPhrase:
 3121|      0|				mode = CTC_UpperCase;
 3122|      0|				i = 0;
 3123|      0|				opcode += (CTO_ModeLetter - CTO_CapsLetter);
 3124|      0|				break;
 3125|      0|			default:
 3126|      0|				if (!getToken(file, &token, "attribute name")) return 0;
 3127|      0|				if (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {
 3128|      0|					return 0;
 3129|      0|				}
 3130|      0|				const CharacterClass *characterClass = findCharacterClass(&token, *table);
 3131|      0|				if (!characterClass) {
 3132|      0|					characterClass =
 3133|      0|							addCharacterClass(file, token.chars, token.length, *table, 1);
 3134|      0|					if (!characterClass) return 0;
 3135|      0|				}
 3136|      0|				mode = characterClass->attribute;
 3137|      0|				if (!(mode == CTC_UpperCase || mode == CTC_Digit) && mode >= CTC_Space &&
 3138|      0|						mode <= CTC_LitDigit) {
 3139|      0|					compileError(file,
 3140|      0|							"mode must be \"uppercase\", \"digit\", or a custom "
 3141|      0|							"attribute name.");
 3142|      0|					return 0;
 3143|      0|				}
 3144|      0|				/* check if this mode is already defined and if the number of modes does
 3145|      0|				 * not exceed the maximal number */
 3146|      0|				if (mode == CTC_UpperCase)
 3147|      0|					i = 0;
 3148|      0|				else {
 3149|      0|					for (i = 1; i < MAX_MODES && (*table)->modes[i].value; i++) {
 3150|      0|						if ((*table)->modes[i].mode == mode) {
 3151|      0|							break;
 3152|      0|						}
 3153|      0|					}
 3154|      0|					if (i == MAX_MODES) {
 3155|      0|						compileError(file, "Max number of modes (%i) reached", MAX_MODES);
 3156|      0|						return 0;
 3157|      0|					}
 3158|      0|				}
 3159|      0|			}
 3160|      0|			if (!(*table)->modes[i].value)
 3161|      0|				(*table)->modes[i] = (EmphasisClass){ plain_text, mode,
 3162|      0|					0x1 << (MAX_EMPH_CLASSES + i), MAX_EMPH_CLASSES + i };
 3163|      0|			switch (opcode) {
 3164|      0|			case CTO_BegModePhrase: {
 3165|      0|				// not passing pointer because compileBrailleIndicator may reallocate
 3166|      0|				// table
 3167|      0|				TranslationTableOffset ruleOffset =
 3168|      0|						(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset];
 3169|      0|				if (!compileBrailleIndicator(file, "first word capital sign",
 3170|      0|							CTO_BegCapsPhraseRule + (8 * i), &ruleOffset, noback, nofor,
 3171|      0|							table))
 3172|      0|					return 0;
 3173|      0|				(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset] = ruleOffset;
 3174|      0|				return 1;
 3175|      0|			}
 3176|      0|			case CTO_EndModePhrase: {
 3177|      0|				TranslationTableOffset ruleOffset;
 3178|      0|				switch (compileBeforeAfter(file)) {
 3179|      0|				case 1:	 // before
 3180|      0|					if ((*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset]) {
 3181|      0|						compileError(
 3182|      0|								file, "Capital sign after last word already defined.");
 3183|      0|						return 0;
 3184|      0|					}
 3185|      0|					// not passing pointer because compileBrailleIndicator may reallocate
 3186|      0|					// table
 3187|      0|					ruleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]
 3188|      0|													[endPhraseBeforeOffset];
 3189|      0|					if (!compileBrailleIndicator(file, "capital sign before last word",
 3190|      0|								CTO_EndCapsPhraseBeforeRule + (8 * i), &ruleOffset,
 3191|      0|								noback, nofor, table))
 3192|      0|						return 0;
 3193|      0|					(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseBeforeOffset] =
 3194|      0|							ruleOffset;
 3195|      0|					return 1;
 3196|      0|				case 2:	 // after
 3197|      0|					if ((*table)->emphRules[MAX_EMPH_CLASSES + i]
 3198|      0|										   [endPhraseBeforeOffset]) {
 3199|      0|						compileError(
 3200|      0|								file, "Capital sign before last word already defined.");
 3201|      0|						return 0;
 3202|      0|					}
 3203|      0|					// not passing pointer because compileBrailleIndicator may reallocate
 3204|      0|					// table
 3205|      0|					ruleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]
 3206|      0|													[endPhraseAfterOffset];
 3207|      0|					if (!compileBrailleIndicator(file, "capital sign after last word",
 3208|      0|								CTO_EndCapsPhraseAfterRule + (8 * i), &ruleOffset, noback,
 3209|      0|								nofor, table))
 3210|      0|						return 0;
 3211|      0|					(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset] =
 3212|      0|							ruleOffset;
 3213|      0|					return 1;
 3214|      0|				default:  // error
 3215|      0|					compileError(file, "Invalid lastword indicator location.");
 3216|      0|					return 0;
 3217|      0|				}
 3218|      0|				return 0;
 3219|      0|			}
 3220|      0|			case CTO_BegMode: {
 3221|      0|				// not passing pointer because compileBrailleIndicator may reallocate
 3222|      0|				// table
 3223|      0|				TranslationTableOffset ruleOffset =
 3224|      0|						(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset];
 3225|      0|				if (!compileBrailleIndicator(file, "first letter capital sign",
 3226|      0|							CTO_BegCapsRule + (8 * i), &ruleOffset, noback, nofor, table))
 3227|      0|					return 0;
 3228|      0|				(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset] = ruleOffset;
 3229|      0|				return 1;
 3230|      0|			}
 3231|      0|			case CTO_EndMode: {
 3232|      0|				// not passing pointer because compileBrailleIndicator may reallocate
 3233|      0|				// table
 3234|      0|				TranslationTableOffset ruleOffset =
 3235|      0|						(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset];
 3236|      0|				if (!compileBrailleIndicator(file, "last letter capital sign",
 3237|      0|							CTO_EndCapsRule + (8 * i), &ruleOffset, noback, nofor, table))
 3238|      0|					return 0;
 3239|      0|				(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset] = ruleOffset;
 3240|      0|				return 1;
 3241|      0|			}
 3242|      0|			case CTO_ModeLetter: {
 3243|      0|				// not passing pointer because compileBrailleIndicator may reallocate
 3244|      0|				// table
 3245|      0|				TranslationTableOffset ruleOffset =
 3246|      0|						(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset];
 3247|      0|				if (!compileBrailleIndicator(file, "single letter capital sign",
 3248|      0|							CTO_CapsLetterRule + (8 * i), &ruleOffset, noback, nofor,
 3249|      0|							table))
 3250|      0|					return 0;
 3251|      0|				(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset] = ruleOffset;
 3252|      0|				return 1;
 3253|      0|			}
 3254|      0|			case CTO_BegModeWord: {
 3255|      0|				// not passing pointer because compileBrailleIndicator may reallocate
 3256|      0|				// table
 3257|      0|				TranslationTableOffset ruleOffset =
 3258|      0|						(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset];
 3259|      0|				if (!compileBrailleIndicator(file, "capital word",
 3260|      0|							CTO_BegCapsWordRule + (8 * i), &ruleOffset, noback, nofor,
 3261|      0|							table))
 3262|      0|					return 0;
 3263|      0|				(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset] = ruleOffset;
 3264|      0|				return 1;
 3265|      0|			}
 3266|      0|			case CTO_EndModeWord: {
 3267|      0|				// not passing pointer because compileBrailleIndicator may reallocate
 3268|      0|				// table
 3269|      0|				TranslationTableOffset ruleOffset =
 3270|      0|						(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset];
 3271|      0|				if (!compileBrailleIndicator(file, "capital word stop",
 3272|      0|							CTO_EndCapsWordRule + (8 * i), &ruleOffset, noback, nofor,
 3273|      0|							table))
 3274|      0|					return 0;
 3275|      0|				(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset] = ruleOffset;
 3276|      0|				return 1;
 3277|      0|			}
 3278|      0|			case CTO_LenModePhrase:
 3279|      0|				return (*table)->emphRules[MAX_EMPH_CLASSES + i][lenPhraseOffset] =
 3280|      0|							   compileNumber(file);
 3281|      0|			default:
 3282|      0|				break;
 3283|      0|			}
 3284|      0|			break;
 3285|      0|		}
 3286|      0|
 3287|      0|		/* these 8 general purpose emphasis opcodes are compiled further down to more
 3288|      0|		 * specific internal opcodes:
 3289|      0|		 * - emphletter
 3290|      0|		 * - begemphword
 3291|      0|		 * - endemphword
 3292|      0|		 * - begemph
 3293|      0|		 * - endemph
 3294|      0|		 * - begemphphrase
 3295|      0|		 * - endemphphrase
 3296|      0|		 * - lenemphphrase
 3297|      0|		 */
 3298|      0|		case CTO_EmphClass:
 3299|      0|			if (!getToken(file, &emphClass, "emphasis class")) {
 3300|      0|				compileError(file, "emphclass must be followed by a valid class name.");
 3301|      0|				return 0;
 3302|      0|			}
 3303|      0|			int k, i;
 3304|      0|			char *s = malloc(sizeof(char) * (emphClass.length + 1));
 3305|      0|			for (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];
 3306|      0|			s[k++] = '\0';
 3307|      0|			for (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)
 3308|      0|				if (strcmp(s, (*table)->emphClassNames[i]) == 0) {
 3309|      0|					_lou_logMessage(LOU_LOG_WARN, "Duplicate emphasis class: %s", s);
 3310|      0|					warningCount++;
 3311|      0|					free(s);
 3312|      0|					return 1;
 3313|      0|				}
 3314|      0|			if (i == MAX_EMPH_CLASSES) {
 3315|      0|				_lou_logMessage(LOU_LOG_ERROR,
 3316|      0|						"Max number of emphasis classes (%i) reached", MAX_EMPH_CLASSES);
 3317|      0|				errorCount++;
 3318|      0|				free(s);
 3319|      0|				return 0;
 3320|      0|			}
 3321|      0|			switch (i) {
 3322|      0|			/* For backwards compatibility (i.e. because programs will assume
 3323|      0|			 * the first 3 typeform bits are `italic', `underline' and `bold')
 3324|      0|			 * we require that the first 3 emphclass definitions are (in that
 3325|      0|			 * order):
 3326|      0|			 *
 3327|      0|			 *   emphclass italic
 3328|      0|			 *   emphclass underline
 3329|      0|			 *   emphclass bold
 3330|      0|			 *
 3331|      0|			 * While it would be possible to use the emphclass opcode only for
 3332|      0|			 * defining _additional_ classes (not allowing for them to be called
 3333|      0|			 * italic, underline or bold), thereby reducing the amount of
 3334|      0|			 * boilerplate, we deliberately choose not to do that in order to
 3335|      0|			 * not give italic, underline and bold any special status. The
 3336|      0|			 * hope is that eventually all programs will use liblouis for
 3337|      0|			 * emphasis the recommended way (i.e. by looking up the supported
 3338|      0|			 * typeforms in the documentation or API) so that we can drop this
 3339|      0|			 * restriction.
 3340|      0|			 */
 3341|      0|			case 0:
 3342|      0|				if (strcmp(s, "italic") != 0) {
 3343|      0|					_lou_logMessage(LOU_LOG_ERROR,
 3344|      0|							"First emphasis class must be \"italic\" but got "
 3345|      0|							"%s",
 3346|      0|							s);
 3347|      0|					errorCount++;
 3348|      0|					free(s);
 3349|      0|					return 0;
 3350|      0|				}
 3351|      0|				break;
 3352|      0|			case 1:
 3353|      0|				if (strcmp(s, "underline") != 0) {
 3354|      0|					_lou_logMessage(LOU_LOG_ERROR,
 3355|      0|							"Second emphasis class must be \"underline\" but "
 3356|      0|							"got "
 3357|      0|							"%s",
 3358|      0|							s);
 3359|      0|					errorCount++;
 3360|      0|					free(s);
 3361|      0|					return 0;
 3362|      0|				}
 3363|      0|				break;
 3364|      0|			case 2:
 3365|      0|				if (strcmp(s, "bold") != 0) {
 3366|      0|					_lou_logMessage(LOU_LOG_ERROR,
 3367|      0|							"Third emphasis class must be \"bold\" but got "
 3368|      0|							"%s",
 3369|      0|							s);
 3370|      0|					errorCount++;
 3371|      0|					free(s);
 3372|      0|					return 0;
 3373|      0|				}
 3374|      0|				break;
 3375|      0|			}
 3376|      0|			(*table)->emphClassNames[i] = s;
 3377|      0|			(*table)->emphClasses[i] = (EmphasisClass){ emph_1
 3378|      0|						<< i, /* relies on the order of typeforms emph_1..emph_10 */
 3379|      0|				0, 0x1 << i, i };
 3380|      0|			return 1;
 3381|      0|		case CTO_EmphLetter:
 3382|      0|		case CTO_BegEmphWord:
 3383|      0|		case CTO_EndEmphWord:
 3384|      0|		case CTO_BegEmph:
 3385|      0|		case CTO_EndEmph:
 3386|      0|		case CTO_BegEmphPhrase:
 3387|      0|		case CTO_EndEmphPhrase:
 3388|      0|		case CTO_LenEmphPhrase:
 3389|      0|		case CTO_EmphModeChars:
 3390|      0|		case CTO_NoEmphChars: {
 3391|      0|			if (!getToken(file, &token, "emphasis class")) return 0;
 3392|      0|			if (!parseChars(file, &emphClass, &token)) return 0;
 3393|      0|			char *s = malloc(sizeof(char) * (emphClass.length + 1));
 3394|      0|			int k, i;
 3395|      0|			for (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];
 3396|      0|			s[k++] = '\0';
 3397|      0|			for (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)
 3398|      0|				if (strcmp(s, (*table)->emphClassNames[i]) == 0) break;
 3399|      0|			if (i == MAX_EMPH_CLASSES || !(*table)->emphClassNames[i]) {
 3400|      0|				_lou_logMessage(LOU_LOG_ERROR, "Emphasis class %s not declared", s);
 3401|      0|				errorCount++;
 3402|      0|				free(s);
 3403|      0|				return 0;
 3404|      0|			}
 3405|      0|			int ok = 0;
 3406|      0|			switch (opcode) {
 3407|      0|			case CTO_EmphLetter: {
 3408|      0|				// not passing pointer because compileBrailleIndicator may reallocate
 3409|      0|				// table
 3410|      0|				TranslationTableOffset ruleOffset = (*table)->emphRules[i][letterOffset];
 3411|      0|				if (!compileBrailleIndicator(file, "single letter",
 3412|      0|							CTO_Emph1LetterRule + letterOffset + (8 * i), &ruleOffset,
 3413|      0|							noback, nofor, table))
 3414|      0|					break;
 3415|      0|				(*table)->emphRules[i][letterOffset] = ruleOffset;
 3416|      0|				ok = 1;
 3417|      0|				break;
 3418|      0|			}
 3419|      0|			case CTO_BegEmphWord: {
 3420|      0|				// not passing pointer because compileBrailleIndicator may reallocate
 3421|      0|				// table
 3422|      0|				TranslationTableOffset ruleOffset = (*table)->emphRules[i][begWordOffset];
 3423|      0|				if (!compileBrailleIndicator(file, "word",
 3424|      0|							CTO_Emph1LetterRule + begWordOffset + (8 * i), &ruleOffset,
 3425|      0|							noback, nofor, table))
 3426|      0|					break;
 3427|      0|				(*table)->emphRules[i][begWordOffset] = ruleOffset;
 3428|      0|				ok = 1;
 3429|      0|				break;
 3430|      0|			}
 3431|      0|			case CTO_EndEmphWord: {
 3432|      0|				// not passing pointer because compileBrailleIndicator may reallocate
 3433|      0|				// table
 3434|      0|				TranslationTableOffset ruleOffset = (*table)->emphRules[i][endWordOffset];
 3435|      0|				if (!compileBrailleIndicator(file, "word stop",
 3436|      0|							CTO_Emph1LetterRule + endWordOffset + (8 * i), &ruleOffset,
 3437|      0|							noback, nofor, table))
 3438|      0|					break;
 3439|      0|				(*table)->emphRules[i][endWordOffset] = ruleOffset;
 3440|      0|				ok = 1;
 3441|      0|				break;
 3442|      0|			}
 3443|      0|			case CTO_BegEmph: {
 3444|      0|				/* fail if both begemph and any of begemphphrase or begemphword are
 3445|      0|				 * defined */
 3446|      0|				if ((*table)->emphRules[i][begWordOffset] ||
 3447|      0|						(*table)->emphRules[i][begPhraseOffset]) {
 3448|      0|					compileError(file,
 3449|      0|							"Cannot define emphasis for both no context and word or "
 3450|      0|							"phrase context, i.e. cannot have both begemph and "
 3451|      0|							"begemphword or begemphphrase.");
 3452|      0|					break;
 3453|      0|				}
 3454|      0|				// not passing pointer because compileBrailleIndicator may reallocate
 3455|      0|				// table
 3456|      0|				TranslationTableOffset ruleOffset = (*table)->emphRules[i][begOffset];
 3457|      0|				if (!compileBrailleIndicator(file, "first letter",
 3458|      0|							CTO_Emph1LetterRule + begOffset + (8 * i), &ruleOffset,
 3459|      0|							noback, nofor, table))
 3460|      0|					break;
 3461|      0|				(*table)->emphRules[i][begOffset] = ruleOffset;
 3462|      0|				ok = 1;
 3463|      0|				break;
 3464|      0|			}
 3465|      0|			case CTO_EndEmph: {
 3466|      0|				if ((*table)->emphRules[i][endWordOffset] ||
 3467|      0|						(*table)->emphRules[i][endPhraseBeforeOffset] ||
 3468|      0|						(*table)->emphRules[i][endPhraseAfterOffset]) {
 3469|      0|					compileError(file,
 3470|      0|							"Cannot define emphasis for both no context and word or "
 3471|      0|							"phrase context, i.e. cannot have both endemph and "
 3472|      0|							"endemphword or endemphphrase.");
 3473|      0|					break;
 3474|      0|				}
 3475|      0|				// not passing pointer because compileBrailleIndicator may reallocate
 3476|      0|				// table
 3477|      0|				TranslationTableOffset ruleOffset = (*table)->emphRules[i][endOffset];
 3478|      0|				if (!compileBrailleIndicator(file, "last letter",
 3479|      0|							CTO_Emph1LetterRule + endOffset + (8 * i), &ruleOffset,
 3480|      0|							noback, nofor, table))
 3481|      0|					break;
 3482|      0|				(*table)->emphRules[i][endOffset] = ruleOffset;
 3483|      0|				ok = 1;
 3484|      0|				break;
 3485|      0|			}
 3486|      0|			case CTO_BegEmphPhrase: {
 3487|      0|				// not passing pointer because compileBrailleIndicator may reallocate
 3488|      0|				// table
 3489|      0|				TranslationTableOffset ruleOffset =
 3490|      0|						(*table)->emphRules[i][begPhraseOffset];
 3491|      0|				if (!compileBrailleIndicator(file, "first word",
 3492|      0|							CTO_Emph1LetterRule + begPhraseOffset + (8 * i), &ruleOffset,
 3493|      0|							noback, nofor, table))
 3494|      0|					break;
 3495|      0|				(*table)->emphRules[i][begPhraseOffset] = ruleOffset;
 3496|      0|				ok = 1;
 3497|      0|				break;
 3498|      0|			}
 3499|      0|			case CTO_EndEmphPhrase:
 3500|      0|				switch (compileBeforeAfter(file)) {
 3501|      0|				case 1: {  // before
 3502|      0|					if ((*table)->emphRules[i][endPhraseAfterOffset]) {
 3503|      0|						compileError(file, "last word after already defined.");
 3504|      0|						break;
 3505|      0|					}
 3506|      0|					// not passing pointer because compileBrailleIndicator may reallocate
 3507|      0|					// table
 3508|      0|					TranslationTableOffset ruleOffset =
 3509|      0|							(*table)->emphRules[i][endPhraseBeforeOffset];
 3510|      0|					if (!compileBrailleIndicator(file, "last word before",
 3511|      0|								CTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i),
 3512|      0|								&ruleOffset, noback, nofor, table))
 3513|      0|						break;
 3514|      0|					(*table)->emphRules[i][endPhraseBeforeOffset] = ruleOffset;
 3515|      0|					ok = 1;
 3516|      0|					break;
 3517|      0|				}
 3518|      0|				case 2: {  // after
 3519|      0|					if ((*table)->emphRules[i][endPhraseBeforeOffset]) {
 3520|      0|						compileError(file, "last word before already defined.");
 3521|      0|						break;
 3522|      0|					}
 3523|      0|					// not passing pointer because compileBrailleIndicator may reallocate
 3524|      0|					// table
 3525|      0|					TranslationTableOffset ruleOffset =
 3526|      0|							(*table)->emphRules[i][endPhraseAfterOffset];
 3527|      0|					if (!compileBrailleIndicator(file, "last word after",
 3528|      0|								CTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i),
 3529|      0|								&ruleOffset, noback, nofor, table))
 3530|      0|						break;
 3531|      0|					(*table)->emphRules[i][endPhraseAfterOffset] = ruleOffset;
 3532|      0|					ok = 1;
 3533|      0|					break;
 3534|      0|				}
 3535|      0|				default:  // error
 3536|      0|					compileError(file, "Invalid lastword indicator location.");
 3537|      0|					break;
 3538|      0|				}
 3539|      0|				break;
 3540|      0|			case CTO_LenEmphPhrase:
 3541|      0|				if (((*table)->emphRules[i][lenPhraseOffset] = compileNumber(file)))
 3542|      0|					ok = 1;
 3543|      0|				break;
 3544|      0|			case CTO_EmphModeChars: {
 3545|      0|				if (!getRuleCharsText(file, &ruleChars)) break;
 3546|      0|				widechar *emphmodechars = (*table)->emphModeChars[i];
 3547|      0|				int len;
 3548|      0|				for (len = 0; len < EMPHMODECHARSSIZE && emphmodechars[len]; len++)
 3549|      0|					;
 3550|      0|				if (len + ruleChars.length > EMPHMODECHARSSIZE) {
 3551|      0|					compileError(file, "More than %d characters", EMPHMODECHARSSIZE);
 3552|      0|					break;
 3553|      0|				}
 3554|      0|				ok = 1;
 3555|      0|				for (int k = 0; k < ruleChars.length; k++) {
 3556|      0|					if (!getChar(ruleChars.chars[k], *table, NULL)) {
 3557|      0|						compileError(file, "Emphasis mode character undefined");
 3558|      0|						ok = 0;
 3559|      0|						break;
 3560|      0|					}
 3561|      0|					emphmodechars[len++] = ruleChars.chars[k];
 3562|      0|				}
 3563|      0|				break;
 3564|      0|			}
 3565|      0|			case CTO_NoEmphChars: {
 3566|      0|				if (!getRuleCharsText(file, &ruleChars)) break;
 3567|      0|				widechar *noemphchars = (*table)->noEmphChars[i];
 3568|      0|				int len;
 3569|      0|				for (len = 0; len < NOEMPHCHARSSIZE && noemphchars[len]; len++)
 3570|      0|					;
 3571|      0|				if (len + ruleChars.length > NOEMPHCHARSSIZE) {
 3572|      0|					compileError(file, "More than %d characters", NOEMPHCHARSSIZE);
 3573|      0|					break;
 3574|      0|				}
 3575|      0|				ok = 1;
 3576|      0|				for (int k = 0; k < ruleChars.length; k++) {
 3577|      0|					if (!getChar(ruleChars.chars[k], *table, NULL)) {
 3578|      0|						compileError(file, "Character undefined");
 3579|      0|						ok = 0;
 3580|      0|						break;
 3581|      0|					}
 3582|      0|					noemphchars[len++] = ruleChars.chars[k];
 3583|      0|				}
 3584|      0|				break;
 3585|      0|			}
 3586|      0|			default:
 3587|      0|				break;
 3588|      0|			}
 3589|      0|			free(s);
 3590|      0|			return ok;
 3591|      0|		}
 3592|      0|		case CTO_LetterSign: {
 3593|      0|			// not passing pointer because compileBrailleIndicator may reallocate table
 3594|      0|			TranslationTableOffset ruleOffset = (*table)->letterSign;
 3595|      0|			if (!compileBrailleIndicator(file, "letter sign", CTO_LetterRule, &ruleOffset,
 3596|      0|						noback, nofor, table))
 3597|      0|				return 0;
 3598|      0|			(*table)->letterSign = ruleOffset;
 3599|      0|			return 1;
 3600|      0|		}
 3601|      0|		case CTO_NoLetsignBefore:
 3602|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3603|      0|			if (((*table)->noLetsignBeforeCount + ruleChars.length) > LETSIGNBEFORESIZE) {
 3604|      0|				compileError(file, "More than %d characters", LETSIGNBEFORESIZE);
 3605|      0|				return 0;
 3606|      0|			}
 3607|      0|			for (int k = 0; k < ruleChars.length; k++)
 3608|      0|				(*table)->noLetsignBefore[(*table)->noLetsignBeforeCount++] =
 3609|      0|						ruleChars.chars[k];
 3610|      0|			return 1;
 3611|      0|		case CTO_NoLetsign:
 3612|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3613|      0|			if (((*table)->noLetsignCount + ruleChars.length) > LETSIGNSIZE) {
 3614|      0|				compileError(file, "More than %d characters", LETSIGNSIZE);
 3615|      0|				return 0;
 3616|      0|			}
 3617|      0|			for (int k = 0; k < ruleChars.length; k++)
 3618|      0|				(*table)->noLetsign[(*table)->noLetsignCount++] = ruleChars.chars[k];
 3619|      0|			return 1;
 3620|      0|		case CTO_NoLetsignAfter:
 3621|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3622|      0|			if (((*table)->noLetsignAfterCount + ruleChars.length) > LETSIGNAFTERSIZE) {
 3623|      0|				compileError(file, "More than %d characters", LETSIGNAFTERSIZE);
 3624|      0|				return 0;
 3625|      0|			}
 3626|      0|			for (int k = 0; k < ruleChars.length; k++)
 3627|      0|				(*table)->noLetsignAfter[(*table)->noLetsignAfterCount++] =
 3628|      0|						ruleChars.chars[k];
 3629|      0|			return 1;
 3630|      0|		case CTO_NumberSign: {
 3631|      0|			// not passing pointer because compileBrailleIndicator may reallocate table
 3632|      0|			TranslationTableOffset ruleOffset = (*table)->numberSign;
 3633|      0|			if (!compileBrailleIndicator(file, "number sign", CTO_NumberRule, &ruleOffset,
 3634|      0|						noback, nofor, table))
 3635|      0|				return 0;
 3636|      0|			(*table)->numberSign = ruleOffset;
 3637|      0|			return 1;
 3638|      0|		}
 3639|      0|
 3640|      0|		case CTO_NumericModeChars:
 3641|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3642|      0|			for (int k = 0; k < ruleChars.length; k++) {
 3643|      0|				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);
 3644|      0|				if (!c) {
 3645|      0|					compileError(file, "Numeric mode character undefined: %s",
 3646|      0|							_lou_showString(&ruleChars.chars[k], 1, 0));
 3647|      0|					return 0;
 3648|      0|				}
 3649|      0|				c->attributes |= CTC_NumericMode;
 3650|      0|				(*table)->usesNumericMode = 1;
 3651|      0|			}
 3652|      0|			return 1;
 3653|      0|
 3654|      0|		case CTO_MidEndNumericModeChars:
 3655|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3656|      0|			for (int k = 0; k < ruleChars.length; k++) {
 3657|      0|				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);
 3658|      0|				if (!c) {
 3659|      0|					compileError(file, "Midendnumeric mode character undefined");
 3660|      0|					return 0;
 3661|      0|				}
 3662|      0|				c->attributes |= CTC_MidEndNumericMode;
 3663|      0|				(*table)->usesNumericMode = 1;
 3664|      0|			}
 3665|      0|			return 1;
 3666|      0|
 3667|      0|		case CTO_NumericNoContractChars:
 3668|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3669|      0|			for (int k = 0; k < ruleChars.length; k++) {
 3670|      0|				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);
 3671|      0|				if (!c) {
 3672|      0|					compileError(file, "Numeric no contraction character undefined");
 3673|      0|					return 0;
 3674|      0|				}
 3675|      0|				c->attributes |= CTC_NumericNoContract;
 3676|      0|				(*table)->usesNumericMode = 1;
 3677|      0|			}
 3678|      0|			return 1;
 3679|      0|
 3680|      0|		case CTO_NoContractSign: {
 3681|      0|			// not passing pointer because compileBrailleIndicator may reallocate table
 3682|      0|			TranslationTableOffset ruleOffset = (*table)->noContractSign;
 3683|      0|			if (!compileBrailleIndicator(file, "no contractions sign", CTO_NoContractRule,
 3684|      0|						&ruleOffset, noback, nofor, table))
 3685|      0|				return 0;
 3686|      0|			(*table)->noContractSign = ruleOffset;
 3687|      0|			return 1;
 3688|      0|		}
 3689|      0|		case CTO_SeqDelimiter:
 3690|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3691|      0|			for (int k = 0; k < ruleChars.length; k++) {
 3692|      0|				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);
 3693|      0|				if (!c) {
 3694|      0|					compileError(file, "Sequence delimiter character undefined");
 3695|      0|					return 0;
 3696|      0|				}
 3697|      0|				c->attributes |= CTC_SeqDelimiter;
 3698|      0|				(*table)->usesSequences = 1;
 3699|      0|			}
 3700|      0|			return 1;
 3701|      0|
 3702|      0|		case CTO_SeqBeforeChars:
 3703|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3704|      0|			for (int k = 0; k < ruleChars.length; k++) {
 3705|      0|				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);
 3706|      0|				if (!c) {
 3707|      0|					compileError(file, "Sequence before character undefined");
 3708|      0|					return 0;
 3709|      0|				}
 3710|      0|				c->attributes |= CTC_SeqBefore;
 3711|      0|			}
 3712|      0|			return 1;
 3713|      0|
 3714|      0|		case CTO_SeqAfterChars:
 3715|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3716|      0|			for (int k = 0; k < ruleChars.length; k++) {
 3717|      0|				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);
 3718|      0|				if (!c) {
 3719|      0|					compileError(file, "Sequence after character undefined");
 3720|      0|					return 0;
 3721|      0|				}
 3722|      0|				c->attributes |= CTC_SeqAfter;
 3723|      0|			}
 3724|      0|			return 1;
 3725|      0|
 3726|      0|		case CTO_SeqAfterPattern:
 3727|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3728|      0|			if (((*table)->seqPatternsCount + ruleChars.length + 1) > SEQPATTERNSIZE) {
 3729|      0|				compileError(file, "More than %d characters", SEQPATTERNSIZE);
 3730|      0|				return 0;
 3731|      0|			}
 3732|      0|			for (int k = 0; k < ruleChars.length; k++)
 3733|      0|				(*table)->seqPatterns[(*table)->seqPatternsCount++] = ruleChars.chars[k];
 3734|      0|			(*table)->seqPatterns[(*table)->seqPatternsCount++] = 0;
 3735|      0|			return 1;
 3736|      0|
 3737|      0|		case CTO_SeqAfterExpression:
 3738|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3739|      0|			for ((*table)->seqAfterExpressionLength = 0;
 3740|      0|					(*table)->seqAfterExpressionLength < ruleChars.length;
 3741|      0|					(*table)->seqAfterExpressionLength++)
 3742|      0|				(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] =
 3743|      0|						ruleChars.chars[(*table)->seqAfterExpressionLength];
 3744|      0|			(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] = 0;
 3745|      0|			return 1;
 3746|      0|
 3747|      0|		case CTO_CapsModeChars:
 3748|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3749|      0|			for (int k = 0; k < ruleChars.length; k++) {
 3750|      0|				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);
 3751|      0|				if (!c) {
 3752|      0|					compileError(file, "Capital mode character undefined");
 3753|      0|					return 0;
 3754|      0|				}
 3755|      0|				c->attributes |= CTC_CapsMode;
 3756|      0|				(*table)->hasCapsModeChars = 1;
 3757|      0|			}
 3758|      0|			return 1;
 3759|      0|
 3760|      0|		case CTO_BegComp: {
 3761|      0|			// not passing pointer because compileBrailleIndicator may reallocate table
 3762|      0|			TranslationTableOffset ruleOffset = (*table)->begComp;
 3763|      0|			if (!compileBrailleIndicator(file, "begin computer braille", CTO_BegCompRule,
 3764|      0|						&ruleOffset, noback, nofor, table))
 3765|      0|				return 0;
 3766|      0|			(*table)->begComp = ruleOffset;
 3767|      0|			return 1;
 3768|      0|		}
 3769|      0|		case CTO_EndComp: {
 3770|      0|			// not passing pointer because compileBrailleIndicator may reallocate table
 3771|      0|			TranslationTableOffset ruleOffset = (*table)->endComp;
 3772|      0|			if (!compileBrailleIndicator(file, "end computer braslle", CTO_EndCompRule,
 3773|      0|						&ruleOffset, noback, nofor, table))
 3774|      0|				return 0;
 3775|      0|			(*table)->endComp = ruleOffset;
 3776|      0|			return 1;
 3777|      0|		}
 3778|      0|		case CTO_NoCross:
 3779|      0|			if (nocross) {
 3780|      0|				compileError(
 3781|      0|						file, "%s already specified.", _lou_findOpcodeName(CTO_NoCross));
 3782|      0|				return 0;
 3783|      0|			}
 3784|      0|			nocross = 1;
 3785|      0|			goto doOpcode;
 3786|      0|		case CTO_Syllable:
 3787|      0|			(*table)->syllables = 1;
 3788|      0|		case CTO_Always:
 3789|      0|		case CTO_LargeSign:
 3790|      0|		case CTO_WholeWord:
 3791|      0|		case CTO_PartWord:
 3792|      0|		case CTO_JoinNum:
 3793|      0|		case CTO_JoinableWord:
 3794|      0|		case CTO_LowWord:
 3795|      0|		case CTO_SuffixableWord:
 3796|      0|		case CTO_PrefixableWord:
 3797|      0|		case CTO_BegWord:
 3798|      0|		case CTO_BegMidWord:
 3799|      0|		case CTO_MidWord:
 3800|      0|		case CTO_MidEndWord:
 3801|      0|		case CTO_EndWord:
 3802|      0|		case CTO_PrePunc:
 3803|      0|		case CTO_PostPunc:
 3804|      0|		case CTO_BegNum:
 3805|      0|		case CTO_MidNum:
 3806|      0|		case CTO_EndNum:
 3807|      0|		case CTO_Repeated:
 3808|      0|		case CTO_RepWord:
 3809|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3810|      0|			if (!getRuleDotsPattern(file, &ruleDots)) return 0;
 3811|      0|			if (ruleDots.length == 0)
 3812|      0|				// check that all characters in a rule with `=` as second operand are
 3813|      0|				// defined (or based on another character)
 3814|      0|				for (int k = 0; k < ruleChars.length; k++) {
 3815|      0|					TranslationTableCharacter *c =
 3816|      0|							getChar(ruleChars.chars[k], *table, NULL);
 3817|      0|					if (!(c && (c->definitionRule || c->basechar))) {
 3818|      0|						compileError(file, "Character %s is not defined",
 3819|      0|								_lou_showString(&ruleChars.chars[k], 1, 0));
 3820|      0|						return 0;
 3821|      0|					}
 3822|      0|				}
 3823|      0|			TranslationTableRule *r;
 3824|      0|			if (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, &r,
 3825|      0|						noback, nofor, table))
 3826|      0|				return 0;
 3827|      0|			if (nocross) r->nocross = 1;
 3828|      0|			return 1;
 3829|      0|			// if (opcode == CTO_MidNum)
 3830|      0|			// {
 3831|      0|			//   TranslationTableCharacter *c = getChar(ruleChars.chars[0]);
 3832|      0|			//   if(c)
 3833|      0|			//     c->attributes |= CTC_NumericMode;
 3834|      0|			// }
 3835|      0|		case CTO_RepEndWord:
 3836|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3837|      0|			CharsString dots;
 3838|      0|			if (!getToken(file, &dots, "dots,dots operand")) return 0;
 3839|      0|			int len = dots.length;
 3840|      0|			for (int k = 0; k < len - 1; k++) {
 3841|      0|				if (dots.chars[k] == ',') {
 3842|      0|					dots.length = k;
 3843|      0|					if (!parseDots(file, &ruleDots, &dots)) return 0;
 3844|      0|					ruleDots.chars[ruleDots.length++] = ',';
 3845|      0|					k++;
 3846|      0|					if (k == len - 1 && dots.chars[k] == '=') {
 3847|      0|						// check that all characters are defined (or based on another
 3848|      0|						// character)
 3849|      0|						for (int l = 0; l < ruleChars.length; l++) {
 3850|      0|							TranslationTableCharacter *c =
 3851|      0|									getChar(ruleChars.chars[l], *table, NULL);
 3852|      0|							if (!(c && (c->definitionRule || c->basechar))) {
 3853|      0|								compileError(file, "Character %s is not defined",
 3854|      0|										_lou_showString(&ruleChars.chars[l], 1, 0));
 3855|      0|								return 0;
 3856|      0|							}
 3857|      0|						}
 3858|      0|					} else {
 3859|      0|						CharsString x, y;
 3860|      0|						x.length = 0;
 3861|      0|						while (k < len) x.chars[x.length++] = dots.chars[k++];
 3862|      0|						if (parseDots(file, &y, &x))
 3863|      0|							for (int l = 0; l < y.length; l++)
 3864|      0|								ruleDots.chars[ruleDots.length++] = y.chars[l];
 3865|      0|					}
 3866|      0|					return addRule(file, opcode, &ruleChars, &ruleDots, after, before,
 3867|      0|							NULL, NULL, noback, nofor, table);
 3868|      0|				}
 3869|      0|			}
 3870|      0|			return 0;
 3871|      0|		case CTO_CompDots:
 3872|      0|		case CTO_Comp6: {
 3873|      0|			TranslationTableOffset ruleOffset;
 3874|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3875|      0|			if (ruleChars.length != 1) {
 3876|      0|				compileError(file, "first operand must be 1 character");
 3877|      0|				return 0;
 3878|      0|			}
 3879|      0|			if (nofor || noback) {
 3880|      0|				compileWarning(file, "nofor and noback not allowed on comp6 rules");
 3881|      0|			}
 3882|      0|			if (!getRuleDotsPattern(file, &ruleDots)) return 0;
 3883|      0|			if (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,
 3884|      0|						NULL, noback, nofor, table))
 3885|      0|				return 0;
 3886|      0|			return 1;
 3887|      0|		}
 3888|      0|		case CTO_ExactDots:
 3889|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3890|      0|			if (ruleChars.chars[0] != '@') {
 3891|      0|				compileError(file, "The operand must begin with an at sign (@)");
 3892|      0|				return 0;
 3893|      0|			}
 3894|      0|			for (int k = 1; k < ruleChars.length; k++)
 3895|      0|				scratchPad.chars[k - 1] = ruleChars.chars[k];
 3896|      0|			scratchPad.length = ruleChars.length - 1;
 3897|      0|			if (!parseDots(file, &ruleDots, &scratchPad)) return 0;
 3898|      0|			return addRule(file, opcode, &ruleChars, &ruleDots, before, after, NULL, NULL,
 3899|      0|					noback, nofor, table);
 3900|      0|		case CTO_CapsNoCont: {
 3901|      0|			TranslationTableOffset ruleOffset;
 3902|      0|			ruleChars.length = 1;
 3903|      0|			ruleChars.chars[0] = 'a';
 3904|      0|			if (!addRule(file, CTO_CapsNoContRule, &ruleChars, NULL, after, before,
 3905|      0|						&ruleOffset, NULL, noback, nofor, table))
 3906|      0|				return 0;
 3907|      0|			(*table)->capsNoCont = ruleOffset;
 3908|      0|			return 1;
 3909|      0|		}
 3910|      0|		case CTO_Replace:
 3911|      0|			if (getRuleCharsText(file, &ruleChars)) {
 3912|      0|				if (atEndOfLine(file))
 3913|      0|					ruleDots.length = ruleDots.chars[0] = 0;
 3914|      0|				else {
 3915|      0|					getRuleDotsText(file, &ruleDots);
 3916|      0|					if (ruleDots.chars[0] == '#')
 3917|      0|						ruleDots.length = ruleDots.chars[0] = 0;
 3918|      0|					else if (ruleDots.chars[0] == '\\' && ruleDots.chars[1] == '#')
 3919|      0|						memmove(&ruleDots.chars[0], &ruleDots.chars[1],
 3920|      0|								ruleDots.length-- * CHARSIZE);
 3921|      0|				}
 3922|      0|			}
 3923|      0|			for (int k = 0; k < ruleChars.length; k++)
 3924|      0|				putChar(file, ruleChars.chars[k], table, NULL);
 3925|      0|			for (int k = 0; k < ruleDots.length; k++)
 3926|      0|				putChar(file, ruleDots.chars[k], table, NULL);
 3927|      0|			return addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,
 3928|      0|					noback, nofor, table);
 3929|      0|		case CTO_Correct:
 3930|      0|			(*table)->corrections = 1;
 3931|      0|			goto doPass;
 3932|      0|		case CTO_Pass2:
 3933|      0|			if ((*table)->numPasses < 2) (*table)->numPasses = 2;
 3934|      0|			goto doPass;
 3935|      0|		case CTO_Pass3:
 3936|      0|			if ((*table)->numPasses < 3) (*table)->numPasses = 3;
 3937|      0|			goto doPass;
 3938|      0|		case CTO_Pass4:
 3939|      0|			if ((*table)->numPasses < 4) (*table)->numPasses = 4;
 3940|      0|		doPass:
 3941|      0|		case CTO_Context:
 3942|      0|			if (!(nofor || noback)) {
 3943|      0|				compileError(file, "%s or %s must be specified.",
 3944|      0|						_lou_findOpcodeName(CTO_NoFor), _lou_findOpcodeName(CTO_NoBack));
 3945|      0|				return 0;
 3946|      0|			}
 3947|      0|			return compilePassOpcode(file, opcode, noback, nofor, table);
 3948|      0|		case CTO_Contraction:
 3949|      0|		case CTO_NoCont:
 3950|      0|		case CTO_CompBrl:
 3951|      0|		case CTO_Literal:
 3952|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 3953|      0|			// check that all characters in a compbrl, contraction,
 3954|      0|			// nocont or literal rule are defined (or based on another
 3955|      0|			// character)
 3956|      0|			for (int k = 0; k < ruleChars.length; k++) {
 3957|      0|				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);
 3958|      0|				if (!(c && (c->definitionRule || c->basechar))) {
 3959|      0|					compileError(file, "Character %s is not defined",
 3960|      0|							_lou_showString(&ruleChars.chars[k], 1, 0));
 3961|      0|					return 0;
 3962|      0|				}
 3963|      0|			}
 3964|      0|			return addRule(file, opcode, &ruleChars, NULL, after, before, NULL, NULL,
 3965|      0|					noback, nofor, table);
 3966|      0|		case CTO_MultInd: {
 3967|      0|			ruleChars.length = 0;
 3968|      0|			if (!getToken(file, &token, "multiple braille indicators") ||
 3969|      0|					!parseDots(file, &cells, &token))
 3970|      0|				return 0;
 3971|      0|			while (getToken(file, &token, "multind opcodes")) {
 3972|      0|				opcode = getOpcode(file, &token);
 3973|      0|				if (opcode == CTO_None) {
 3974|      0|					compileError(file, "opcode %s not defined.",
 3975|      0|							_lou_showString(token.chars, token.length, 0));
 3976|      0|					return 0;
 3977|      0|				}
 3978|      0|				if (!(opcode >= CTO_CapsLetter && opcode < CTO_MultInd)) {
 3979|      0|					compileError(file, "Not a braille indicator opcode.");
 3980|      0|					return 0;
 3981|      0|				}
 3982|      0|				ruleChars.chars[ruleChars.length++] = (widechar)opcode;
 3983|      0|				if (atEndOfLine(file)) break;
 3984|      0|			}
 3985|      0|			return addRule(file, CTO_MultInd, &ruleChars, &cells, after, before, NULL,
 3986|      0|					NULL, noback, nofor, table);
 3987|      0|		}
 3988|      0|
 3989|      0|		case CTO_Class:
 3990|      0|			compileWarning(file, "class is deprecated, use attribute instead");
 3991|      0|		case CTO_Attribute: {
 3992|      0|			if (nofor || noback) {
 3993|      0|				compileWarning(
 3994|      0|						file, "nofor and noback not allowed before class/attribute");
 3995|      0|			}
 3996|      0|			if ((opcode == CTO_Class && (*table)->usesAttributeOrClass == 1) ||
 3997|      0|					(opcode == CTO_Attribute && (*table)->usesAttributeOrClass == 2)) {
 3998|      0|				compileError(file,
 3999|      0|						"attribute and class rules must not be both present in a table");
 4000|      0|				return 0;
 4001|      0|			}
 4002|      0|			if (opcode == CTO_Class)
 4003|      0|				(*table)->usesAttributeOrClass = 2;
 4004|      0|			else
 4005|      0|				(*table)->usesAttributeOrClass = 1;
 4006|      0|			if (!getToken(file, &token, "attribute name")) {
 4007|      0|				compileError(file, "Expected %s", "attribute name");
 4008|      0|				return 0;
 4009|      0|			}
 4010|      0|			if (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {
 4011|      0|				return 0;
 4012|      0|			}
 4013|      0|
 4014|      0|			TranslationTableCharacterAttributes attribute = 0;
 4015|      0|			{
 4016|      0|				int attrNumber = -1;
 4017|      0|				switch (token.chars[0]) {
 4018|      0|				case '0':
 4019|      0|				case '1':
 4020|      0|				case '2':
 4021|      0|				case '3':
 4022|      0|				case '4':
 4023|      0|				case '5':
 4024|      0|				case '6':
 4025|      0|				case '7':
 4026|      0|				case '8':
 4027|      0|				case '9':
 4028|      0|					attrNumber = token.chars[0] - '0';
 4029|      0|					break;
 4030|      0|				}
 4031|      0|				if (attrNumber >= 0) {
 4032|      0|					if (opcode == CTO_Class) {
 4033|      0|						compileError(file,
 4034|      0|								"Invalid class name: may not contain digits, use "
 4035|      0|								"attribute instead of class");
 4036|      0|						return 0;
 4037|      0|					}
 4038|      0|					if (token.length > 1 || attrNumber > 7) {
 4039|      0|						compileError(file,
 4040|      0|								"Invalid attribute name: must be a digit between 0 and 7 "
 4041|      0|								"or a word containing only letters");
 4042|      0|						return 0;
 4043|      0|					}
 4044|      0|					if (!(*table)->numberedAttributes[attrNumber])
 4045|      0|						// attribute not used before yet: assign it a value
 4046|      0|						(*table)->numberedAttributes[attrNumber] =
 4047|      0|								getNextNumberedAttribute(*table);
 4048|      0|					attribute = (*table)->numberedAttributes[attrNumber];
 4049|      0|				} else {
 4050|      0|					const CharacterClass *namedAttr = findCharacterClass(&token, *table);
 4051|      0|					if (!namedAttr) {
 4052|      0|						// no class with that name: create one
 4053|      0|						namedAttr = addCharacterClass(
 4054|      0|								file, &token.chars[0], token.length, *table, 1);
 4055|      0|						if (!namedAttr) return 0;
 4056|      0|					}
 4057|      0|					// there is a class with that name or a new class was successfully
 4058|      0|					// created
 4059|      0|					attribute = namedAttr->attribute;
 4060|      0|					if (attribute == CTC_UpperCase || attribute == CTC_LowerCase)
 4061|      0|						attribute |= CTC_Letter;
 4062|      0|				}
 4063|      0|			}
 4064|      0|			CharsString characters;
 4065|      0|			if (!getCharacters(file, &characters)) return 0;
 4066|      0|			for (int i = 0; i < characters.length; i++) {
 4067|      0|				// get the character from the table, or if it is not defined yet,
 4068|      0|				// define it
 4069|      0|				TranslationTableCharacter *character =
 4070|      0|						putChar(file, characters.chars[i], table, NULL);
 4071|      0|				// set the attribute
 4072|      0|				character->attributes |= attribute;
 4073|      0|				// also set the attribute on the associated dots (if any)
 4074|      0|				if (character->basechar)
 4075|      0|					character = (TranslationTableCharacter *)&(*table)
 4076|      0|										->ruleArea[character->basechar];
 4077|      0|				if (character->definitionRule) {
 4078|      0|					TranslationTableRule *defRule =
 4079|      0|							(TranslationTableRule *)&(*table)
 4080|      0|									->ruleArea[character->definitionRule];
 4081|      0|					if (defRule->dotslen == 1) {
 4082|      0|						TranslationTableCharacter *dots =
 4083|      0|								getDots(defRule->charsdots[defRule->charslen], *table);
 4084|      0|						if (dots) dots->attributes |= attribute;
 4085|      0|					}
 4086|      0|				}
 4087|      0|			}
 4088|      0|			return 1;
 4089|      0|		}
 4090|      0|
 4091|      0|			{
 4092|      0|				TranslationTableCharacterAttributes *attributes;
 4093|      0|				const CharacterClass *class;
 4094|      0|			case CTO_After:
 4095|      0|				attributes = &after;
 4096|      0|				goto doBeforeAfter;
 4097|      0|			case CTO_Before:
 4098|      0|				attributes = &before;
 4099|      0|			doBeforeAfter:
 4100|      0|				if (!(*table)->characterClasses) {
 4101|      0|					if (!allocateCharacterClasses(*table)) return 0;
 4102|      0|				}
 4103|      0|				if (!getToken(file, &token, "attribute name")) return 0;
 4104|      0|				if (!(class = findCharacterClass(&token, *table))) {
 4105|      0|					compileError(file, "attribute not defined");
 4106|      0|					return 0;
 4107|      0|				}
 4108|      0|				*attributes |= class->attribute;
 4109|      0|				goto doOpcode;
 4110|      0|			}
 4111|      0|		case CTO_Base:
 4112|      0|			if (nofor || noback) {
 4113|      0|				compileWarning(file, "nofor and noback not allowed before base");
 4114|      0|			}
 4115|      0|			if (!getToken(file, &token, "attribute name")) {
 4116|      0|				compileError(
 4117|      0|						file, "base opcode must be followed by a valid attribute name.");
 4118|      0|				return 0;
 4119|      0|			}
 4120|      0|			if (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {
 4121|      0|				return 0;
 4122|      0|			}
 4123|      0|			const CharacterClass *mode = findCharacterClass(&token, *table);
 4124|      0|			if (!mode) {
 4125|      0|				mode = addCharacterClass(file, token.chars, token.length, *table, 1);
 4126|      0|				if (!mode) return 0;
 4127|      0|			}
 4128|      0|			if (!(mode->attribute == CTC_UpperCase || mode->attribute == CTC_Digit) &&
 4129|      0|					mode->attribute >= CTC_Space && mode->attribute <= CTC_LitDigit) {
 4130|      0|				compileError(file,
 4131|      0|						"base opcode must be followed by \"uppercase\", \"digit\", or a "
 4132|      0|						"custom attribute name.");
 4133|      0|				return 0;
 4134|      0|			}
 4135|      0|			if (!getRuleCharsText(file, &token)) return 0;
 4136|      0|			if (token.length != 1) {
 4137|      0|				compileError(file,
 4138|      0|						"Exactly one character followed by one base character is "
 4139|      0|						"required.");
 4140|      0|				return 0;
 4141|      0|			}
 4142|      0|			TranslationTableOffset characterOffset;
 4143|      0|			TranslationTableCharacter *character =
 4144|      0|					putChar(file, token.chars[0], table, &characterOffset);
 4145|      0|			if (!getRuleCharsText(file, &token)) return 0;
 4146|      0|			if (token.length != 1) {
 4147|      0|				compileError(file, "Exactly one base character is required.");
 4148|      0|				return 0;
 4149|      0|			}
 4150|      0|			if (character->definitionRule) {
 4151|      0|				TranslationTableRule *prevRule =
 4152|      0|						(TranslationTableRule *)&(*table)
 4153|      0|								->ruleArea[character->definitionRule];
 4154|      0|				_lou_logMessage(LOU_LOG_DEBUG,
 4155|      0|						"%s:%d: Character already defined (%s). The base rule will take "
 4156|      0|						"precedence.",
 4157|      0|						file->fileName, file->lineNumber,
 4158|      0|						printSource(file, prevRule->sourceFile, prevRule->sourceLine));
 4159|      0|				character->definitionRule = 0;
 4160|      0|			}
 4161|      0|			TranslationTableOffset basechar;
 4162|      0|			putChar(file, token.chars[0], table, &basechar);
 4163|      0|			// putChar may have moved table, so make sure character is still valid
 4164|      0|			character = (TranslationTableCharacter *)&(*table)->ruleArea[characterOffset];
 4165|      0|			if (character->basechar) {
 4166|      0|				if (character->basechar == basechar &&
 4167|      0|						character->mode == mode->attribute) {
 4168|      0|					_lou_logMessage(LOU_LOG_DEBUG, "%s:%d: Duplicate base rule.",
 4169|      0|							file->fileName, file->lineNumber);
 4170|      0|				} else {
 4171|      0|					_lou_logMessage(LOU_LOG_DEBUG,
 4172|      0|							"%s:%d: A different base rule already exists for this "
 4173|      0|							"character (%s). The new rule will take precedence.",
 4174|      0|							file->fileName, file->lineNumber,
 4175|      0|							printSource(
 4176|      0|									file, character->sourceFile, character->sourceLine));
 4177|      0|				}
 4178|      0|			}
 4179|      0|			character->basechar = basechar;
 4180|      0|			character->mode = mode->attribute;
 4181|      0|			character->sourceFile = file->sourceFile;
 4182|      0|			character->sourceLine = file->lineNumber;
 4183|      0|			/* some other processing is done at the end of the compilation, in
 4184|      0|			 * finalizeTable() */
 4185|      0|			return 1;
 4186|      0|		case CTO_EmpMatchBefore:
 4187|      0|			before |= CTC_EmpMatch;
 4188|      0|			goto doOpcode;
 4189|      0|		case CTO_EmpMatchAfter:
 4190|      0|			after |= CTC_EmpMatch;
 4191|      0|			goto doOpcode;
 4192|      0|
 4193|      0|		case CTO_SwapCc:
 4194|      0|		case CTO_SwapCd:
 4195|      0|		case CTO_SwapDd:
 4196|      0|			return compileSwap(file, opcode, noback, nofor, table);
 4197|      0|		case CTO_Hyphen:
 4198|      0|		case CTO_DecPoint:
 4199|      0|			//	case CTO_Apostrophe:
 4200|      0|			//	case CTO_Initial:
 4201|      0|			if (!getRuleCharsText(file, &ruleChars)) return 0;
 4202|      0|			if (!getRuleDotsPattern(file, &ruleDots)) return 0;
 4203|      0|			if (ruleChars.length != 1 || ruleDots.length < 1) {
 4204|      0|				compileError(file,
 4205|      0|						"One Unicode character and at least one cell are "
 4206|      0|						"required.");
 4207|      0|				return 0;
 4208|      0|			}
 4209|      0|			return addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,
 4210|      0|					noback, nofor, table);
 4211|      0|			// if (opcode == CTO_DecPoint)
 4212|      0|			// {
 4213|      0|			//   TranslationTableCharacter *c =
 4214|      0|			//   getChar(ruleChars.chars[0]);
 4215|      0|			//   if(c)
 4216|      0|			//     c->attributes |= CTC_NumericMode;
 4217|      0|			// }
 4218|      0|		default:
 4219|      0|			compileError(file, "unimplemented opcode.");
 4220|      0|			return 0;
 4221|      0|		}
 4222|      0|	}
 4223|      0|	return 0;
 4224|      0|}
 4225|       |
 4226|       |int EXPORT_CALL
 4227|      0|lou_readCharFromFile(const char *fileName, int *mode) {
 4228|      0|	/* Read a character from a file, whether big-endian, little-endian or
 4229|      0|	 * ASCII8 */
 4230|      0|	int ch;
 4231|      0|	static FileInfo file;
 4232|      0|	if (fileName == NULL) return 0;
 4233|      0|	if (*mode == 1) {
 4234|      0|		*mode = 0;
 4235|      0|		file.fileName = fileName;
 4236|      0|		file.encoding = noEncoding;
 4237|      0|		file.status = 0;
 4238|      0|		file.lineNumber = 0;
 4239|      0|		if (!(file.in = fopen(file.fileName, "r"))) {
 4240|      0|			_lou_logMessage(LOU_LOG_ERROR, "Cannot open file '%s'", file.fileName);
 4241|      0|			*mode = 1;
 4242|      0|			return EOF;
 4243|      0|		}
 4244|      0|	}
 4245|      0|	if (file.in == NULL) {
 4246|      0|		*mode = 1;
 4247|      0|		return EOF;
 4248|      0|	}
 4249|      0|	ch = getAChar(&file);
 4250|      0|	if (ch == EOF) {
 4251|      0|		fclose(file.in);
 4252|      0|		file.in = NULL;
 4253|      0|		*mode = 1;
 4254|      0|	}
 4255|      0|	return ch;
 4256|      0|}
 4257|       |
 4258|       |static int
 4259|      0|finalizeTable(TranslationTableHeader *table) {
 4260|      0|	if (table->finalized) return 1;
 4261|      0|	// normalize basechar and mode of all characters
 4262|      0|	for (int i = 0; i < HASHNUM; i++) {
 4263|      0|		TranslationTableOffset characterOffset = table->characters[i];
 4264|      0|		while (characterOffset) {
 4265|      0|			TranslationTableCharacter *character =
 4266|      0|					(TranslationTableCharacter *)&table->ruleArea[characterOffset];
 4267|      0|			if (character->basechar) {
 4268|      0|				TranslationTableOffset basecharOffset = 0;
 4269|      0|				TranslationTableCharacter *basechar = character;
 4270|      0|				TranslationTableCharacterAttributes mode = 0;
 4271|      0|				int detect_loop = 0;
 4272|      0|				while (basechar->basechar) {
 4273|      0|					if (basechar->basechar == characterOffset ||
 4274|      0|							detect_loop++ > MAX_MODES) {
 4275|      0|						_lou_logMessage(LOU_LOG_ERROR,
 4276|      0|								"%s: error: Character can not be (indirectly) based on "
 4277|      0|								"itself.",
 4278|      0|								printSource(NULL, character->sourceFile,
 4279|      0|										character->sourceLine));
 4280|      0|						errorCount++;
 4281|      0|						return 0;
 4282|      0|					}
 4283|      0|					// inherit basechar mode
 4284|      0|					mode |= basechar->mode;
 4285|      0|					// compute basechar recursively
 4286|      0|					basecharOffset = basechar->basechar;
 4287|      0|					basechar =
 4288|      0|							(TranslationTableCharacter *)&table->ruleArea[basecharOffset];
 4289|      0|					if (character->mode & (basechar->attributes | basechar->mode)) {
 4290|      0|						char *attributeName = NULL;
 4291|      0|						const CharacterClass *class = table->characterClasses;
 4292|      0|						while (class) {
 4293|      0|							if (class->attribute == character->mode) {
 4294|      0|								attributeName = strdup(
 4295|      0|										_lou_showString(class->name, class->length, 0));
 4296|      0|								break;
 4297|      0|							}
 4298|      0|							class = class->next;
 4299|      0|						}
 4300|      0|						_lou_logMessage(LOU_LOG_ERROR,
 4301|      0|								"%s: error: Base character %s can not have the %s "
 4302|      0|								"attribute.",
 4303|      0|								printSource(NULL, character->sourceFile,
 4304|      0|										character->sourceLine),
 4305|      0|								_lou_showString(&basechar->value, 1, 0),
 4306|      0|								attributeName != NULL ? attributeName : "?");
 4307|      0|						errorCount++;
 4308|      0|						free(attributeName);
 4309|      0|						return 0;
 4310|      0|					}
 4311|      0|				}
 4312|      0|				character->mode = mode;
 4313|      0|				character->basechar = basecharOffset;
 4314|      0|				// add mode to attributes
 4315|      0|				character->attributes |= character->mode;
 4316|      0|				if (character->attributes & (CTC_UpperCase | CTC_LowerCase))
 4317|      0|					character->attributes |= CTC_Letter;
 4318|      0|				// also set the new attributes on the associated dots of the base
 4319|      0|				// character
 4320|      0|				TranslationTableRule *defRule =
 4321|      0|						(TranslationTableRule *)&table
 4322|      0|								->ruleArea[basechar->definitionRule];
 4323|      0|				if (defRule->dotslen == 1) {
 4324|      0|					TranslationTableCharacter *dots =
 4325|      0|							getDots(defRule->charsdots[defRule->charslen], table);
 4326|      0|					if (dots) {
 4327|      0|						dots->attributes |= character->mode;
 4328|      0|						if (dots->attributes & (CTC_UpperCase | CTC_LowerCase))
 4329|      0|							dots->attributes |= CTC_Letter;
 4330|      0|					}
 4331|      0|				}
 4332|      0|				// store all characters that are based on a base character in list
 4333|      0|				if (basechar->linked) character->linked = basechar->linked;
 4334|      0|				basechar->linked = characterOffset;
 4335|      0|			}
 4336|      0|			characterOffset = character->next;
 4337|      0|		}
 4338|      0|	}
 4339|      0|	// add noletsign rules from single-letter word and largesign rules
 4340|      0|	for (int i = 0; i < HASHNUM; i++) {
 4341|      0|		TranslationTableOffset characterOffset = table->characters[i];
 4342|      0|		while (characterOffset) {
 4343|      0|			TranslationTableCharacter *character =
 4344|      0|					(TranslationTableCharacter *)&table->ruleArea[characterOffset];
 4345|      0|			if (character->attributes & CTC_Letter) {
 4346|      0|				TranslationTableOffset *otherRule = &character->otherRules;
 4347|      0|				while (*otherRule) {
 4348|      0|					TranslationTableRule *rule =
 4349|      0|							(TranslationTableRule *)&table->ruleArea[*otherRule];
 4350|      0|					if (rule->opcode == CTO_WholeWord || rule->opcode == CTO_LargeSign)
 4351|      0|						if (table->noLetsignCount < LETSIGNSIZE)
 4352|      0|							table->noLetsign[table->noLetsignCount++] =
 4353|      0|									rule->charsdots[0];
 4354|      0|					otherRule = &rule->charsnext;
 4355|      0|				}
 4356|      0|			}
 4357|      0|			characterOffset = character->next;
 4358|      0|		}
 4359|      0|	}
 4360|      0|	table->finalized = 1;
 4361|      0|	return 1;
 4362|      0|}
 4363|       |
 4364|       |static int
 4365|       |compileString(const char *inString, TranslationTableHeader **table,
 4366|      0|		DisplayTableHeader **displayTable) {
 4367|      0|	/* This function can be used to make changes to tables on the fly. */
 4368|      0|	int k;
 4369|      0|	FileInfo file;
 4370|      0|	if (inString == NULL) return 0;
 4371|      0|	memset(&file, 0, sizeof(file));
 4372|      0|	file.fileName = inString;
 4373|      0|	file.encoding = noEncoding;
 4374|      0|	file.lineNumber = 1;
 4375|      0|	file.status = 0;
 4376|      0|	file.linepos = 0;
 4377|      0|	for (k = 0; inString[k]; k++) file.line[k] = inString[k];
 4378|      0|	file.line[k] = 0;
 4379|      0|	file.linelen = k;
 4380|      0|	if (table && *table && (*table)->finalized) {
 4381|      0|		compileError(&file, "Table is finalized");
 4382|      0|		return 0;
 4383|      0|	}
 4384|      0|	return compileRule(&file, table, displayTable, NULL);
 4385|      0|}
 4386|       |
 4387|       |static int
 4388|      0|setDefaults(TranslationTableHeader *table) {
 4389|      0|	for (int i = 0; i < 3; i++)
 4390|      0|		if (!table->emphRules[i][lenPhraseOffset])
 4391|      0|			table->emphRules[i][lenPhraseOffset] = 4;
 4392|      0|	if (table->numPasses == 0) table->numPasses = 1;
 4393|      0|	return 1;
 4394|      0|}
 4395|       |
 4396|       |/* =============== *
 4397|       | * TABLE RESOLVING *
 4398|       | * =============== *
 4399|       | *
 4400|       | * A table resolver is a function that resolves a `tableList` path against a
 4401|       | * `base` path, and returns the resolved table(s) as a list of absolute file
 4402|       | * paths.
 4403|       | *
 4404|       | * The function must have the following signature:
 4405|       | *
 4406|       | *     char ** (const char * tableList, const char * base)
 4407|       | *
 4408|       | * In general, `tableList` is a path in the broad sense. The default
 4409|       | * implementation accepts only *file* paths. But another implementation could
 4410|       | * for instance handle URI's. `base` is always a file path however.
 4411|       | *
 4412|       | * The idea is to give other programs that use liblouis the ability to define
 4413|       | * their own table resolver (in C, Java, Python, etc.) when the default
 4414|       | * resolver is not satisfying. (see also lou_registerTableResolver)
 4415|       | *
 4416|       | */
 4417|       |
 4418|       |/**
 4419|       | * Resolve a single (sub)table.
 4420|       | *
 4421|       | * Tries to resolve `table` against `base` if base is an absolute path. If
 4422|       | * that fails, searches `searchPath`.
 4423|       | *
 4424|       | */
 4425|       |static char *
 4426|      0|resolveSubtable(const char *table, const char *base, const char *searchPath) {
 4427|      0|	char *tableFile;
 4428|      0|	static struct stat info;
 4429|      0|
 4430|      0|	if (table == NULL || table[0] == '\0') return NULL;
 4431|      0|	tableFile = (char *)malloc(MAXSTRING * sizeof(char) * 2);
 4432|      0|
 4433|      0|	//
 4434|      0|	// First try to resolve against base
 4435|      0|	//
 4436|      0|	if (base) {
 4437|      0|		int k;
 4438|      0|		strcpy(tableFile, base);
 4439|      0|		k = (int)strlen(tableFile);
 4440|      0|		while (k >= 0 && tableFile[k] != '/' && tableFile[k] != '\\') k--;
 4441|      0|		tableFile[++k] = '\0';
 4442|      0|		strcat(tableFile, table);
 4443|      0|		if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {
 4444|      0|			_lou_logMessage(LOU_LOG_DEBUG, "found table %s", tableFile);
 4445|      0|			return tableFile;
 4446|      0|		}
 4447|      0|	}
 4448|      0|
 4449|      0|	//
 4450|      0|	// It could be an absolute path, or a path relative to the current working
 4451|      0|	// directory
 4452|      0|	//
 4453|      0|	strcpy(tableFile, table);
 4454|      0|	if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {
 4455|      0|		_lou_logMessage(LOU_LOG_DEBUG, "found table %s", tableFile);
 4456|      0|		return tableFile;
 4457|      0|	}
 4458|      0|
 4459|      0|	//
 4460|      0|	// Then search `LOUIS_TABLEPATH`, `dataPath` and `programPath`
 4461|      0|	//
 4462|      0|	if (searchPath[0] != '\0') {
 4463|      0|		char *dir;
 4464|      0|		int last;
 4465|      0|		char *cp;
 4466|      0|		char *searchPath_copy = strdup(searchPath);
 4467|      0|		for (dir = searchPath_copy;; dir = cp + 1) {
 4468|      0|			for (cp = dir; *cp != '\0' && *cp != ','; cp++)
 4469|      0|				;
 4470|      0|			last = (*cp == '\0');
 4471|      0|			*cp = '\0';
 4472|      0|			if (dir == cp) dir = ".";
 4473|      0|			sprintf(tableFile, "%s%c%s", dir, DIR_SEP, table);
 4474|      0|			if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {
 4475|      0|				_lou_logMessage(LOU_LOG_DEBUG, "found table %s", tableFile);
 4476|      0|				free(searchPath_copy);
 4477|      0|				return tableFile;
 4478|      0|			}
 4479|      0|			if (last) break;
 4480|      0|			sprintf(tableFile, "%s%c%s%c%s%c%s", dir, DIR_SEP, "liblouis", DIR_SEP,
 4481|      0|					"tables", DIR_SEP, table);
 4482|      0|			if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {
 4483|      0|				_lou_logMessage(LOU_LOG_DEBUG, "found table %s", tableFile);
 4484|      0|				free(searchPath_copy);
 4485|      0|				return tableFile;
 4486|      0|			}
 4487|      0|			if (last) break;
 4488|      0|		}
 4489|      0|		free(searchPath_copy);
 4490|      0|	}
 4491|      0|	free(tableFile);
 4492|      0|	return NULL;
 4493|      0|}
 4494|       |
 4495|       |char *EXPORT_CALL
 4496|      0|_lou_getTablePath(void) {
 4497|      0|	char searchPath[MAXSTRING];
 4498|      0|	char *path;
 4499|      0|	char *cp;
 4500|      0|	int envset = 0;
 4501|      0|	cp = searchPath;
 4502|      0|	path = getenv("LOUIS_TABLEPATH");
 4503|      0|	if (path != NULL && path[0] != '\0') {
 4504|      0|		envset = 1;
 4505|      0|		cp += sprintf(cp, ",%s", path);
 4506|      0|	}
 4507|      0|	path = lou_getDataPath();
 4508|      0|	if (path != NULL && path[0] != '\0')
 4509|      0|		cp += sprintf(cp, ",%s%c%s%c%s", path, DIR_SEP, "liblouis", DIR_SEP, "tables");
 4510|      0|	if (!envset) {
 4511|       |#ifdef _WIN32
 4512|       |		path = lou_getProgramPath();
 4513|       |		if (path != NULL) {
 4514|       |			if (path[0] != '\0')
 4515|       |				cp += sprintf(cp, ",%s%s", path, "\\share\\liblouis\\tables");
 4516|       |			free(path);
 4517|       |		}
 4518|       |#else
 4519|       |		cp += sprintf(cp, ",%s", TABLESDIR);
 4520|      0|#endif
 4521|      0|	}
 4522|      0|	if (searchPath[0] != '\0')
 4523|      0|		return strdup(&searchPath[1]);
 4524|      0|	else
 4525|      0|		return strdup(".");
 4526|      0|}
 4527|       |
 4528|       |/**
 4529|       | * The default table resolver
 4530|       | *
 4531|       | * Tries to resolve tableList against base. The search path is set to
 4532|       | * `LOUIS_TABLEPATH`, `dataPath` and `programPath` (in that order).
 4533|       | *
 4534|       | * @param table A file path, may be absolute or relative. May be a list of
 4535|       | *              tables separated by comma's. In that case, the first table
 4536|       | *              is used as the base for the other subtables.
 4537|       | * @param base A file path or directory path, or NULL.
 4538|       | * @return The file paths of the resolved subtables, or NULL if the table
 4539|       | *         could not be resolved.
 4540|       | *
 4541|       | */
 4542|       |char **EXPORT_CALL
 4543|      0|_lou_defaultTableResolver(const char *tableList, const char *base) {
 4544|      0|	char *searchPath;
 4545|      0|	char **tableFiles;
 4546|      0|	char *subTable;
 4547|      0|	char *tableList_copy;
 4548|      0|	char *cp;
 4549|      0|	int last;
 4550|      0|	int k;
 4551|      0|
 4552|      0|	/* Set up search path */
 4553|      0|	searchPath = _lou_getTablePath();
 4554|      0|
 4555|      0|	/* Count number of subtables in table list */
 4556|      0|	k = 0;
 4557|      0|	for (cp = (char *)tableList; *cp != '\0'; cp++)
 4558|      0|		if (*cp == ',') k++;
 4559|      0|	tableFiles = (char **)calloc(k + 2, sizeof(char *));
 4560|      0|	if (!tableFiles) _lou_outOfMemory();
 4561|      0|
 4562|      0|	/* Resolve subtables */
 4563|      0|	k = 0;
 4564|      0|	tableList_copy = strdup(tableList);
 4565|      0|	for (subTable = tableList_copy;; subTable = cp + 1) {
 4566|      0|		for (cp = subTable; *cp != '\0' && *cp != ','; cp++)
 4567|      0|			;
 4568|      0|		last = (*cp == '\0');
 4569|      0|		*cp = '\0';
 4570|      0|		if (!(tableFiles[k++] = resolveSubtable(subTable, base, searchPath))) {
 4571|      0|			char *path;
 4572|      0|			_lou_logMessage(LOU_LOG_ERROR, "Cannot resolve table '%s'", subTable);
 4573|      0|			path = getenv("LOUIS_TABLEPATH");
 4574|      0|			if (path != NULL && path[0] != '\0')
 4575|      0|				_lou_logMessage(LOU_LOG_ERROR, "LOUIS_TABLEPATH=%s", path);
 4576|      0|			free(searchPath);
 4577|      0|			free(tableList_copy);
 4578|      0|			free_tablefiles(tableFiles);
 4579|      0|			return NULL;
 4580|      0|		}
 4581|      0|		if (k == 1) base = subTable;
 4582|      0|		if (last) break;
 4583|      0|	}
 4584|      0|	free(searchPath);
 4585|      0|	free(tableList_copy);
 4586|      0|	tableFiles[k] = NULL;
 4587|      0|	return tableFiles;
 4588|      0|}
 4589|       |
 4590|       |static char **(EXPORT_CALL *tableResolver)(
 4591|       |		const char *tableList, const char *base) = &_lou_defaultTableResolver;
 4592|       |
 4593|       |static char **
 4594|      0|copyStringArray(char **array) {
 4595|      0|	int len;
 4596|      0|	char **copy;
 4597|      0|	if (!array) return NULL;
 4598|      0|	len = 0;
 4599|      0|	while (array[len]) len++;
 4600|      0|	copy = malloc((len + 1) * sizeof(char *));
 4601|      0|	copy[len] = NULL;
 4602|      0|	while (len) {
 4603|      0|		len--;
 4604|      0|		copy[len] = strdup(array[len]);
 4605|      0|	}
 4606|      0|	return copy;
 4607|      0|}
 4608|       |
 4609|       |char **EXPORT_CALL
 4610|      0|_lou_resolveTable(const char *tableList, const char *base) {
 4611|      0|	char **tableFiles = (*tableResolver)(tableList, base);
 4612|      0|	char **result = copyStringArray(tableFiles);
 4613|      0|	if (tableResolver == &_lou_defaultTableResolver) free_tablefiles(tableFiles);
 4614|      0|	return result;
 4615|      0|}
 4616|       |
 4617|       |/**
 4618|       | * Register a new table resolver. Overrides the default resolver.
 4619|       | *
 4620|       | * @param resolver The new resolver as a function pointer.
 4621|       | *
 4622|       | */
 4623|       |void EXPORT_CALL
 4624|       |lou_registerTableResolver(
 4625|      0|		char **(EXPORT_CALL *resolver)(const char *tableList, const char *base)) {
 4626|      0|	tableResolver = resolver;
 4627|      0|}
 4628|       |
 4629|       |static int fileCount = 0;
 4630|       |
 4631|       |/**
 4632|       | * Compile a single file
 4633|       | *
 4634|       | */
 4635|       |static int
 4636|       |compileFile(const char *fileName, TranslationTableHeader **table,
 4637|      0|		DisplayTableHeader **displayTable) {
 4638|      0|	FileInfo file;
 4639|      0|	fileCount++;
 4640|      0|	file.fileName = fileName;
 4641|      0|	if (table) {
 4642|      0|		int i;
 4643|      0|		for (i = 0; (*table)->sourceFiles[i]; i++)
 4644|      0|			;
 4645|      0|		if (i >= MAX_SOURCE_FILES) {
 4646|      0|			_lou_logMessage(LOU_LOG_WARN, "Max number of source files (%i) reached",
 4647|      0|					MAX_SOURCE_FILES);
 4648|      0|			file.sourceFile = NULL;
 4649|      0|		} else {
 4650|      0|			file.sourceFile = (*table)->sourceFiles[i] = strdup(fileName);
 4651|      0|		}
 4652|      0|	}
 4653|      0|	file.encoding = noEncoding;
 4654|      0|	file.status = 0;
 4655|      0|	file.lineNumber = 0;
 4656|      0|	if ((file.in = fopen(file.fileName, "rb"))) {
 4657|      0|		// the scope of a macro is the current file (after the macro definition)
 4658|      0|		const MacroList *inscopeMacros = NULL;
 4659|      0|		while (_lou_getALine(&file))
 4660|      0|			if (!compileRule(&file, table, displayTable, &inscopeMacros)) {
 4661|      0|				if (!errorCount) compileError(&file, "Rule could not be compiled");
 4662|      0|				break;
 4663|      0|			}
 4664|      0|		fclose(file.in);
 4665|      0|		free_macro_list(inscopeMacros);
 4666|      0|	} else {
 4667|      0|		_lou_logMessage(LOU_LOG_ERROR, "Cannot open table '%s'", file.fileName);
 4668|      0|		errorCount++;
 4669|      0|	}
 4670|      0|	return !errorCount;
 4671|      0|}
 4672|       |
 4673|       |static void
 4674|      0|freeTranslationTable(TranslationTableHeader *t) {
 4675|      0|	for (int i = 0; i < MAX_EMPH_CLASSES && t->emphClassNames[i]; i++)
 4676|      0|		free(t->emphClassNames[i]);
 4677|      0|	for (int i = 0; t->sourceFiles[i]; i++) free(t->sourceFiles[i]);
 4678|      0|	if (t->characterClasses) deallocateCharacterClasses(t);
 4679|      0|	if (t->ruleNames) deallocateRuleNames(t);
 4680|      0|	free(t);
 4681|      0|}
 4682|       |
 4683|       |/**
 4684|       | * Free a char** array
 4685|       | */
 4686|       |static void
 4687|      0|free_tablefiles(char **tables) {
 4688|      0|	char **table;
 4689|      0|	if (!tables) return;
 4690|      0|	for (table = tables; *table; table++) free(*table);
 4691|      0|	free(tables);
 4692|      0|}
 4693|       |
 4694|       |/**
 4695|       | * Implement include opcode
 4696|       | *
 4697|       | */
 4698|       |static int
 4699|       |includeFile(const FileInfo *file, CharsString *includedFile,
 4700|      0|		TranslationTableHeader **table, DisplayTableHeader **displayTable) {
 4701|      0|	int k;
 4702|      0|	char includeThis[MAXSTRING];
 4703|      0|	char **tableFiles;
 4704|      0|	int rv;
 4705|      0|	for (k = 0; k < includedFile->length; k++)
 4706|      0|		includeThis[k] = (char)includedFile->chars[k];
 4707|      0|	if (k >= MAXSTRING) {
 4708|      0|		compileError(file, "Include statement too long: 'include %s'", includeThis);
 4709|      0|		return 0;
 4710|      0|	}
 4711|      0|	includeThis[k] = 0;
 4712|      0|	tableFiles = _lou_resolveTable(includeThis, file->fileName);
 4713|      0|	if (tableFiles == NULL) {
 4714|      0|		errorCount++;
 4715|      0|		return 0;
 4716|      0|	}
 4717|      0|	if (tableFiles[1] != NULL) {
 4718|      0|		free_tablefiles(tableFiles);
 4719|      0|		compileError(file, "Table list not supported in include statement: 'include %s'",
 4720|      0|				includeThis);
 4721|      0|		return 0;
 4722|      0|	}
 4723|      0|	rv = compileFile(*tableFiles, table, displayTable);
 4724|      0|	free_tablefiles(tableFiles);
 4725|      0|	if (!rv)
 4726|      0|		_lou_logMessage(LOU_LOG_ERROR, "%s:%d: Error in included file", file->fileName,
 4727|      0|				file->lineNumber);
 4728|      0|	return rv;
 4729|      0|}
 4730|       |
 4731|       |/**
 4732|       | * Compile source tables into a table in memory
 4733|       | *
 4734|       | */
 4735|       |static int
 4736|       |compileTable(const char *tableList, const char *displayTableList,
 4737|      0|		TranslationTableHeader **translationTable, DisplayTableHeader **displayTable) {
 4738|      0|	char **tableFiles;
 4739|      0|	char **subTable;
 4740|      0|	if (translationTable && !tableList) return 0;
 4741|      0|	if (displayTable && !displayTableList) return 0;
 4742|      0|	if (!translationTable && !displayTable) return 0;
 4743|      0|	if (translationTable) *translationTable = NULL;
 4744|      0|	if (displayTable) *displayTable = NULL;
 4745|      0|	errorCount = warningCount = fileCount = 0;
 4746|      0|	if (!opcodeLengths[0]) {
 4747|      0|		TranslationTableOpcode opcode;
 4748|      0|		for (opcode = 0; opcode < CTO_None; opcode++)
 4749|      0|			opcodeLengths[opcode] = (short)strlen(opcodeNames[opcode]);
 4750|      0|	}
 4751|      0|	if (translationTable) allocateTranslationTable(NULL, translationTable);
 4752|      0|	if (displayTable) allocateDisplayTable(NULL, displayTable);
 4753|      0|
 4754|      0|	if (translationTable) {
 4755|      0|		(*translationTable)->emphClassNames[0] = NULL;
 4756|      0|		(*translationTable)->characterClasses = NULL;
 4757|      0|		(*translationTable)->ruleNames = NULL;
 4758|      0|	}
 4759|      0|
 4760|      0|	/* Compile things that are necesary for the proper operation of
 4761|      0|	 * liblouis or liblouisxml or liblouisutdml */
 4762|      0|	/* TODO: These definitions seem to be necessary for proper functioning of
 4763|      0|	   liblouisutdml. Find a way to satisfy those requirements without hard coding
 4764|      0|	   some characters in every table notably behind the users back */
 4765|      0|	compileString("space \\xffff 123456789abcdef LOU_ENDSEGMENT", translationTable,
 4766|      0|			displayTable);
 4767|      0|
 4768|      0|	if (displayTable && translationTable && strcmp(tableList, displayTableList) == 0) {
 4769|      0|		/* Compile the display and translation tables in one go */
 4770|      0|
 4771|      0|		/* Compile all subtables in the list */
 4772|      0|		if (!(tableFiles = _lou_resolveTable(tableList, NULL))) {
 4773|      0|			errorCount++;
 4774|      0|			goto cleanup;
 4775|      0|		}
 4776|      0|		for (subTable = tableFiles; *subTable; subTable++)
 4777|      0|			if (!compileFile(*subTable, translationTable, displayTable)) goto cleanup;
 4778|      0|	} else {
 4779|      0|		/* Compile the display and translation tables separately */
 4780|      0|
 4781|      0|		if (displayTable) {
 4782|      0|			if (!(tableFiles = _lou_resolveTable(displayTableList, NULL))) {
 4783|      0|				errorCount++;
 4784|      0|				goto cleanup;
 4785|      0|			}
 4786|      0|			for (subTable = tableFiles; *subTable; subTable++)
 4787|      0|				if (!compileFile(*subTable, NULL, displayTable)) goto cleanup;
 4788|      0|			free_tablefiles(tableFiles);
 4789|      0|			tableFiles = NULL;
 4790|      0|		}
 4791|      0|		if (translationTable) {
 4792|      0|			if (!(tableFiles = _lou_resolveTable(tableList, NULL))) {
 4793|      0|				errorCount++;
 4794|      0|				goto cleanup;
 4795|      0|			}
 4796|      0|			for (subTable = tableFiles; *subTable; subTable++)
 4797|      0|				if (!compileFile(*subTable, translationTable, NULL)) goto cleanup;
 4798|      0|		}
 4799|      0|	}
 4800|      0|
 4801|      0|/* Clean up after compiling files */
 4802|      0|cleanup:
 4803|      0|	free_tablefiles(tableFiles);
 4804|      0|	if (warningCount) _lou_logMessage(LOU_LOG_WARN, "%d warnings issued", warningCount);
 4805|      0|	if (!errorCount) {
 4806|      0|		if (translationTable) setDefaults(*translationTable);
 4807|      0|		return 1;
 4808|      0|	} else {
 4809|      0|		_lou_logMessage(LOU_LOG_ERROR, "%d errors found.", errorCount);
 4810|      0|		if (translationTable) {
 4811|      0|			if (*translationTable) freeTranslationTable(*translationTable);
 4812|      0|			*translationTable = NULL;
 4813|      0|		}
 4814|      0|		if (displayTable) {
 4815|      0|			if (*displayTable) free(*displayTable);
 4816|      0|			*displayTable = NULL;
 4817|      0|		}
 4818|      0|		return 0;
 4819|      0|	}
 4820|      0|}
 4821|       |
 4822|       |/* Return the emphasis classes declared in tableList. */
 4823|       |char const **EXPORT_CALL
 4824|      0|lou_getEmphClasses(const char *tableList) {
 4825|      0|	const char *names[MAX_EMPH_CLASSES + 1];
 4826|      0|	unsigned int count = 0;
 4827|      0|	const TranslationTableHeader *table = _lou_getTranslationTable(tableList);
 4828|      0|	if (!table) return NULL;
 4829|      0|
 4830|      0|	while (count < MAX_EMPH_CLASSES) {
 4831|      0|		char const *name = table->emphClassNames[count];
 4832|      0|		if (!name) break;
 4833|      0|		names[count++] = name;
 4834|      0|	}
 4835|      0|	names[count++] = NULL;
 4836|      0|
 4837|      0|	{
 4838|      0|		unsigned int size = count * sizeof(names[0]);
 4839|      0|		char const **result = malloc(size);
 4840|      0|		if (!result) return NULL;
 4841|      0|		/* The void* cast is necessary to stop MSVC from warning about
 4842|      0|		 * different 'const' qualifiers (C4090). */
 4843|      0|		memcpy((void *)result, names, size);
 4844|      0|		return result;
 4845|      0|	}
 4846|      0|}
 4847|       |
 4848|       |void
 4849|       |getTable(const char *tableList, const char *displayTableList,
 4850|       |		TranslationTableHeader **translationTable, DisplayTableHeader **displayTable);
 4851|       |
 4852|       |void EXPORT_CALL
 4853|       |_lou_getTable(const char *tableList, const char *displayTableList,
 4854|       |		const TranslationTableHeader **translationTable,
 4855|      0|		const DisplayTableHeader **displayTable) {
 4856|      0|	TranslationTableHeader *newTable;
 4857|      0|	DisplayTableHeader *newDisplayTable;
 4858|      0|	getTable(tableList, displayTableList, &newTable, &newDisplayTable);
 4859|      0|	if (newTable)
 4860|      0|		if (!finalizeTable(newTable)) newTable = NULL;
 4861|      0|	*translationTable = newTable;
 4862|      0|	*displayTable = newDisplayTable;
 4863|      0|}
 4864|       |
 4865|       |/* Checks and loads tableList. */
 4866|       |const void *EXPORT_CALL
 4867|      0|lou_getTable(const char *tableList) {
 4868|      0|	const TranslationTableHeader *table;
 4869|      0|	const DisplayTableHeader *displayTable;
 4870|      0|	_lou_getTable(tableList, tableList, &table, &displayTable);
 4871|      0|	if (!table || !displayTable) return NULL;
 4872|      0|	return table;
 4873|      0|}
 4874|       |
 4875|       |const TranslationTableHeader *EXPORT_CALL
 4876|      0|_lou_getTranslationTable(const char *tableList) {
 4877|      0|	TranslationTableHeader *table;
 4878|      0|	getTable(tableList, NULL, &table, NULL);
 4879|      0|	if (table)
 4880|      0|		if (!finalizeTable(table)) table = NULL;
 4881|      0|	return table;
 4882|      0|}
 4883|       |
 4884|       |const DisplayTableHeader *EXPORT_CALL
 4885|      0|_lou_getDisplayTable(const char *tableList) {
 4886|      0|	DisplayTableHeader *table;
 4887|      0|	getTable(NULL, tableList, NULL, &table);
 4888|      0|	return table;
 4889|      0|}
 4890|       |
 4891|       |void
 4892|       |getTable(const char *translationTableList, const char *displayTableList,
 4893|      0|		TranslationTableHeader **translationTable, DisplayTableHeader **displayTable) {
 4894|      0|	/* Keep track of which tables have already been compiled */
 4895|      0|	int translationTableListLen, displayTableListLen = 0;
 4896|      0|	if (translationTableList == NULL || *translationTableList == 0)
 4897|      0|		translationTable = NULL;
 4898|      0|	if (displayTableList == NULL || *displayTableList == 0) displayTable = NULL;
 4899|      0|	/* See if translation table has already been compiled */
 4900|      0|	if (translationTable) {
 4901|      0|		translationTableListLen = (int)strlen(translationTableList);
 4902|      0|		*translationTable = NULL;
 4903|      0|		TranslationTableChainEntry *currentEntry = translationTableChain;
 4904|      0|		TranslationTableChainEntry *prevEntry = NULL;
 4905|      0|		while (currentEntry != NULL) {
 4906|      0|			if (translationTableListLen == currentEntry->tableListLength &&
 4907|      0|					(memcmp(&currentEntry->tableList[0], translationTableList,
 4908|      0|							translationTableListLen)) == 0) {
 4909|      0|				/* Move the table to the top of the table chain. */
 4910|      0|				if (prevEntry != NULL) {
 4911|      0|					prevEntry->next = currentEntry->next;
 4912|      0|					currentEntry->next = translationTableChain;
 4913|      0|					translationTableChain = currentEntry;
 4914|      0|				}
 4915|      0|				*translationTable = currentEntry->table;
 4916|      0|				break;
 4917|      0|			}
 4918|      0|			prevEntry = currentEntry;
 4919|      0|			currentEntry = currentEntry->next;
 4920|      0|		}
 4921|      0|	}
 4922|      0|	/* See if display table has already been compiled */
 4923|      0|	if (displayTable) {
 4924|      0|		displayTableListLen = (int)strlen(displayTableList);
 4925|      0|		*displayTable = NULL;
 4926|      0|		DisplayTableChainEntry *currentEntry = displayTableChain;
 4927|      0|		DisplayTableChainEntry *prevEntry = NULL;
 4928|      0|		while (currentEntry != NULL) {
 4929|      0|			if (displayTableListLen == currentEntry->tableListLength &&
 4930|      0|					(memcmp(&currentEntry->tableList[0], displayTableList,
 4931|      0|							displayTableListLen)) == 0) {
 4932|      0|				/* Move the table to the top of the table chain. */
 4933|      0|				if (prevEntry != NULL) {
 4934|      0|					prevEntry->next = currentEntry->next;
 4935|      0|					currentEntry->next = displayTableChain;
 4936|      0|					displayTableChain = currentEntry;
 4937|      0|				}
 4938|      0|				*displayTable = currentEntry->table;
 4939|      0|				break;
 4940|      0|			}
 4941|      0|			prevEntry = currentEntry;
 4942|      0|			currentEntry = currentEntry->next;
 4943|      0|		}
 4944|      0|	}
 4945|      0|	if ((translationTable && *translationTable == NULL) ||
 4946|      0|			(displayTable && *displayTable == NULL)) {
 4947|      0|		TranslationTableHeader *newTranslationTable = NULL;
 4948|      0|		DisplayTableHeader *newDisplayTable = NULL;
 4949|      0|		if (compileTable(translationTableList, displayTableList,
 4950|      0|					(translationTable && *translationTable == NULL) ? &newTranslationTable
 4951|      0|																	: NULL,
 4952|      0|					(displayTable && *displayTable == NULL) ? &newDisplayTable : NULL)) {
 4953|      0|			/* Add a new entry to the top of the table chain. */
 4954|      0|			if (newTranslationTable != NULL) {
 4955|      0|				int entrySize =
 4956|      0|						sizeof(TranslationTableChainEntry) + translationTableListLen;
 4957|      0|				TranslationTableChainEntry *newEntry = malloc(entrySize);
 4958|      0|				if (!newEntry) _lou_outOfMemory();
 4959|      0|				newEntry->next = translationTableChain;
 4960|      0|				newEntry->table = newTranslationTable;
 4961|      0|				newEntry->tableListLength = translationTableListLen;
 4962|      0|				memcpy(&newEntry->tableList[0], translationTableList,
 4963|      0|						translationTableListLen);
 4964|      0|				translationTableChain = newEntry;
 4965|      0|				*translationTable = newTranslationTable;
 4966|      0|			}
 4967|      0|			if (newDisplayTable != NULL) {
 4968|      0|				int entrySize = sizeof(DisplayTableChainEntry) + displayTableListLen;
 4969|      0|				DisplayTableChainEntry *newEntry = malloc(entrySize);
 4970|      0|				if (!newEntry) _lou_outOfMemory();
 4971|      0|				newEntry->next = displayTableChain;
 4972|      0|				newEntry->table = newDisplayTable;
 4973|      0|				newEntry->tableListLength = displayTableListLen;
 4974|      0|				memcpy(&newEntry->tableList[0], displayTableList, displayTableListLen);
 4975|      0|				displayTableChain = newEntry;
 4976|      0|				*displayTable = newDisplayTable;
 4977|      0|			}
 4978|      0|		} else {
 4979|      0|			_lou_logMessage(
 4980|      0|					LOU_LOG_ERROR, "%s could not be compiled", translationTableList);
 4981|      0|			return;
 4982|      0|		}
 4983|      0|	}
 4984|      0|}
 4985|       |
 4986|       |int EXPORT_CALL
 4987|      0|lou_checkTable(const char *tableList) {
 4988|      0|	if (lou_getTable(tableList)) return 1;
 4989|      0|	return 0;
 4990|      0|}
 4991|       |
 4992|       |formtype EXPORT_CALL
 4993|      0|lou_getTypeformForEmphClass(const char *tableList, const char *emphClass) {
 4994|      0|	const TranslationTableHeader *table = _lou_getTranslationTable(tableList);
 4995|      0|	if (!table) return 0;
 4996|      0|	for (int i = 0; i < MAX_EMPH_CLASSES && table->emphClassNames[i]; i++)
 4997|      0|		if (strcmp(emphClass, table->emphClassNames[i]) == 0) return italic << i;
 4998|      0|	return 0;
 4999|      0|}
 5000|       |
 5001|       |static unsigned char *destSpacing = NULL;
 5002|       |static int sizeDestSpacing = 0;
 5003|       |static formtype *typebuf = NULL;
 5004|       |static unsigned int *wordBuffer = NULL;
 5005|       |static EmphasisInfo *emphasisBuffer = NULL;
 5006|       |static int sizeTypebuf = 0;
 5007|       |static widechar *passbuf[MAXPASSBUF] = { NULL };
 5008|       |static int sizePassbuf[MAXPASSBUF] = { 0 };
 5009|       |static int *posMapping1 = NULL;
 5010|       |static int sizePosMapping1 = 0;
 5011|       |static int *posMapping2 = NULL;
 5012|       |static int sizePosMapping2 = 0;
 5013|       |static int *posMapping3 = NULL;
 5014|       |static int sizePosMapping3 = 0;
 5015|       |void *EXPORT_CALL
 5016|      0|_lou_allocMem(AllocBuf buffer, int index, int srcmax, int destmax) {
 5017|      0|	if (srcmax < 1024) srcmax = 1024;
 5018|      0|	if (destmax < 1024) destmax = 1024;
 5019|      0|	switch (buffer) {
 5020|      0|	case alloc_typebuf:
 5021|      0|		if (destmax > sizeTypebuf) {
 5022|      0|			if (typebuf != NULL) free(typebuf);
 5023|      0|			// TODO: should this be srcmax?
 5024|      0|			typebuf = malloc((destmax + 4) * sizeof(formtype));
 5025|      0|			if (!typebuf) _lou_outOfMemory();
 5026|      0|			sizeTypebuf = destmax;
 5027|      0|		}
 5028|      0|		return typebuf;
 5029|      0|
 5030|      0|	case alloc_wordBuffer:
 5031|      0|
 5032|      0|		if (wordBuffer != NULL) free(wordBuffer);
 5033|      0|		wordBuffer = calloc(srcmax + 4, sizeof(unsigned int));
 5034|      0|		if (wordBuffer == NULL) _lou_outOfMemory();
 5035|      0|		return wordBuffer;
 5036|      0|
 5037|      0|	case alloc_emphasisBuffer:
 5038|      0|
 5039|      0|		if (emphasisBuffer != NULL) free(emphasisBuffer);
 5040|      0|		emphasisBuffer = calloc(srcmax + 4, sizeof(EmphasisInfo));
 5041|      0|		if (emphasisBuffer == NULL) _lou_outOfMemory();
 5042|      0|		return emphasisBuffer;
 5043|      0|
 5044|      0|	case alloc_destSpacing:
 5045|      0|		if (destmax > sizeDestSpacing) {
 5046|      0|			if (destSpacing != NULL) free(destSpacing);
 5047|      0|			destSpacing = malloc(destmax + 4);
 5048|      0|			if (!destSpacing) _lou_outOfMemory();
 5049|      0|			sizeDestSpacing = destmax;
 5050|      0|		}
 5051|      0|		return destSpacing;
 5052|      0|	case alloc_passbuf:
 5053|      0|		if (index < 0 || index >= MAXPASSBUF) {
 5054|      0|			_lou_logMessage(LOU_LOG_FATAL, "Index out of bounds: %d\n", index);
 5055|      0|			exit(3);
 5056|      0|		}
 5057|      0|		if (destmax > sizePassbuf[index]) {
 5058|      0|			if (passbuf[index] != NULL) free(passbuf[index]);
 5059|      0|			passbuf[index] = malloc((destmax + 4) * CHARSIZE);
 5060|      0|			if (!passbuf[index]) _lou_outOfMemory();
 5061|      0|			sizePassbuf[index] = destmax;
 5062|      0|		}
 5063|      0|		return passbuf[index];
 5064|      0|	case alloc_posMapping1: {
 5065|      0|		int mapSize;
 5066|      0|		if (srcmax >= destmax)
 5067|      0|			mapSize = srcmax;
 5068|      0|		else
 5069|      0|			mapSize = destmax;
 5070|      0|		if (mapSize > sizePosMapping1) {
 5071|      0|			if (posMapping1 != NULL) free(posMapping1);
 5072|      0|			posMapping1 = malloc((mapSize + 4) * sizeof(int));
 5073|      0|			if (!posMapping1) _lou_outOfMemory();
 5074|      0|			sizePosMapping1 = mapSize;
 5075|      0|		}
 5076|      0|	}
 5077|      0|		return posMapping1;
 5078|      0|	case alloc_posMapping2: {
 5079|      0|		int mapSize;
 5080|      0|		if (srcmax >= destmax)
 5081|      0|			mapSize = srcmax;
 5082|      0|		else
 5083|      0|			mapSize = destmax;
 5084|      0|		if (mapSize > sizePosMapping2) {
 5085|      0|			if (posMapping2 != NULL) free(posMapping2);
 5086|      0|			posMapping2 = malloc((mapSize + 4) * sizeof(int));
 5087|      0|			if (!posMapping2) _lou_outOfMemory();
 5088|      0|			sizePosMapping2 = mapSize;
 5089|      0|		}
 5090|      0|	}
 5091|      0|		return posMapping2;
 5092|      0|	case alloc_posMapping3: {
 5093|      0|		int mapSize;
 5094|      0|		if (srcmax >= destmax)
 5095|      0|			mapSize = srcmax;
 5096|      0|		else
 5097|      0|			mapSize = destmax;
 5098|      0|		if (mapSize > sizePosMapping3) {
 5099|      0|			if (posMapping3 != NULL) free(posMapping3);
 5100|      0|			posMapping3 = malloc((mapSize + 4) * sizeof(int));
 5101|      0|			if (!posMapping3) _lou_outOfMemory();
 5102|      0|			sizePosMapping3 = mapSize;
 5103|      0|		}
 5104|      0|	}
 5105|      0|		return posMapping3;
 5106|      0|	default:
 5107|      0|		return NULL;
 5108|      0|	}
 5109|      0|}
 5110|       |
 5111|       |void EXPORT_CALL
 5112|      0|lou_free(void) {
 5113|      0|	TranslationTableChainEntry *currentEntry;
 5114|      0|	TranslationTableChainEntry *previousEntry;
 5115|      0|	lou_logEnd();
 5116|      0|	if (translationTableChain != NULL) {
 5117|      0|		currentEntry = translationTableChain;
 5118|      0|		while (currentEntry) {
 5119|      0|			freeTranslationTable(currentEntry->table);
 5120|      0|			previousEntry = currentEntry;
 5121|      0|			currentEntry = currentEntry->next;
 5122|      0|			free(previousEntry);
 5123|      0|		}
 5124|      0|		translationTableChain = NULL;
 5125|      0|	}
 5126|      0|	if (typebuf != NULL) free(typebuf);
 5127|      0|	typebuf = NULL;
 5128|      0|	if (wordBuffer != NULL) free(wordBuffer);
 5129|      0|	wordBuffer = NULL;
 5130|      0|	if (emphasisBuffer != NULL) free(emphasisBuffer);
 5131|      0|	emphasisBuffer = NULL;
 5132|      0|	sizeTypebuf = 0;
 5133|      0|	if (destSpacing != NULL) free(destSpacing);
 5134|      0|	destSpacing = NULL;
 5135|      0|	sizeDestSpacing = 0;
 5136|      0|	{
 5137|      0|		int k;
 5138|      0|		for (k = 0; k < MAXPASSBUF; k++) {
 5139|      0|			if (passbuf[k] != NULL) free(passbuf[k]);
 5140|      0|			passbuf[k] = NULL;
 5141|      0|			sizePassbuf[k] = 0;
 5142|      0|		}
 5143|      0|	}
 5144|      0|	if (posMapping1 != NULL) free(posMapping1);
 5145|      0|	posMapping1 = NULL;
 5146|      0|	sizePosMapping1 = 0;
 5147|      0|	if (posMapping2 != NULL) free(posMapping2);
 5148|      0|	posMapping2 = NULL;
 5149|      0|	sizePosMapping2 = 0;
 5150|      0|	if (posMapping3 != NULL) free(posMapping3);
 5151|      0|	posMapping3 = NULL;
 5152|      0|	sizePosMapping3 = 0;
 5153|      0|	opcodeLengths[0] = 0;
 5154|      0|}
 5155|       |
 5156|       |const char *EXPORT_CALL
 5157|      0|lou_version(void) {
 5158|      0|	static const char *version = PACKAGE_VERSION;
 5159|      0|	return version;
 5160|      0|}
 5161|       |
 5162|       |int EXPORT_CALL
 5163|      0|lou_charSize(void) {
 5164|      0|	return CHARSIZE;
 5165|      0|}
 5166|       |
 5167|       |int EXPORT_CALL
 5168|      0|lou_compileString(const char *tableList, const char *inString) {
 5169|      0|	TranslationTableHeader *table;
 5170|      0|	DisplayTableHeader *displayTable;
 5171|      0|	getTable(tableList, tableList, &table, &displayTable);
 5172|      0|	if (!table) return 0;
 5173|      0|	if (!compileString(inString, &table, &displayTable)) return 0;
 5174|      0|	return 1;
 5175|      0|}
 5176|       |
 5177|       |int EXPORT_CALL
 5178|      0|_lou_compileTranslationRule(const char *tableList, const char *inString) {
 5179|      0|	TranslationTableHeader *table;
 5180|      0|	getTable(tableList, NULL, &table, NULL);
 5181|      0|	return compileString(inString, &table, NULL);
 5182|      0|}
 5183|       |
 5184|       |int EXPORT_CALL
 5185|      0|_lou_compileDisplayRule(const char *tableList, const char *inString) {
 5186|      0|	DisplayTableHeader *table;
 5187|      0|	getTable(NULL, tableList, NULL, &table);
 5188|      0|	return compileString(inString, NULL, &table);
 5189|      0|}
 5190|       |
 5191|       |/**
 5192|       | * This procedure provides a target for cals that serve as breakpoints
 5193|       | * for gdb.
 5194|       | */
 5195|       |// char *EXPORT_CALL
 5196|       |// lou_getTablePaths (void)
 5197|       |// {
 5198|       |//   static char paths[MAXSTRING];
 5199|       |//   static char scratchBuf[MAXSTRING];
 5200|       |//   char *pathList;
 5201|       |//   strcpy (paths, tablePath);
 5202|       |//   strcat (paths, ",");
 5203|       |//   pathList = getenv ("LOUIS_TABLEPATH");
 5204|       |//   if (pathList)
 5205|       |//     {
 5206|       |//       strcat (paths, pathList);
 5207|       |//       strcat (paths, ",");
 5208|       |//     }
 5209|       |//   pathList = getcwd (scratchBuf, MAXSTRING);
 5210|       |//   if (pathList)
 5211|       |//     {
 5212|       |//       strcat (paths, pathList);
 5213|       |//       strcat (paths, ",");
 5214|       |//     }
 5215|       |//   pathList = lou_getDataPath ();
 5216|       |//   if (pathList)
 5217|       |//     {
 5218|       |//       strcat (paths, pathList);
 5219|       |//       strcat (paths, ",");
 5220|       |//     }
 5221|       |// #ifdef _WIN32
 5222|       |//   strcpy (paths, lou_getProgramPath ());
 5223|       |//   strcat (paths, "\\share\\liblouss\\tables\\");
 5224|       |// #else
 5225|       |//   strcpy (paths, TABLESDIR);
 5226|       |// #endif
 5227|       |//   return paths;
 5228|       |// }

/home/vito/MASTER_CSI/S2/TER/fuzzing/liblouis/liblouis/config.h:
    1|       |/* liblouis/config.h.  Generated from config.h.in by configure.  */
    2|       |/* liblouis/config.h.in.  Generated from configure.ac by autoheader.  */
    3|       |
    4|       |
    5|       |#ifndef LOUISCFG_H
    6|       |#define LOUISCFG_H
    7|       |
    8|       |
    9|       |/* Define to the number of bits in type 'ptrdiff_t'. */
   10|       |/* #undef BITSIZEOF_PTRDIFF_T */
   11|       |
   12|       |/* Define to the number of bits in type 'sig_atomic_t'. */
   13|       |/* #undef BITSIZEOF_SIG_ATOMIC_T */
   14|       |
   15|       |/* Define to the number of bits in type 'size_t'. */
   16|       |/* #undef BITSIZEOF_SIZE_T */
   17|       |
   18|       |/* Define to the number of bits in type 'wchar_t'. */
   19|       |/* #undef BITSIZEOF_WCHAR_T */
   20|       |
   21|       |/* Define to the number of bits in type 'wint_t'. */
   22|       |/* #undef BITSIZEOF_WINT_T */
   23|       |
   24|       |/* Define to 1 if using 'alloca.c'. */
   25|       |/* #undef C_ALLOCA */
   26|       |
   27|       |/* Define to 1 if // is a file system root distinct from /. */
   28|       |/* #undef DOUBLE_SLASH_IS_DISTINCT_ROOT */
   29|       |
   30|       |/* Enable macros */
   31|       |/* #undef ENABLE_MACROS */
   32|       |
   33|       |/* Define this to 1 if F_DUPFD behavior does not match POSIX */
   34|       |/* #undef FCNTL_DUPFD_BUGGY */
   35|       |
   36|       |/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
   37|       |   whether the gnulib module fscanf shall be considered present. */
   38|       |#define GNULIB_FSCANF 1
   39|       |
   40|       |/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
   41|       |   whether the gnulib module msvc-nothrow shall be considered present. */
   42|       |#define GNULIB_MSVC_NOTHROW 1
   43|       |
   44|       |/* Define to 1 if printf and friends should be labeled with attribute
   45|       |   "__gnu_printf__" instead of "__printf__" */
   46|       |/* #undef GNULIB_PRINTF_ATTRIBUTE_FLAVOR_GNU */
   47|       |
   48|       |/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
   49|       |   whether the gnulib module scanf shall be considered present. */
   50|       |#define GNULIB_SCANF 1
   51|       |
   52|       |/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
   53|       |   whether the gnulib module strerror shall be considered present. */
   54|       |#define GNULIB_STRERROR 1
   55|       |
   56|       |/* Define to 1 when the gnulib module cloexec should be tested. */
   57|       |#define GNULIB_TEST_CLOEXEC 1
   58|       |
   59|       |/* Define to 1 when the gnulib module close should be tested. */
   60|       |#define GNULIB_TEST_CLOSE 1
   61|       |
   62|       |/* Define to 1 when the gnulib module dup2 should be tested. */
   63|       |#define GNULIB_TEST_DUP2 1
   64|       |
   65|       |/* Define to 1 when the gnulib module environ should be tested. */
   66|       |#define GNULIB_TEST_ENVIRON 1
   67|       |
   68|       |/* Define to 1 when the gnulib module fcntl should be tested. */
   69|       |#define GNULIB_TEST_FCNTL 1
   70|       |
   71|       |/* Define to 1 when the gnulib module fgetc should be tested. */
   72|       |#define GNULIB_TEST_FGETC 1
   73|       |
   74|       |/* Define to 1 when the gnulib module fgets should be tested. */
   75|       |#define GNULIB_TEST_FGETS 1
   76|       |
   77|       |/* Define to 1 when the gnulib module fprintf should be tested. */
   78|       |#define GNULIB_TEST_FPRINTF 1
   79|       |
   80|       |/* Define to 1 when the gnulib module fputc should be tested. */
   81|       |#define GNULIB_TEST_FPUTC 1
   82|       |
   83|       |/* Define to 1 when the gnulib module fputs should be tested. */
   84|       |#define GNULIB_TEST_FPUTS 1
   85|       |
   86|       |/* Define to 1 when the gnulib module fread should be tested. */
   87|       |#define GNULIB_TEST_FREAD 1
   88|       |
   89|       |/* Define to 1 when the gnulib module free-posix should be tested. */
   90|       |#define GNULIB_TEST_FREE_POSIX 1
   91|       |
   92|       |/* Define to 1 when the gnulib module fscanf should be tested. */
   93|       |#define GNULIB_TEST_FSCANF 1
   94|       |
   95|       |/* Define to 1 when the gnulib module fstat should be tested. */
   96|       |#define GNULIB_TEST_FSTAT 1
   97|       |
   98|       |/* Define to 1 when the gnulib module fwrite should be tested. */
   99|       |#define GNULIB_TEST_FWRITE 1
  100|       |
  101|       |/* Define to 1 when the gnulib module getc should be tested. */
  102|       |#define GNULIB_TEST_GETC 1
  103|       |
  104|       |/* Define to 1 when the gnulib module getchar should be tested. */
  105|       |#define GNULIB_TEST_GETCHAR 1
  106|       |
  107|       |/* Define to 1 when the gnulib module getdtablesize should be tested. */
  108|       |#define GNULIB_TEST_GETDTABLESIZE 1
  109|       |
  110|       |/* Define to 1 when the gnulib module getopt-posix should be tested. */
  111|       |#define GNULIB_TEST_GETOPT_POSIX 1
  112|       |
  113|       |/* Define to 1 when the gnulib module malloc-gnu should be tested. */
  114|       |#define GNULIB_TEST_MALLOC_GNU 1
  115|       |
  116|       |/* Define to 1 when the gnulib module malloc-posix should be tested. */
  117|       |#define GNULIB_TEST_MALLOC_POSIX 1
  118|       |
  119|       |/* Define to 1 when the gnulib module open should be tested. */
  120|       |#define GNULIB_TEST_OPEN 1
  121|       |
  122|       |/* Define to 1 when the gnulib module printf should be tested. */
  123|       |#define GNULIB_TEST_PRINTF 1
  124|       |
  125|       |/* Define to 1 when the gnulib module putc should be tested. */
  126|       |#define GNULIB_TEST_PUTC 1
  127|       |
  128|       |/* Define to 1 when the gnulib module putchar should be tested. */
  129|       |#define GNULIB_TEST_PUTCHAR 1
  130|       |
  131|       |/* Define to 1 when the gnulib module puts should be tested. */
  132|       |#define GNULIB_TEST_PUTS 1
  133|       |
  134|       |/* Define to 1 when the gnulib module realloc-gnu should be tested. */
  135|       |#define GNULIB_TEST_REALLOC_GNU 1
  136|       |
  137|       |/* Define to 1 when the gnulib module realloc-posix should be tested. */
  138|       |#define GNULIB_TEST_REALLOC_POSIX 1
  139|       |
  140|       |/* Define to 1 when the gnulib module scanf should be tested. */
  141|       |#define GNULIB_TEST_SCANF 1
  142|       |
  143|       |/* Define to 1 when the gnulib module setenv should be tested. */
  144|       |#define GNULIB_TEST_SETENV 1
  145|       |
  146|       |/* Define to 1 when the gnulib module stat should be tested. */
  147|       |#define GNULIB_TEST_STAT 1
  148|       |
  149|       |/* Define to 1 when the gnulib module strerror should be tested. */
  150|       |#define GNULIB_TEST_STRERROR 1
  151|       |
  152|       |/* Define to 1 when the gnulib module strndup should be tested. */
  153|       |#define GNULIB_TEST_STRNDUP 1
  154|       |
  155|       |/* Define to 1 when the gnulib module strnlen should be tested. */
  156|       |#define GNULIB_TEST_STRNLEN 1
  157|       |
  158|       |/* Define to 1 when the gnulib module vfprintf should be tested. */
  159|       |#define GNULIB_TEST_VFPRINTF 1
  160|       |
  161|       |/* Define to 1 when the gnulib module vprintf should be tested. */
  162|       |#define GNULIB_TEST_VPRINTF 1
  163|       |
  164|       |/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
  165|       |   whether the gnulib module unistr/u16-mbtoucr shall be considered present.
  166|       |   */
  167|       |#define GNULIB_UNISTR_U16_MBTOUCR 1
  168|       |
  169|       |/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
  170|       |   whether the gnulib module unistr/u8-uctomb shall be considered present. */
  171|       |#define GNULIB_UNISTR_U8_UCTOMB 1
  172|       |
  173|       |/* Define to 1 if you have 'alloca' after including <alloca.h>, a header that
  174|       |   may be supplied by this distribution. */
  175|       |#define HAVE_ALLOCA 1
  176|       |
  177|       |/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
  178|       |   */
  179|       |#define HAVE_ALLOCA_H 1
  180|       |
  181|       |/* Define to 1 if you have the <crtdefs.h> header file. */
  182|       |/* #undef HAVE_CRTDEFS_H */
  183|       |
  184|       |/* Define to 1 if C supports variable-length arrays. */
  185|       |#define HAVE_C_VARARRAYS 1
  186|       |
  187|       |/* Define to 1 if you have the declaration of `ecvt', and to 0 if you don't.
  188|       |   */
  189|       |#define HAVE_DECL_ECVT 1
  190|       |
  191|       |/* Define to 1 if you have the declaration of `execvpe', and to 0 if you
  192|       |   don't. */
  193|       |#define HAVE_DECL_EXECVPE 1
  194|       |
  195|       |/* Define to 1 if you have the declaration of `fcloseall', and to 0 if you
  196|       |   don't. */
  197|       |#define HAVE_DECL_FCLOSEALL 1
  198|       |
  199|       |/* Define to 1 if you have the declaration of `fcvt', and to 0 if you don't.
  200|       |   */
  201|       |#define HAVE_DECL_FCVT 1
  202|       |
  203|       |/* Define to 1 if you have the declaration of `gcvt', and to 0 if you don't.
  204|       |   */
  205|       |#define HAVE_DECL_GCVT 1
  206|       |
  207|       |/* Define to 1 if you have the declaration of `getdtablesize', and to 0 if you
  208|       |   don't. */
  209|       |#define HAVE_DECL_GETDTABLESIZE 1
  210|       |
  211|       |/* Define to 1 if you have the declaration of `program_invocation_name', and
  212|       |   to 0 if you don't. */
  213|       |#define HAVE_DECL_PROGRAM_INVOCATION_NAME 1
  214|       |
  215|       |/* Define to 1 if you have the declaration of `program_invocation_short_name',
  216|       |   and to 0 if you don't. */
  217|       |#define HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME 1
  218|       |
  219|       |/* Define to 1 if you have the declaration of `setenv', and to 0 if you don't.
  220|       |   */
  221|       |#define HAVE_DECL_SETENV 1
  222|       |
  223|       |/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
  224|       |   don't. */
  225|       |#define HAVE_DECL_STRERROR_R 1
  226|       |
  227|       |/* Define to 1 if you have the declaration of `strndup', and to 0 if you
  228|       |   don't. */
  229|       |#define HAVE_DECL_STRNDUP 1
  230|       |
  231|       |/* Define to 1 if you have the declaration of `strnlen', and to 0 if you
  232|       |   don't. */
  233|       |#define HAVE_DECL_STRNLEN 1
  234|       |
  235|       |/* Define to 1 if you have the declaration of `wcsdup', and to 0 if you don't.
  236|       |   */
  237|       |#define HAVE_DECL_WCSDUP 1
  238|       |
  239|       |/* Define to 1 if you have the declaration of `__argv', and to 0 if you don't.
  240|       |   */
  241|       |#define HAVE_DECL___ARGV 0
  242|       |
  243|       |/* Define to 1 if you have the <dirent.h> header file. */
  244|       |#define HAVE_DIRENT_H 1
  245|       |
  246|       |/* Define to 1 if you have the <dlfcn.h> header file. */
  247|       |#define HAVE_DLFCN_H 1
  248|       |
  249|       |/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
  250|       |/* #undef HAVE_DOPRNT */
  251|       |
  252|       |/* Define if you have the declaration of environ. */
  253|       |#define HAVE_ENVIRON_DECL 1
  254|       |
  255|       |/* Define to 1 if you have the `fcntl' function. */
  256|       |#define HAVE_FCNTL 1
  257|       |
  258|       |/* Define to 1 if you have the <features.h> header file. */
  259|       |#define HAVE_FEATURES_H 1
  260|       |
  261|       |/* Define if the 'free' function is guaranteed to preserve errno. */
  262|       |/* #undef HAVE_FREE_POSIX */
  263|       |
  264|       |/* Define to 1 if you have the `getdtablesize' function. */
  265|       |#define HAVE_GETDTABLESIZE 1
  266|       |
  267|       |/* Define to 1 if you have the `getexecname' function. */
  268|       |/* #undef HAVE_GETEXECNAME */
  269|       |
  270|       |/* Define to 1 if you have the <getopt.h> header file. */
  271|       |#define HAVE_GETOPT_H 1
  272|       |
  273|       |/* Define to 1 if you have the `getopt_long_only' function. */
  274|       |#define HAVE_GETOPT_LONG_ONLY 1
  275|       |
  276|       |/* Define to 1 if you have the `getprogname' function. */
  277|       |/* #undef HAVE_GETPROGNAME */
  278|       |
  279|       |/* Define to 1 if the compiler supports one of the keywords 'inline',
  280|       |   '__inline__', '__inline' and effectively inlines functions marked as such.
  281|       |   */
  282|       |#define HAVE_INLINE 1
  283|       |
  284|       |/* Define to 1 if you have the <inttypes.h> header file. */
  285|       |#define HAVE_INTTYPES_H 1
  286|       |
  287|       |/* Define to 1 if you have the `yaml' library (-lyaml). */
  288|       |/* #undef HAVE_LIBYAML */
  289|       |
  290|       |/* Define to 1 if you have the <limits.h> header file. */
  291|       |#define HAVE_LIMITS_H 1
  292|       |
  293|       |/* Define to 1 if the system has the type 'long long int'. */
  294|       |#define HAVE_LONG_LONG_INT 1
  295|       |
  296|       |/* Define to 1 if you have the `lstat' function. */
  297|       |#define HAVE_LSTAT 1
  298|       |
  299|       |/* Define if malloc, realloc, and calloc set errno on allocation failure. */
  300|       |#define HAVE_MALLOC_POSIX 1
  301|       |
  302|       |/* Define to 1 if you have the <memory.h> header file. */
  303|       |#define HAVE_MEMORY_H 1
  304|       |
  305|       |/* Define to 1 if you have the `memset' function. */
  306|       |#define HAVE_MEMSET 1
  307|       |
  308|       |/* Define to 1 if you have the <minix/config.h> header file. */
  309|       |/* #undef HAVE_MINIX_CONFIG_H */
  310|       |
  311|       |/* Define to 1 on MSVC platforms that have the "invalid parameter handler"
  312|       |   concept. */
  313|       |/* #undef HAVE_MSVC_INVALID_PARAMETER_HANDLER */
  314|       |
  315|       |/* Define to 1 if you have the <sdkddkver.h> header file. */
  316|       |/* #undef HAVE_SDKDDKVER_H */
  317|       |
  318|       |/* Define to 1 if you have the <search.h> header file. */
  319|       |#define HAVE_SEARCH_H 1
  320|       |
  321|       |/* Define to 1 if you have the `setdtablesize' function. */
  322|       |/* #undef HAVE_SETDTABLESIZE */
  323|       |
  324|       |/* Define to 1 if you have the `setenv' function. */
  325|       |#define HAVE_SETENV 1
  326|       |
  327|       |/* Define to 1 if 'sig_atomic_t' is a signed integer type. */
  328|       |/* #undef HAVE_SIGNED_SIG_ATOMIC_T */
  329|       |
  330|       |/* Define to 1 if 'wchar_t' is a signed integer type. */
  331|       |/* #undef HAVE_SIGNED_WCHAR_T */
  332|       |
  333|       |/* Define to 1 if 'wint_t' is a signed integer type. */
  334|       |/* #undef HAVE_SIGNED_WINT_T */
  335|       |
  336|       |/* Define to 1 if you have the <stddef.h> header file. */
  337|       |#define HAVE_STDDEF_H 1
  338|       |
  339|       |/* Define to 1 if you have the <stdint.h> header file. */
  340|       |#define HAVE_STDINT_H 1
  341|       |
  342|       |/* Define to 1 if you have the <stdlib.h> header file. */
  343|       |#define HAVE_STDLIB_H 1
  344|       |
  345|       |/* Define to 1 if you have the `strerror_r' function. */
  346|       |#define HAVE_STRERROR_R 1
  347|       |
  348|       |/* Define to 1 if you have the <strings.h> header file. */
  349|       |#define HAVE_STRINGS_H 1
  350|       |
  351|       |/* Define to 1 if you have the <string.h> header file. */
  352|       |#define HAVE_STRING_H 1
  353|       |
  354|       |/* Define to 1 if you have the `strndup' function. */
  355|       |#define HAVE_STRNDUP 1
  356|       |
  357|       |/* Define to 1 if `st_atimensec' is a member of `struct stat'. */
  358|       |/* #undef HAVE_STRUCT_STAT_ST_ATIMENSEC */
  359|       |
  360|       |/* Define to 1 if `st_atimespec.tv_nsec' is a member of `struct stat'. */
  361|       |/* #undef HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC */
  362|       |
  363|       |/* Define to 1 if `st_atim.st__tim.tv_nsec' is a member of `struct stat'. */
  364|       |/* #undef HAVE_STRUCT_STAT_ST_ATIM_ST__TIM_TV_NSEC */
  365|       |
  366|       |/* Define to 1 if `st_atim.tv_nsec' is a member of `struct stat'. */
  367|       |#define HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC 1
  368|       |
  369|       |/* Define to 1 if `st_birthtimensec' is a member of `struct stat'. */
  370|       |/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC */
  371|       |
  372|       |/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
  373|       |/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */
  374|       |
  375|       |/* Define to 1 if `st_birthtim.tv_nsec' is a member of `struct stat'. */
  376|       |/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC */
  377|       |
  378|       |/* Define to 1 if you have the `symlink' function. */
  379|       |#define HAVE_SYMLINK 1
  380|       |
  381|       |/* Define to 1 if you have the <sys/bitypes.h> header file. */
  382|       |/* #undef HAVE_SYS_BITYPES_H */
  383|       |
  384|       |/* Define to 1 if you have the <sys/cdefs.h> header file. */
  385|       |#define HAVE_SYS_CDEFS_H 1
  386|       |
  387|       |/* Define to 1 if you have the <sys/inttypes.h> header file. */
  388|       |/* #undef HAVE_SYS_INTTYPES_H */
  389|       |
  390|       |/* Define to 1 if you have the <sys/param.h> header file. */
  391|       |#define HAVE_SYS_PARAM_H 1
  392|       |
  393|       |/* Define to 1 if you have the <sys/socket.h> header file. */
  394|       |#define HAVE_SYS_SOCKET_H 1
  395|       |
  396|       |/* Define to 1 if you have the <sys/stat.h> header file. */
  397|       |#define HAVE_SYS_STAT_H 1
  398|       |
  399|       |/* Define to 1 if you have the <sys/time.h> header file. */
  400|       |#define HAVE_SYS_TIME_H 1
  401|       |
  402|       |/* Define to 1 if you have the <sys/types.h> header file. */
  403|       |#define HAVE_SYS_TYPES_H 1
  404|       |
  405|       |/* Define to 1 if you have the `tsearch' function. */
  406|       |#define HAVE_TSEARCH 1
  407|       |
  408|       |/* Define to 1 if you have the <unistd.h> header file. */
  409|       |#define HAVE_UNISTD_H 1
  410|       |
  411|       |/* Define to 1 if the system has the type 'unsigned long long int'. */
  412|       |#define HAVE_UNSIGNED_LONG_LONG_INT 1
  413|       |
  414|       |/* Define if you have a global __progname variable */
  415|       |/* #undef HAVE_VAR___PROGNAME */
  416|       |
  417|       |/* Define to 1 if you have the `vprintf' function. */
  418|       |#define HAVE_VPRINTF 1
  419|       |
  420|       |/* Define to 1 if you have the <wchar.h> header file. */
  421|       |#define HAVE_WCHAR_H 1
  422|       |
  423|       |/* Define if you have the 'wchar_t' type. */
  424|       |#define HAVE_WCHAR_T 1
  425|       |
  426|       |/* Define to 1 if you have the <winsock2.h> header file. */
  427|       |/* #undef HAVE_WINSOCK2_H */
  428|       |
  429|       |/* Define if you have the 'wint_t' type. */
  430|       |#define HAVE_WINT_T 1
  431|       |
  432|       |/* Define to 1 if O_NOATIME works. */
  433|       |#define HAVE_WORKING_O_NOATIME 1
  434|       |
  435|       |/* Define to 1 if O_NOFOLLOW works. */
  436|       |#define HAVE_WORKING_O_NOFOLLOW 1
  437|       |
  438|       |/* Define to 1 if the system has the type `_Bool'. */
  439|       |#define HAVE__BOOL 1
  440|       |
  441|       |/* Define to 1 if you have the `_set_invalid_parameter_handler' function. */
  442|       |/* #undef HAVE__SET_INVALID_PARAMETER_HANDLER */
  443|       |
  444|       |/* Define to the sub-directory where libtool stores uninstalled libraries. */
  445|       |#define LT_OBJDIR ".libs/"
  446|       |
  447|       |/* If malloc(0) is != NULL, define this to 1. Otherwise define this to 0. */
  448|       |#define MALLOC_0_IS_NONNULL 1
  449|       |
  450|       |/* Use GNU style printf and scanf.  */
  451|       |#ifndef __USE_MINGW_ANSI_STDIO
  452|       |# define __USE_MINGW_ANSI_STDIO 1
  453|       |#endif
  454|       |
  455|       |
  456|       |/* Define to 1 if open() fails to recognize a trailing slash. */
  457|       |/* #undef OPEN_TRAILING_SLASH_BUG */
  458|       |
  459|       |/* Name of package */
  460|       |#define PACKAGE "liblouis"
  461|       |
  462|       |/* Define to the address where bug reports for this package should be sent. */
  463|       |#define PACKAGE_BUGREPORT "liblouis-liblouisxml@freelists.org"
  464|       |
  465|       |/* Define to the full name of this package. */
  466|       |#define PACKAGE_NAME "Liblouis"
  467|       |
  468|       |/* String identifying the packager of this software */
  469|       |/* #undef PACKAGE_PACKAGER */
  470|       |
  471|       |/* Packager info for bug reports (URL/e-mail/...) */
  472|       |/* #undef PACKAGE_PACKAGER_BUG_REPORTS */
  473|       |
  474|       |/* Packager-specific version information */
  475|       |/* #undef PACKAGE_PACKAGER_VERSION */
  476|       |
  477|       |/* Define to the full name and version of this package. */
  478|       |#define PACKAGE_STRING "Liblouis 3.21.0"
  479|       |
  480|       |/* Define to the one symbol short name of this package. */
  481|       |#define PACKAGE_TARNAME "liblouis"
  482|       |
  483|       |/* Define to the home page for this package. */
  484|       |#define PACKAGE_URL "http://www.liblouis.org"
  485|       |
  486|       |/* Define to the version of this package. */
  487|      0|#define PACKAGE_VERSION "3.21.0"
  488|       |
  489|       |/* Define to the type that is the result of default argument promotions of
  490|       |   type mode_t. */
  491|       |#define PROMOTED_MODE_T mode_t
  492|       |
  493|       |/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
  494|       |   'ptrdiff_t'. */
  495|       |/* #undef PTRDIFF_T_SUFFIX */
  496|       |
  497|       |/* Define to 1 if stat needs help when passed a file name with a trailing
  498|       |   slash */
  499|       |/* #undef REPLACE_FUNC_STAT_FILE */
  500|       |
  501|       |/* Define to 1 if strerror(0) does not return a message implying success. */
  502|       |/* #undef REPLACE_STRERROR_0 */
  503|       |
  504|       |/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
  505|       |   'sig_atomic_t'. */
  506|       |/* #undef SIG_ATOMIC_T_SUFFIX */
  507|       |
  508|       |/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
  509|       |   'size_t'. */
  510|       |/* #undef SIZE_T_SUFFIX */
  511|       |
  512|       |/* If using the C implementation of alloca, define if you know the
  513|       |   direction of stack growth for your system; otherwise it will be
  514|       |   automatically deduced at runtime.
  515|       |        STACK_DIRECTION > 0 => grows toward higher addresses
  516|       |        STACK_DIRECTION < 0 => grows toward lower addresses
  517|       |        STACK_DIRECTION = 0 => direction of growth unknown */
  518|       |/* #undef STACK_DIRECTION */
  519|       |
  520|       |/* Define to 1 if the `S_IS*' macros in <sys/stat.h> do not work properly. */
  521|       |/* #undef STAT_MACROS_BROKEN */
  522|       |
  523|       |/* Define to 1 if you have the ANSI C header files. */
  524|       |#define STDC_HEADERS 1
  525|       |
  526|       |/* Define to 1 if strerror_r returns char *. */
  527|       |#define STRERROR_R_CHAR_P 1
  528|       |
  529|       |/* Define to 1 if the type of the st_atim member of a struct stat is struct
  530|       |   timespec. */
  531|       |#define TYPEOF_STRUCT_STAT_ST_ATIM_IS_STRUCT_TIMESPEC 1
  532|       |
  533|       |/* Enable extensions on AIX 3, Interix.  */
  534|       |#ifndef _ALL_SOURCE
  535|       |# define _ALL_SOURCE 1
  536|       |#endif
  537|       |/* Enable general extensions on macOS.  */
  538|       |#ifndef _DARWIN_C_SOURCE
  539|       |# define _DARWIN_C_SOURCE 1
  540|       |#endif
  541|       |/* Enable general extensions on Solaris.  */
  542|       |#ifndef __EXTENSIONS__
  543|       |# define __EXTENSIONS__ 1
  544|       |#endif
  545|       |/* Enable GNU extensions on systems that have them.  */
  546|       |#ifndef _GNU_SOURCE
  547|       |# define _GNU_SOURCE 1
  548|       |#endif
  549|       |/* Enable X/Open compliant socket functions that do not require linking
  550|       |   with -lxnet on HP-UX 11.11.  */
  551|       |#ifndef _HPUX_ALT_XOPEN_SOCKET_API
  552|       |# define _HPUX_ALT_XOPEN_SOCKET_API 1
  553|       |#endif
  554|       |/* Identify the host operating system as Minix.
  555|       |   This macro does not affect the system headers' behavior.
  556|       |   A future release of Autoconf may stop defining this macro.  */
  557|       |#ifndef _MINIX
  558|       |/* # undef _MINIX */
  559|       |#endif
  560|       |/* Enable general extensions on NetBSD.
  561|       |   Enable NetBSD compatibility extensions on Minix.  */
  562|       |#ifndef _NETBSD_SOURCE
  563|       |# define _NETBSD_SOURCE 1
  564|       |#endif
  565|       |/* Enable OpenBSD compatibility extensions on NetBSD.
  566|       |   Oddly enough, this does nothing on OpenBSD.  */
  567|       |#ifndef _OPENBSD_SOURCE
  568|       |# define _OPENBSD_SOURCE 1
  569|       |#endif
  570|       |/* Define to 1 if needed for POSIX-compatible behavior.  */
  571|       |#ifndef _POSIX_SOURCE
  572|       |/* # undef _POSIX_SOURCE */
  573|       |#endif
  574|       |/* Define to 2 if needed for POSIX-compatible behavior.  */
  575|       |#ifndef _POSIX_1_SOURCE
  576|       |/* # undef _POSIX_1_SOURCE */
  577|       |#endif
  578|       |/* Enable POSIX-compatible threading on Solaris.  */
  579|       |#ifndef _POSIX_PTHREAD_SEMANTICS
  580|       |# define _POSIX_PTHREAD_SEMANTICS 1
  581|       |#endif
  582|       |/* Enable extensions specified by ISO/IEC TS 18661-5:2014.  */
  583|       |#ifndef __STDC_WANT_IEC_60559_ATTRIBS_EXT__
  584|       |# define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
  585|       |#endif
  586|       |/* Enable extensions specified by ISO/IEC TS 18661-1:2014.  */
  587|       |#ifndef __STDC_WANT_IEC_60559_BFP_EXT__
  588|       |# define __STDC_WANT_IEC_60559_BFP_EXT__ 1
  589|       |#endif
  590|       |/* Enable extensions specified by ISO/IEC TS 18661-2:2015.  */
  591|       |#ifndef __STDC_WANT_IEC_60559_DFP_EXT__
  592|       |# define __STDC_WANT_IEC_60559_DFP_EXT__ 1
  593|       |#endif
  594|       |/* Enable extensions specified by ISO/IEC TS 18661-4:2015.  */
  595|       |#ifndef __STDC_WANT_IEC_60559_FUNCS_EXT__
  596|       |# define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
  597|       |#endif
  598|       |/* Enable extensions specified by ISO/IEC TS 18661-3:2015.  */
  599|       |#ifndef __STDC_WANT_IEC_60559_TYPES_EXT__
  600|       |# define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
  601|       |#endif
  602|       |/* Enable extensions specified by ISO/IEC TR 24731-2:2010.  */
  603|       |#ifndef __STDC_WANT_LIB_EXT2__
  604|       |# define __STDC_WANT_LIB_EXT2__ 1
  605|       |#endif
  606|       |/* Enable extensions specified by ISO/IEC 24747:2009.  */
  607|       |#ifndef __STDC_WANT_MATH_SPEC_FUNCS__
  608|       |# define __STDC_WANT_MATH_SPEC_FUNCS__ 1
  609|       |#endif
  610|       |/* Enable extensions on HP NonStop.  */
  611|       |#ifndef _TANDEM_SOURCE
  612|       |# define _TANDEM_SOURCE 1
  613|       |#endif
  614|       |/* Enable X/Open extensions.  Define to 500 only if necessary
  615|       |   to make mbstate_t available.  */
  616|       |#ifndef _XOPEN_SOURCE
  617|       |/* # undef _XOPEN_SOURCE */
  618|       |#endif
  619|       |
  620|       |
  621|       |/* Version number of package */
  622|       |#define VERSION "3.21.0"
  623|       |
  624|       |/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
  625|       |   'wchar_t'. */
  626|       |/* #undef WCHAR_T_SUFFIX */
  627|       |
  628|       |/* Define if widechars are ucs4 */
  629|       |/* #undef WIDECHARS_ARE_UCS4 */
  630|       |
  631|       |/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
  632|       |   'wint_t'. */
  633|       |/* #undef WINT_T_SUFFIX */
  634|       |
  635|       |/* Disable YAML tests */
  636|       |/* #undef WITHOUT_YAML */
  637|       |
  638|       |/* Number of bits in a file offset, on hosts where this is settable. */
  639|       |/* #undef _FILE_OFFSET_BITS */
  640|       |
  641|       |/* True if the compiler says it groks GNU C version MAJOR.MINOR.  */
  642|       |#if defined __GNUC__ && defined __GNUC_MINOR__
  643|       |# define _GL_GNUC_PREREQ(major, minor) \
  644|       |    ((major) < __GNUC__ + ((minor) <= __GNUC_MINOR__))
  645|       |#else
  646|       |# define _GL_GNUC_PREREQ(major, minor) 0
  647|       |#endif
  648|       |
  649|       |
  650|       |/* Define to enable the declarations of ISO C 11 types and functions. */
  651|       |/* #undef _ISOC11_SOURCE */
  652|       |
  653|       |/* Define for large files, on AIX-style hosts. */
  654|       |/* #undef _LARGE_FILES */
  655|       |
  656|       |/* The _Noreturn keyword of C11.  */
  657|       |#ifndef _Noreturn
  658|       |# if (defined __cplusplus \
  659|       |      && ((201103 <= __cplusplus && !(__GNUC__ == 4 && __GNUC_MINOR__ == 7)) \
  660|       |          || (defined _MSC_VER && 1900 <= _MSC_VER)) \
  661|       |      && 0)
  662|       |    /* [[noreturn]] is not practically usable, because with it the syntax
  663|       |         extern _Noreturn void func (...);
  664|       |       would not be valid; such a declaration would only be valid with 'extern'
  665|       |       and '_Noreturn' swapped, or without the 'extern' keyword.  However, some
  666|       |       AIX system header files and several gnulib header files use precisely
  667|       |       this syntax with 'extern'.  */
  668|       |#  define _Noreturn [[noreturn]]
  669|       |# elif ((!defined __cplusplus || defined __clang__) \
  670|       |        && (201112 <= (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0) \
  671|       |            || (!defined __STRICT_ANSI__ \
  672|       |                && (_GL_GNUC_PREREQ (4, 7) \
  673|       |                    || (defined __apple_build_version__ \
  674|       |                        ? 6000000 <= __apple_build_version__ \
  675|       |                        : 3 < __clang_major__ + (5 <= __clang_minor__))))))
  676|       |   /* _Noreturn works as-is.  */
  677|       |# elif _GL_GNUC_PREREQ (2, 8) || defined __clang__ || 0x5110 <= __SUNPRO_C
  678|       |#  define _Noreturn __attribute__ ((__noreturn__))
  679|       |# elif 1200 <= (defined _MSC_VER ? _MSC_VER : 0)
  680|       |#  define _Noreturn __declspec (noreturn)
  681|       |# else
  682|       |#  define _Noreturn
  683|       |# endif
  684|       |#endif
  685|       |
  686|       |
  687|       |/* Number of bits in a timestamp, on hosts where this is settable. */
  688|       |/* #undef _TIME_BITS */
  689|       |
  690|       |/* For standard stat data types on VMS. */
  691|       |#define _USE_STD_STAT 1
  692|       |
  693|       |/* Define to rpl_ if the getopt replacement functions and variables should be
  694|       |   used. */
  695|       |/* #undef __GETOPT_PREFIX */
  696|       |
  697|       |/* For 64-bit time_t on 32-bit mingw. */
  698|       |/* #undef __MINGW_USE_VC2005_COMPAT */
  699|       |
  700|       |/* Define to 1 if the system <stdint.h> predates C++11. */
  701|       |/* #undef __STDC_CONSTANT_MACROS */
  702|       |
  703|       |/* Define to 1 if the system <stdint.h> predates C++11. */
  704|       |/* #undef __STDC_LIMIT_MACROS */
  705|       |
  706|       |/* Define to 1 if C does not support variable-length arrays, and if the
  707|       |   compiler does not already define this. */
  708|       |/* #undef __STDC_NO_VLA__ */
  709|       |
  710|       |/* The _GL_ASYNC_SAFE marker should be attached to functions that are
  711|       |   signal handlers (for signals other than SIGABRT, SIGPIPE) or can be
  712|       |   invoked from such signal handlers.  Such functions have some restrictions:
  713|       |     * All functions that it calls should be marked _GL_ASYNC_SAFE as well,
  714|       |       or should be listed as async-signal-safe in POSIX
  715|       |       <https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04>
  716|       |       section 2.4.3.  Note that malloc(), sprintf(), and fwrite(), in
  717|       |       particular, are NOT async-signal-safe.
  718|       |     * All memory locations (variables and struct fields) that these functions
  719|       |       access must be marked 'volatile'.  This holds for both read and write
  720|       |       accesses.  Otherwise the compiler might optimize away stores to and
  721|       |       reads from such locations that occur in the program, depending on its
  722|       |       data flow analysis.  For example, when the program contains a loop
  723|       |       that is intended to inspect a variable set from within a signal handler
  724|       |           while (!signal_occurred)
  725|       |             ;
  726|       |       the compiler is allowed to transform this into an endless loop if the
  727|       |       variable 'signal_occurred' is not declared 'volatile'.
  728|       |   Additionally, recall that:
  729|       |     * A signal handler should not modify errno (except if it is a handler
  730|       |       for a fatal signal and ends by raising the same signal again, thus
  731|       |       provoking the termination of the process).  If it invokes a function
  732|       |       that may clobber errno, it needs to save and restore the value of
  733|       |       errno.  */
  734|       |#define _GL_ASYNC_SAFE
  735|       |
  736|       |
  737|       |/* Attributes.  */
  738|       |#if (defined __has_attribute \
  739|       |     && (!defined __clang_minor__ \
  740|       |         || 3 < __clang_major__ + (5 <= __clang_minor__)))
  741|       |# define _GL_HAS_ATTRIBUTE(attr) __has_attribute (__##attr##__)
  742|       |#else
  743|       |# define _GL_HAS_ATTRIBUTE(attr) _GL_ATTR_##attr
  744|       |# define _GL_ATTR_alloc_size _GL_GNUC_PREREQ (4, 3)
  745|       |# define _GL_ATTR_always_inline _GL_GNUC_PREREQ (3, 2)
  746|       |# define _GL_ATTR_artificial _GL_GNUC_PREREQ (4, 3)
  747|       |# define _GL_ATTR_cold _GL_GNUC_PREREQ (4, 3)
  748|       |# define _GL_ATTR_const _GL_GNUC_PREREQ (2, 95)
  749|       |# define _GL_ATTR_deprecated _GL_GNUC_PREREQ (3, 1)
  750|       |# define _GL_ATTR_diagnose_if 0
  751|       |# define _GL_ATTR_error _GL_GNUC_PREREQ (4, 3)
  752|       |# define _GL_ATTR_externally_visible _GL_GNUC_PREREQ (4, 1)
  753|       |# define _GL_ATTR_fallthrough _GL_GNUC_PREREQ (7, 0)
  754|       |# define _GL_ATTR_format _GL_GNUC_PREREQ (2, 7)
  755|       |# define _GL_ATTR_leaf _GL_GNUC_PREREQ (4, 6)
  756|       |# define _GL_ATTR_malloc _GL_GNUC_PREREQ (3, 0)
  757|       |# ifdef _ICC
  758|       |#  define _GL_ATTR_may_alias 0
  759|       |# else
  760|       |#  define _GL_ATTR_may_alias _GL_GNUC_PREREQ (3, 3)
  761|       |# endif
  762|       |# define _GL_ATTR_noinline _GL_GNUC_PREREQ (3, 1)
  763|       |# define _GL_ATTR_nonnull _GL_GNUC_PREREQ (3, 3)
  764|       |# define _GL_ATTR_nonstring _GL_GNUC_PREREQ (8, 0)
  765|       |# define _GL_ATTR_nothrow _GL_GNUC_PREREQ (3, 3)
  766|       |# define _GL_ATTR_packed _GL_GNUC_PREREQ (2, 7)
  767|       |# define _GL_ATTR_pure _GL_GNUC_PREREQ (2, 96)
  768|       |# define _GL_ATTR_returns_nonnull _GL_GNUC_PREREQ (4, 9)
  769|       |# define _GL_ATTR_sentinel _GL_GNUC_PREREQ (4, 0)
  770|       |# define _GL_ATTR_unused _GL_GNUC_PREREQ (2, 7)
  771|       |# define _GL_ATTR_warn_unused_result _GL_GNUC_PREREQ (3, 4)
  772|       |#endif
  773|       |
  774|       |#ifdef __has_c_attribute
  775|       |# define _GL_HAS_C_ATTRIBUTE(attr) __has_c_attribute (__##attr##__)
  776|       |#else
  777|       |# define _GL_HAS_C_ATTRIBUTE(attr) 0
  778|       |#endif
  779|       |
  780|       |
  781|       |/* _GL_ATTRIBUTE_ALLOC_SIZE ((N)) declares that the Nth argument of the function
  782|       |   is the size of the returned memory block.
  783|       |   _GL_ATTRIBUTE_ALLOC_SIZE ((M, N)) declares that the Mth argument multiplied
  784|       |   by the Nth argument of the function is the size of the returned memory block.
  785|       | */
  786|       |/* Applies to: function, pointer to function, function types.  */
  787|       |#if _GL_HAS_ATTRIBUTE (alloc_size)
  788|       |# define _GL_ATTRIBUTE_ALLOC_SIZE(args) __attribute__ ((__alloc_size__ args))
  789|       |#else
  790|       |# define _GL_ATTRIBUTE_ALLOC_SIZE(args)
  791|       |#endif
  792|       |
  793|       |/* _GL_ATTRIBUTE_ALWAYS_INLINE tells that the compiler should always inline the
  794|       |   function and report an error if it cannot do so.  */
  795|       |/* Applies to: function.  */
  796|       |#if _GL_HAS_ATTRIBUTE (always_inline)
  797|       |# define _GL_ATTRIBUTE_ALWAYS_INLINE __attribute__ ((__always_inline__))
  798|       |#else
  799|       |# define _GL_ATTRIBUTE_ALWAYS_INLINE
  800|       |#endif
  801|       |
  802|       |/* _GL_ATTRIBUTE_ARTIFICIAL declares that the function is not important to show
  803|       |    in stack traces when debugging.  The compiler should omit the function from
  804|       |    stack traces.  */
  805|       |/* Applies to: function.  */
  806|       |#if _GL_HAS_ATTRIBUTE (artificial)
  807|       |# define _GL_ATTRIBUTE_ARTIFICIAL __attribute__ ((__artificial__))
  808|       |#else
  809|       |# define _GL_ATTRIBUTE_ARTIFICIAL
  810|       |#endif
  811|       |
  812|       |/* _GL_ATTRIBUTE_COLD declares that the function is rarely executed.  */
  813|       |/* Applies to: functions.  */
  814|       |/* Avoid __attribute__ ((cold)) on MinGW; see thread starting at
  815|       |   <https://lists.gnu.org/r/emacs-devel/2019-04/msg01152.html>.
  816|       |   Also, Oracle Studio 12.6 requires 'cold' not '__cold__'.  */
  817|       |#if _GL_HAS_ATTRIBUTE (cold) && !defined __MINGW32__
  818|       |# ifndef __SUNPRO_C
  819|       |#  define _GL_ATTRIBUTE_COLD __attribute__ ((__cold__))
  820|       |# else
  821|       |#  define _GL_ATTRIBUTE_COLD __attribute__ ((cold))
  822|       |# endif
  823|       |#else
  824|       |# define _GL_ATTRIBUTE_COLD
  825|       |#endif
  826|       |
  827|       |/* _GL_ATTRIBUTE_CONST declares that it is OK for a compiler to omit duplicate
  828|       |   calls to the function with the same arguments.
  829|       |   This attribute is safe for a function that neither depends on nor affects
  830|       |   observable state, and always returns exactly once - e.g., does not loop
  831|       |   forever, and does not call longjmp.
  832|       |   (This attribute is stricter than _GL_ATTRIBUTE_PURE.)  */
  833|       |/* Applies to: functions.  */
  834|       |#if _GL_HAS_ATTRIBUTE (const)
  835|       |# define _GL_ATTRIBUTE_CONST __attribute__ ((__const__))
  836|       |#else
  837|       |# define _GL_ATTRIBUTE_CONST
  838|       |#endif
  839|       |
  840|       |/* _GL_ATTRIBUTE_DEALLOC (F, I) declares that the function returns pointers
  841|       |   that can be freed by passing them as the Ith argument to the
  842|       |   function F.
  843|       |   _GL_ATTRIBUTE_DEALLOC_FREE declares that the function returns pointers that
  844|       |   can be freed via 'free'; it can be used only after declaring 'free'.  */
  845|       |/* Applies to: functions.  Cannot be used on inline functions.  */
  846|       |#if _GL_GNUC_PREREQ (11, 0)
  847|       |# define _GL_ATTRIBUTE_DEALLOC(f, i) __attribute__ ((__malloc__ (f, i)))
  848|       |#else
  849|       |# define _GL_ATTRIBUTE_DEALLOC(f, i)
  850|       |#endif
  851|       |#define _GL_ATTRIBUTE_DEALLOC_FREE _GL_ATTRIBUTE_DEALLOC (free, 1)
  852|       |
  853|       |/* _GL_ATTRIBUTE_DEPRECATED: Declares that an entity is deprecated.
  854|       |   The compiler may warn if the entity is used.  */
  855|       |/* Applies to:
  856|       |     - function, variable,
  857|       |     - struct, union, struct/union member,
  858|       |     - enumeration, enumeration item,
  859|       |     - typedef,
  860|       |   in C++ also: namespace, class, template specialization.  */
  861|       |#if _GL_HAS_C_ATTRIBUTE (deprecated)
  862|       |# define _GL_ATTRIBUTE_DEPRECATED [[__deprecated__]]
  863|       |#elif _GL_HAS_ATTRIBUTE (deprecated)
  864|       |# define _GL_ATTRIBUTE_DEPRECATED __attribute__ ((__deprecated__))
  865|       |#else
  866|       |# define _GL_ATTRIBUTE_DEPRECATED
  867|       |#endif
  868|       |
  869|       |/* _GL_ATTRIBUTE_ERROR(msg) requests an error if a function is called and
  870|       |   the function call is not optimized away.
  871|       |   _GL_ATTRIBUTE_WARNING(msg) requests a warning if a function is called and
  872|       |   the function call is not optimized away.  */
  873|       |/* Applies to: functions.  */
  874|       |#if _GL_HAS_ATTRIBUTE (error)
  875|       |# define _GL_ATTRIBUTE_ERROR(msg) __attribute__ ((__error__ (msg)))
  876|       |# define _GL_ATTRIBUTE_WARNING(msg) __attribute__ ((__warning__ (msg)))
  877|       |#elif _GL_HAS_ATTRIBUTE (diagnose_if)
  878|       |# define _GL_ATTRIBUTE_ERROR(msg) __attribute__ ((__diagnose_if__ (1, msg, "error")))
  879|       |# define _GL_ATTRIBUTE_WARNING(msg) __attribute__ ((__diagnose_if__ (1, msg, "warning")))
  880|       |#else
  881|       |# define _GL_ATTRIBUTE_ERROR(msg)
  882|       |# define _GL_ATTRIBUTE_WARNING(msg)
  883|       |#endif
  884|       |
  885|       |/* _GL_ATTRIBUTE_EXTERNALLY_VISIBLE declares that the entity should remain
  886|       |   visible to debuggers etc., even with '-fwhole-program'.  */
  887|       |/* Applies to: functions, variables.  */
  888|       |#if _GL_HAS_ATTRIBUTE (externally_visible)
  889|       |# define _GL_ATTRIBUTE_EXTERNALLY_VISIBLE __attribute__ ((externally_visible))
  890|       |#else
  891|       |# define _GL_ATTRIBUTE_EXTERNALLY_VISIBLE
  892|       |#endif
  893|       |
  894|       |/* _GL_ATTRIBUTE_FALLTHROUGH declares that it is not a programming mistake if
  895|       |   the control flow falls through to the immediately following 'case' or
  896|       |   'default' label.  The compiler should not warn in this case.  */
  897|       |/* Applies to: Empty statement (;), inside a 'switch' statement.  */
  898|       |/* Always expands to something.  */
  899|       |#if _GL_HAS_C_ATTRIBUTE (fallthrough)
  900|       |# define _GL_ATTRIBUTE_FALLTHROUGH [[__fallthrough__]]
  901|       |#elif _GL_HAS_ATTRIBUTE (fallthrough)
  902|       |# define _GL_ATTRIBUTE_FALLTHROUGH __attribute__ ((__fallthrough__))
  903|       |#else
  904|       |# define _GL_ATTRIBUTE_FALLTHROUGH ((void) 0)
  905|       |#endif
  906|       |
  907|       |/* _GL_ATTRIBUTE_FORMAT ((ARCHETYPE, STRING-INDEX, FIRST-TO-CHECK))
  908|       |   declares that the STRING-INDEXth function argument is a format string of
  909|       |   style ARCHETYPE, which is one of:
  910|       |     printf, gnu_printf
  911|       |     scanf, gnu_scanf,
  912|       |     strftime, gnu_strftime,
  913|       |     strfmon,
  914|       |   or the same thing prefixed and suffixed with '__'.
  915|       |   If FIRST-TO-CHECK is not 0, arguments starting at FIRST-TO_CHECK
  916|       |   are suitable for the format string.  */
  917|       |/* Applies to: functions.  */
  918|       |#if _GL_HAS_ATTRIBUTE (format)
  919|       |# define _GL_ATTRIBUTE_FORMAT(spec) __attribute__ ((__format__ spec))
  920|       |#else
  921|       |# define _GL_ATTRIBUTE_FORMAT(spec)
  922|       |#endif
  923|       |
  924|       |/* _GL_ATTRIBUTE_LEAF declares that if the function is called from some other
  925|       |   compilation unit, it executes code from that unit only by return or by
  926|       |   exception handling.  This declaration lets the compiler optimize that unit
  927|       |   more aggressively.  */
  928|       |/* Applies to: functions.  */
  929|       |#if _GL_HAS_ATTRIBUTE (leaf)
  930|       |# define _GL_ATTRIBUTE_LEAF __attribute__ ((__leaf__))
  931|       |#else
  932|       |# define _GL_ATTRIBUTE_LEAF
  933|       |#endif
  934|       |
  935|       |/* _GL_ATTRIBUTE_MALLOC declares that the function returns a pointer to freshly
  936|       |   allocated memory.  */
  937|       |/* Applies to: functions.  */
  938|       |#if _GL_HAS_ATTRIBUTE (malloc)
  939|       |# define _GL_ATTRIBUTE_MALLOC __attribute__ ((__malloc__))
  940|       |#else
  941|       |# define _GL_ATTRIBUTE_MALLOC
  942|       |#endif
  943|       |
  944|       |/* _GL_ATTRIBUTE_MAY_ALIAS declares that pointers to the type may point to the
  945|       |   same storage as pointers to other types.  Thus this declaration disables
  946|       |   strict aliasing optimization.  */
  947|       |/* Applies to: types.  */
  948|       |/* Oracle Studio 12.6 mishandles may_alias despite __has_attribute OK.  */
  949|       |#if _GL_HAS_ATTRIBUTE (may_alias) && !defined __SUNPRO_C
  950|       |# define _GL_ATTRIBUTE_MAY_ALIAS __attribute__ ((__may_alias__))
  951|       |#else
  952|       |# define _GL_ATTRIBUTE_MAY_ALIAS
  953|       |#endif
  954|       |
  955|       |/* _GL_ATTRIBUTE_MAYBE_UNUSED declares that it is not a programming mistake if
  956|       |   the entity is not used.  The compiler should not warn if the entity is not
  957|       |   used.  */
  958|       |/* Applies to:
  959|       |     - function, variable,
  960|       |     - struct, union, struct/union member,
  961|       |     - enumeration, enumeration item,
  962|       |     - typedef,
  963|       |   in C++ also: class.  */
  964|       |/* In C++ and C2x, this is spelled [[__maybe_unused__]].
  965|       |   GCC's syntax is __attribute__ ((__unused__)).
  966|       |   clang supports both syntaxes.  */
  967|       |#if _GL_HAS_C_ATTRIBUTE (maybe_unused)
  968|       |# define _GL_ATTRIBUTE_MAYBE_UNUSED [[__maybe_unused__]]
  969|       |#else
  970|       |# define _GL_ATTRIBUTE_MAYBE_UNUSED _GL_ATTRIBUTE_UNUSED
  971|       |#endif
  972|       |/* Alternative spelling of this macro, for convenience.  */
  973|       |#define _GL_UNUSED _GL_ATTRIBUTE_MAYBE_UNUSED
  974|       |/* Earlier spellings of this macro.  */
  975|       |#define _UNUSED_PARAMETER_ _GL_ATTRIBUTE_MAYBE_UNUSED
  976|       |
  977|       |/* _GL_ATTRIBUTE_NODISCARD declares that the caller of the function should not
  978|       |   discard the return value.  The compiler may warn if the caller does not use
  979|       |   the return value, unless the caller uses something like ignore_value.  */
  980|       |/* Applies to: function, enumeration, class.  */
  981|       |#if _GL_HAS_C_ATTRIBUTE (nodiscard)
  982|       |# define _GL_ATTRIBUTE_NODISCARD [[__nodiscard__]]
  983|       |#elif _GL_HAS_ATTRIBUTE (warn_unused_result)
  984|       |# define _GL_ATTRIBUTE_NODISCARD __attribute__ ((__warn_unused_result__))
  985|       |#else
  986|       |# define _GL_ATTRIBUTE_NODISCARD
  987|       |#endif
  988|       |
  989|       |/* _GL_ATTRIBUTE_NOINLINE tells that the compiler should not inline the
  990|       |   function.  */
  991|       |/* Applies to: functions.  */
  992|       |#if _GL_HAS_ATTRIBUTE (noinline)
  993|       |# define _GL_ATTRIBUTE_NOINLINE __attribute__ ((__noinline__))
  994|       |#else
  995|       |# define _GL_ATTRIBUTE_NOINLINE
  996|       |#endif
  997|       |
  998|       |/* _GL_ATTRIBUTE_NONNULL ((N1, N2,...)) declares that the arguments N1, N2,...
  999|       |   must not be NULL.
 1000|       |   _GL_ATTRIBUTE_NONNULL () declares that all pointer arguments must not be
 1001|       |   null.  */
 1002|       |/* Applies to: functions.  */
 1003|       |#if _GL_HAS_ATTRIBUTE (nonnull)
 1004|       |# define _GL_ATTRIBUTE_NONNULL(args) __attribute__ ((__nonnull__ args))
 1005|       |#else
 1006|       |# define _GL_ATTRIBUTE_NONNULL(args)
 1007|       |#endif
 1008|       |
 1009|       |/* _GL_ATTRIBUTE_NONSTRING declares that the contents of a character array is
 1010|       |   not meant to be NUL-terminated.  */
 1011|       |/* Applies to: struct/union members and variables that are arrays of element
 1012|       |   type '[[un]signed] char'.  */
 1013|       |#if _GL_HAS_ATTRIBUTE (nonstring)
 1014|       |# define _GL_ATTRIBUTE_NONSTRING __attribute__ ((__nonstring__))
 1015|       |#else
 1016|       |# define _GL_ATTRIBUTE_NONSTRING
 1017|       |#endif
 1018|       |
 1019|       |/* There is no _GL_ATTRIBUTE_NORETURN; use _Noreturn instead.  */
 1020|       |
 1021|       |/* _GL_ATTRIBUTE_NOTHROW declares that the function does not throw exceptions.
 1022|       | */
 1023|       |/* Applies to: functions.  */
 1024|       |#if _GL_HAS_ATTRIBUTE (nothrow) && !defined __cplusplus
 1025|       |# define _GL_ATTRIBUTE_NOTHROW __attribute__ ((__nothrow__))
 1026|       |#else
 1027|       |# define _GL_ATTRIBUTE_NOTHROW
 1028|       |#endif
 1029|       |
 1030|       |/* _GL_ATTRIBUTE_PACKED declares:
 1031|       |   For struct members: The member has the smallest possible alignment.
 1032|       |   For struct, union, class: All members have the smallest possible alignment,
 1033|       |   minimizing the memory required.  */
 1034|       |/* Applies to: struct members, struct, union,
 1035|       |   in C++ also: class.  */
 1036|       |#if _GL_HAS_ATTRIBUTE (packed)
 1037|       |# define _GL_ATTRIBUTE_PACKED __attribute__ ((__packed__))
 1038|       |#else
 1039|       |# define _GL_ATTRIBUTE_PACKED
 1040|       |#endif
 1041|       |
 1042|       |/* _GL_ATTRIBUTE_PURE declares that It is OK for a compiler to omit duplicate
 1043|       |   calls to the function with the same arguments if observable state is not
 1044|       |   changed between calls.
 1045|       |   This attribute is safe for a function that does not affect
 1046|       |   observable state, and always returns exactly once.
 1047|       |   (This attribute is looser than _GL_ATTRIBUTE_CONST.)  */
 1048|       |/* Applies to: functions.  */
 1049|       |#if _GL_HAS_ATTRIBUTE (pure)
 1050|       |# define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
 1051|       |#else
 1052|       |# define _GL_ATTRIBUTE_PURE
 1053|       |#endif
 1054|       |
 1055|       |/* _GL_ATTRIBUTE_RETURNS_NONNULL declares that the function's return value is
 1056|       |   a non-NULL pointer.  */
 1057|       |/* Applies to: functions.  */
 1058|       |#if _GL_HAS_ATTRIBUTE (returns_nonnull)
 1059|       |# define _GL_ATTRIBUTE_RETURNS_NONNULL __attribute__ ((__returns_nonnull__))
 1060|       |#else
 1061|       |# define _GL_ATTRIBUTE_RETURNS_NONNULL
 1062|       |#endif
 1063|       |
 1064|       |/* _GL_ATTRIBUTE_SENTINEL(pos) declares that the variadic function expects a
 1065|       |   trailing NULL argument.
 1066|       |   _GL_ATTRIBUTE_SENTINEL () - The last argument is NULL (requires C99).
 1067|       |   _GL_ATTRIBUTE_SENTINEL ((N)) - The (N+1)st argument from the end is NULL.  */
 1068|       |/* Applies to: functions.  */
 1069|       |#if _GL_HAS_ATTRIBUTE (sentinel)
 1070|       |# define _GL_ATTRIBUTE_SENTINEL(pos) __attribute__ ((__sentinel__ pos))
 1071|       |#else
 1072|       |# define _GL_ATTRIBUTE_SENTINEL(pos)
 1073|       |#endif
 1074|       |
 1075|       |/* A helper macro.  Don't use it directly.  */
 1076|       |#if _GL_HAS_ATTRIBUTE (unused)
 1077|       |# define _GL_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
 1078|       |#else
 1079|       |# define _GL_ATTRIBUTE_UNUSED
 1080|       |#endif
 1081|       |
 1082|       |
 1083|       |/* _GL_UNUSED_LABEL; declares that it is not a programming mistake if the
 1084|       |   immediately preceding label is not used.  The compiler should not warn
 1085|       |   if the label is not used.  */
 1086|       |/* Applies to: label (both in C and C++).  */
 1087|       |/* Note that g++ < 4.5 does not support the '__attribute__ ((__unused__)) ;'
 1088|       |   syntax.  But clang does.  */
 1089|       |#if !(defined __cplusplus && !_GL_GNUC_PREREQ (4, 5)) || defined __clang__
 1090|       |# define _GL_UNUSED_LABEL _GL_ATTRIBUTE_UNUSED
 1091|       |#else
 1092|       |# define _GL_UNUSED_LABEL
 1093|       |#endif
 1094|       |
 1095|       |
 1096|       |/* Define to empty if `const' does not conform to ANSI C. */
 1097|       |/* #undef const */
 1098|       |
 1099|       |/* Please see the Gnulib manual for how to use these macros.
 1100|       |
 1101|       |   Suppress extern inline with HP-UX cc, as it appears to be broken; see
 1102|       |   <https://lists.gnu.org/r/bug-texinfo/2013-02/msg00030.html>.
 1103|       |
 1104|       |   Suppress extern inline with Sun C in standards-conformance mode, as it
 1105|       |   mishandles inline functions that call each other.  E.g., for 'inline void f
 1106|       |   (void) { } inline void g (void) { f (); }', c99 incorrectly complains
 1107|       |   'reference to static identifier "f" in extern inline function'.
 1108|       |   This bug was observed with Oracle Developer Studio 12.6
 1109|       |   (Sun C 5.15 SunOS_sparc 2017/05/30).
 1110|       |
 1111|       |   Suppress extern inline (with or without __attribute__ ((__gnu_inline__)))
 1112|       |   on configurations that mistakenly use 'static inline' to implement
 1113|       |   functions or macros in standard C headers like <ctype.h>.  For example,
 1114|       |   if isdigit is mistakenly implemented via a static inline function,
 1115|       |   a program containing an extern inline function that calls isdigit
 1116|       |   may not work since the C standard prohibits extern inline functions
 1117|       |   from calling static functions (ISO C 99 section 6.7.4.(3).
 1118|       |   This bug is known to occur on:
 1119|       |
 1120|       |     OS X 10.8 and earlier; see:
 1121|       |     https://lists.gnu.org/r/bug-gnulib/2012-12/msg00023.html
 1122|       |
 1123|       |     DragonFly; see
 1124|       |     http://muscles.dragonflybsd.org/bulk/clang-master-potential/20141111_102002/logs/ah-tty-0.3.12.log
 1125|       |
 1126|       |     FreeBSD; see:
 1127|       |     https://lists.gnu.org/r/bug-gnulib/2014-07/msg00104.html
 1128|       |
 1129|       |   OS X 10.9 has a macro __header_inline indicating the bug is fixed for C and
 1130|       |   for clang but remains for g++; see <https://trac.macports.org/ticket/41033>.
 1131|       |   Assume DragonFly and FreeBSD will be similar.
 1132|       |
 1133|       |   GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
 1134|       |   inline semantics, unless -fgnu89-inline is used.  It defines a macro
 1135|       |   __GNUC_STDC_INLINE__ to indicate this situation or a macro
 1136|       |   __GNUC_GNU_INLINE__ to indicate the opposite situation.
 1137|       |   GCC 4.2 with -std=c99 or -std=gnu99 implements the GNU C inline
 1138|       |   semantics but warns, unless -fgnu89-inline is used:
 1139|       |     warning: C99 inline functions are not supported; using GNU89
 1140|       |     warning: to disable this warning use -fgnu89-inline or the gnu_inline function attribute
 1141|       |   It defines a macro __GNUC_GNU_INLINE__ to indicate this situation.
 1142|       | */
 1143|       |#if (((defined __APPLE__ && defined __MACH__) \
 1144|       |      || defined __DragonFly__ || defined __FreeBSD__) \
 1145|       |     && (defined __header_inline \
 1146|       |         ? (defined __cplusplus && defined __GNUC_STDC_INLINE__ \
 1147|       |            && ! defined __clang__) \
 1148|       |         : ((! defined _DONT_USE_CTYPE_INLINE_ \
 1149|       |             && (defined __GNUC__ || defined __cplusplus)) \
 1150|       |            || (defined _FORTIFY_SOURCE && 0 < _FORTIFY_SOURCE \
 1151|       |                && defined __GNUC__ && ! defined __cplusplus))))
 1152|       |# define _GL_EXTERN_INLINE_STDHEADER_BUG
 1153|       |#endif
 1154|       |#if ((__GNUC__ \
 1155|       |      ? defined __GNUC_STDC_INLINE__ && __GNUC_STDC_INLINE__ \
 1156|       |      : (199901L <= __STDC_VERSION__ \
 1157|       |         && !defined __HP_cc \
 1158|       |         && !defined __PGI \
 1159|       |         && !(defined __SUNPRO_C && __STDC__))) \
 1160|       |     && !defined _GL_EXTERN_INLINE_STDHEADER_BUG)
 1161|       |# define _GL_INLINE inline
 1162|       |# define _GL_EXTERN_INLINE extern inline
 1163|       |# define _GL_EXTERN_INLINE_IN_USE
 1164|       |#elif (2 < __GNUC__ + (7 <= __GNUC_MINOR__) && !defined __STRICT_ANSI__ \
 1165|       |       && !defined _GL_EXTERN_INLINE_STDHEADER_BUG)
 1166|       |# if defined __GNUC_GNU_INLINE__ && __GNUC_GNU_INLINE__
 1167|       |   /* __gnu_inline__ suppresses a GCC 4.2 diagnostic.  */
 1168|       |#  define _GL_INLINE extern inline __attribute__ ((__gnu_inline__))
 1169|       |# else
 1170|       |#  define _GL_INLINE extern inline
 1171|       |# endif
 1172|       |# define _GL_EXTERN_INLINE extern
 1173|       |# define _GL_EXTERN_INLINE_IN_USE
 1174|       |#else
 1175|       |# define _GL_INLINE _GL_UNUSED static
 1176|       |# define _GL_EXTERN_INLINE _GL_UNUSED static
 1177|       |#endif
 1178|       |
 1179|       |/* In GCC 4.6 (inclusive) to 5.1 (exclusive),
 1180|       |   suppress bogus "no previous prototype for 'FOO'"
 1181|       |   and "no previous declaration for 'FOO'" diagnostics,
 1182|       |   when FOO is an inline function in the header; see
 1183|       |   <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54113> and
 1184|       |   <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63877>.  */
 1185|       |#if __GNUC__ == 4 && 6 <= __GNUC_MINOR__
 1186|       |# if defined __GNUC_STDC_INLINE__ && __GNUC_STDC_INLINE__
 1187|       |#  define _GL_INLINE_HEADER_CONST_PRAGMA
 1188|       |# else
 1189|       |#  define _GL_INLINE_HEADER_CONST_PRAGMA \
 1190|       |     _Pragma ("GCC diagnostic ignored \"-Wsuggest-attribute=const\"")
 1191|       |# endif
 1192|       |# define _GL_INLINE_HEADER_BEGIN \
 1193|       |    _Pragma ("GCC diagnostic push") \
 1194|       |    _Pragma ("GCC diagnostic ignored \"-Wmissing-prototypes\"") \
 1195|       |    _Pragma ("GCC diagnostic ignored \"-Wmissing-declarations\"") \
 1196|       |    _GL_INLINE_HEADER_CONST_PRAGMA
 1197|       |# define _GL_INLINE_HEADER_END \
 1198|       |    _Pragma ("GCC diagnostic pop")
 1199|       |#else
 1200|       |# define _GL_INLINE_HEADER_BEGIN
 1201|       |# define _GL_INLINE_HEADER_END
 1202|       |#endif
 1203|       |
 1204|       |/* A replacement for va_copy, if needed.  */
 1205|       |#define gl_va_copy(a,b) ((a) = (b))
 1206|       |
 1207|       |/* Define to `__inline__' or `__inline' if that's what the C compiler
 1208|       |   calls it, or to nothing if 'inline' is not supported under any name.  */
 1209|       |#ifndef __cplusplus
 1210|       |/* #undef inline */
 1211|       |#endif
 1212|       |
 1213|       |/* Work around a bug in Apple GCC 4.0.1 build 5465: In C99 mode, it supports
 1214|       |   the ISO C 99 semantics of 'extern inline' (unlike the GNU C semantics of
 1215|       |   earlier versions), but does not display it by setting __GNUC_STDC_INLINE__.
 1216|       |   __APPLE__ && __MACH__ test for Mac OS X.
 1217|       |   __APPLE_CC__ tests for the Apple compiler and its version.
 1218|       |   __STDC_VERSION__ tests for the C99 mode.  */
 1219|       |#if defined __APPLE__ && defined __MACH__ && __APPLE_CC__ >= 5465 && !defined __cplusplus && __STDC_VERSION__ >= 199901L && !defined __GNUC_STDC_INLINE__
 1220|       |# define __GNUC_STDC_INLINE__ 1
 1221|       |#endif
 1222|       |
 1223|       |/* _GL_CMP (n1, n2) performs a three-valued comparison on n1 vs. n2, where
 1224|       |   n1 and n2 are expressions without side effects, that evaluate to real
 1225|       |   numbers (excluding NaN).
 1226|       |   It returns
 1227|       |     1  if n1 > n2
 1228|       |     0  if n1 == n2
 1229|       |     -1 if n1 < n2
 1230|       |   The naïve code   (n1 > n2 ? 1 : n1 < n2 ? -1 : 0)  produces a conditional
 1231|       |   jump with nearly all GCC versions up to GCC 10.
 1232|       |   This variant     (n1 < n2 ? -1 : n1 > n2)  produces a conditional with many
 1233|       |   GCC versions up to GCC 9.
 1234|       |   The better code  (n1 > n2) - (n1 < n2)  from Hacker's Delight § 2-9
 1235|       |   avoids conditional jumps in all GCC versions >= 3.4.  */
 1236|       |#define _GL_CMP(n1, n2) (((n1) > (n2)) - ((n1) < (n2)))
 1237|       |
 1238|       |
 1239|       |/* Define to `int' if <sys/types.h> does not define. */
 1240|       |/* #undef mode_t */
 1241|       |
 1242|       |/* Define to the type of st_nlink in struct stat, or a supertype. */
 1243|       |/* #undef nlink_t */
 1244|       |
 1245|       |/* Define as a signed integer type capable of holding a process identifier. */
 1246|       |/* #undef pid_t */
 1247|       |
 1248|       |/* Define to the equivalent of the C99 'restrict' keyword, or to
 1249|       |   nothing if this is not supported.  Do not define if restrict is
 1250|       |   supported only directly.  */
 1251|       |#define restrict __restrict__
 1252|       |/* Work around a bug in older versions of Sun C++, which did not
 1253|       |   #define __restrict__ or support _Restrict or __restrict__
 1254|       |   even though the corresponding Sun C compiler ended up with
 1255|       |   "#define restrict _Restrict" or "#define restrict __restrict__"
 1256|       |   in the previous line.  This workaround can be removed once
 1257|       |   we assume Oracle Developer Studio 12.5 (2016) or later.  */
 1258|       |#if defined __SUNPRO_CC && !defined __RESTRICT && !defined __restrict__
 1259|       |# define _Restrict
 1260|       |# define __restrict__
 1261|       |#endif
 1262|       |
 1263|       |/* Define to `unsigned int' if <sys/types.h> does not define. */
 1264|       |/* #undef size_t */
 1265|       |
 1266|       |/* Define as a signed type of the same size as size_t. */
 1267|       |/* #undef ssize_t */
 1268|       |
 1269|       |
 1270|       |  /* This definition is a duplicate of the one in unitypes.h.
 1271|       |     It is here so that we can cope with an older version of unitypes.h
 1272|       |     that does not contain this definition and that is pre-installed among
 1273|       |     the public header files.  */
 1274|       |  # if defined __restrict \
 1275|       |       || 2 < __GNUC__ + (95 <= __GNUC_MINOR__) \
 1276|       |       || __clang_major__ >= 3
 1277|       |  #  define _UC_RESTRICT __restrict
 1278|       |  # elif 199901L <= __STDC_VERSION__ || defined restrict
 1279|       |  #  define _UC_RESTRICT restrict
 1280|       |  # else
 1281|       |  #  define _UC_RESTRICT
 1282|       |  # endif
 1283|       |  
 1284|       |
 1285|       |/* Define as a macro for copying va_list variables. */
 1286|       |/* #undef va_copy */
 1287|       |
 1288|       |
 1289|       |#endif /*LOUISCFG_H*/
 1290|       |

/home/vito/MASTER_CSI/S2/TER/fuzzing/liblouis/liblouis/internal.h:
    1|       |/* liblouis Braille Translation and Back-Translation Library
    2|       |
    3|       |   Based on the Linux screenreader BRLTTY, copyright (C) 1999-2006 by The
    4|       |   BRLTTY Team
    5|       |
    6|       |   Copyright (C) 2004, 2005, 2006 ViewPlus Technologies, Inc. www.viewplus.com
    7|       |   Copyright (C) 2004, 2005, 2006 JJB Software, Inc. www.jjb-software.com
    8|       |   Copyright (C) 2016 Mike Gray, American Printing House for the Blind
    9|       |   Copyright (C) 2016 Davy Kager, Dedicon
   10|       |
   11|       |   This file is part of liblouis.
   12|       |
   13|       |   liblouis is free software: you can redistribute it and/or modify it
   14|       |   under the terms of the GNU Lesser General Public License as published
   15|       |   by the Free Software Foundation, either version 2.1 of the License, or
   16|       |   (at your option) any later version.
   17|       |
   18|       |   liblouis is distributed in the hope that it will be useful, but
   19|       |   WITHOUT ANY WARRANTY; without even the implied warranty of
   20|       |   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
   21|       |   Lesser General Public License for more details.
   22|       |
   23|       |   You should have received a copy of the GNU Lesser General Public
   24|       |   License along with liblouis. If not, see <http://www.gnu.org/licenses/>.
   25|       |*/
   26|       |
   27|       |/**
   28|       | * @file
   29|       | * @brief Internal API of liblouis
   30|       | */
   31|       |
   32|       |#ifndef __LOUIS_H_
   33|       |#define __LOUIS_H_
   34|       |
   35|       |#ifdef __cplusplus
   36|       |extern "C" {
   37|       |#endif /* __cplusplus */
   38|       |
   39|       |#include <stdio.h>
   40|       |#include "liblouis.h"
   41|       |
   42|       |/* Unlike Windows, Mingw can handle forward slashes as directory
   43|       |   separator, see http://mingw.org/wiki/Posix_path_conversion */
   44|       |#if defined(_WIN32) && !defined(__MINGW32__) && !defined(__MINGW64__)
   45|       |#define PATH_SEP ';'
   46|       |#define DIR_SEP '\\'
   47|       |#else
   48|       |#define PATH_SEP ':'
   49|      0|#define DIR_SEP '/'
   50|       |#endif
   51|       |
   52|       |#ifdef _MSC_VER
   53|       |#define strcasecmp _stricmp
   54|       |#endif
   55|       |
   56|      0|#define NUMVAR 50
   57|      0|#define EMPHMODECHARSSIZE 256
   58|      0|#define NOEMPHCHARSSIZE 256
   59|      0|#define LETSIGNSIZE 256
   60|       |// noletsignbefore and noletsignafter is hardly ever used and usually
   61|       |// only with very few chars, so it only needs a small array
   62|      0|#define LETSIGNBEFORESIZE 64
   63|      0|#define LETSIGNAFTERSIZE 64
   64|      0|#define SEQPATTERNSIZE 128
   65|      0|#define CHARSIZE sizeof(widechar)
   66|      0|#define DEFAULTRULESIZE 50
   67|       |
   68|       |typedef struct intCharTupple {
   69|       |	unsigned long long key;
   70|       |	char value;
   71|       |} intCharTupple;
   72|       |
   73|       |/* HASHNUM must be prime */
   74|      0|#define HASHNUM 1123
   75|       |
   76|       |#define MAXPASS 4
   77|      0|#define MAXSTRING 2048
   78|       |#define MAX_MACRO_VAR 100  // maximal number of variable substitutions a macro can contain
   79|      0|#define MAX_EMPH_CLASSES 10	  // maximal number of emphasis classes
   80|      0|#define MAX_MODES 6			  // maximal number of modes that can be handled
   81|      0|#define MAX_SOURCE_FILES 100  // maximal number of files a table can consist of
   82|       |
   83|       |typedef unsigned int TranslationTableOffset;
   84|       |
   85|       |/* Basic type for translation table data, which carries all alignment
   86|       | * constraints that fields contained in translation table may have.
   87|       | * Notably TranslationTableCharacterAttributes is unsigned long long, so we need
   88|       | * at least this big basic type. */
   89|       |typedef unsigned long long TranslationTableData;
   90|      0|#define OFFSETSIZE sizeof(TranslationTableData)
   91|       |
   92|       |typedef enum {
   93|       |	/* The first 8 are the predefined character classes. They need to be listed first and
   94|       |	   in this order because of how allocateCharacterClasses works. */
   95|       |	CTC_Space = 0x1,
   96|       |	CTC_Letter = 0x2,
   97|       |	CTC_Digit = 0x4,
   98|       |	CTC_Punctuation = 0x8,
   99|       |	CTC_UpperCase = 0x10,
  100|       |	CTC_LowerCase = 0x20,
  101|       |	CTC_Math = 0x40,
  102|       |	CTC_Sign = 0x80,
  103|       |	CTC_LitDigit = 0x100,
  104|       |	CTC_CapsMode = 0x200,
  105|       |	// bit 0x400 used to be taken by CTC_EmphMode
  106|       |	CTC_NumericMode = 0x800,
  107|       |	CTC_NumericNoContract = 0x1000,
  108|       |	CTC_SeqDelimiter = 0x2000,
  109|       |	CTC_SeqBefore = 0x4000,
  110|       |	CTC_SeqAfter = 0x8000,
  111|       |	/* The following 8 are reserved for %0 to %7 (in no particular order) */
  112|       |	/* Be careful with changing these values (and also CTC_EndOfInput) because in
  113|       |	   pattern_compile_expression they are stored in a unsigned int after cutting of the
  114|       |	   16 least significant bits. */
  115|       |	CTC_UserDefined1 = 0x10000,
  116|       |	CTC_UserDefined2 = 0x20000,
  117|       |	CTC_UserDefined3 = 0x40000,
  118|       |	CTC_UserDefined4 = 0x80000,
  119|       |	CTC_UserDefined5 = 0x100000,
  120|       |	CTC_UserDefined6 = 0x200000,
  121|       |	CTC_UserDefined7 = 0x400000,
  122|       |	CTC_UserDefined8 = 0x800000,
  123|       |	CTC_EndOfInput = 0x1000000,	 // only used by pattern matcher
  124|       |	CTC_EmpMatch = 0x2000000,	 // only used in TranslationTableRule->before and
  125|       |								 // TranslationTableRule->after
  126|       |	CTC_MidEndNumericMode = 0x4000000,
  127|       |	/* At least 37 more bits available in a unsigned long long (at least 64 bits). Used
  128|       |	   for custom attributes 9 to 45. These need to be the last values of the enum. */
  129|       |	CTC_UserDefined9 = 0x8000000,
  130|       |	CTC_UserDefined10 = 0x10000000,
  131|       |	CTC_UserDefined11 = 0x20000000,
  132|       |	CTC_UserDefined12 = 0x40000000,
  133|       |} TranslationTableCharacterAttribute;
  134|       |
  135|       |typedef enum {
  136|       |	pass_first = '`',
  137|       |	pass_last = '~',
  138|       |	pass_lookback = '_',
  139|       |	pass_string = '\"',
  140|       |	pass_dots = '@',
  141|       |	pass_omit = '?',
  142|       |	pass_startReplace = '[',
  143|       |	pass_endReplace = ']',
  144|       |	pass_startGroup = '{',
  145|       |	pass_endGroup = '}',
  146|       |	pass_variable = '#',
  147|       |	pass_not = '!',
  148|       |	pass_search = '/',
  149|       |	pass_any = 'a',
  150|       |	pass_digit = 'd',
  151|       |	pass_litDigit = 'D',
  152|       |	pass_letter = 'l',
  153|       |	pass_math = 'm',
  154|       |	pass_punctuation = 'p',
  155|       |	pass_sign = 'S',
  156|       |	pass_space = 's',
  157|       |	pass_uppercase = 'U',
  158|       |	pass_lowercase = 'u',
  159|       |	pass_class1 = 'w',
  160|       |	pass_class2 = 'x',
  161|       |	pass_class3 = 'y',
  162|       |	pass_class4 = 'z',
  163|       |	pass_attributes = '$',
  164|       |	pass_groupstart = '{',
  165|       |	pass_groupend = '}',
  166|       |	pass_groupreplace = ';',
  167|       |	pass_swap = '%',
  168|       |	pass_hyphen = '-',
  169|       |	pass_until = '.',
  170|       |	pass_eq = '=',
  171|       |	pass_lt = '<',
  172|       |	pass_gt = '>',
  173|       |	pass_endTest = 32,
  174|       |	pass_plus = '+',
  175|       |	pass_copy = '*',
  176|       |	pass_leftParen = '(',
  177|       |	pass_rightParen = ')',
  178|       |	pass_comma = ',',
  179|       |	pass_lteq = 130,
  180|       |	pass_gteq = 131,
  181|       |	pass_invalidToken = 132,
  182|       |	pass_noteq = 133,
  183|       |	pass_and = 134,
  184|       |	pass_or = 135,
  185|       |	pass_nameFound = 136,
  186|       |	pass_numberFound = 137,
  187|       |	pass_boolean = 138,
  188|       |	pass_class = 139,
  189|       |	pass_define = 140,
  190|       |	pass_emphasis = 141,
  191|       |	pass_group = 142,
  192|       |	pass_mark = 143,
  193|       |	pass_repGroup = 143,
  194|       |	pass_script = 144,
  195|       |	pass_noMoreTokens = 145,
  196|       |	pass_replace = 146,
  197|       |	pass_if = 147,
  198|       |	pass_then = 148,
  199|       |	pass_all = 255
  200|       |} pass_Codes;
  201|       |
  202|       |typedef unsigned long long TranslationTableCharacterAttributes;
  203|       |
  204|       |typedef struct {
  205|       |	TranslationTableOffset next;
  206|       |	widechar lookFor;
  207|       |	widechar found;
  208|       |} CharDotsMapping;
  209|       |
  210|       |typedef struct {
  211|       |	const char *sourceFile;
  212|       |	int sourceLine;
  213|       |	TranslationTableOffset next;
  214|       |	TranslationTableOffset definitionRule;
  215|       |	TranslationTableOffset otherRules;
  216|       |	TranslationTableCharacterAttributes attributes;
  217|       |	TranslationTableCharacterAttributes mode;
  218|       |	TranslationTableOffset compRule;
  219|       |	widechar value;
  220|       |	TranslationTableOffset basechar;
  221|       |	TranslationTableOffset linked;
  222|       |} TranslationTableCharacter;
  223|       |
  224|       |typedef enum { /* Op codes */
  225|       |	CTO_IncludeFile,
  226|       |	CTO_Locale, /* Deprecated, do not use */
  227|       |	CTO_Undefined,
  228|       |	/* Do not change the order of the following opcodes! */
  229|       |	CTO_CapsLetter,
  230|       |	CTO_BegCapsWord,
  231|       |	CTO_EndCapsWord,
  232|       |	CTO_BegCaps,
  233|       |	CTO_EndCaps,
  234|       |	CTO_BegCapsPhrase,
  235|       |	CTO_EndCapsPhrase,
  236|       |	CTO_LenCapsPhrase,
  237|       |	CTO_ModeLetter,
  238|       |	CTO_BegModeWord,
  239|       |	CTO_EndModeWord,
  240|       |	CTO_BegMode,
  241|       |	CTO_EndMode,
  242|       |	CTO_BegModePhrase,
  243|       |	CTO_EndModePhrase,
  244|       |	CTO_LenModePhrase,
  245|       |	/* End of ordered opcodes */
  246|       |	CTO_LetterSign,
  247|       |	CTO_NoLetsignBefore,
  248|       |	CTO_NoLetsign,
  249|       |	CTO_NoLetsignAfter,
  250|       |	CTO_NumberSign,
  251|       |	CTO_NumericModeChars,
  252|       |	CTO_MidEndNumericModeChars,
  253|       |	CTO_NumericNoContractChars,
  254|       |	CTO_SeqDelimiter,
  255|       |	CTO_SeqBeforeChars,
  256|       |	CTO_SeqAfterChars,
  257|       |	CTO_SeqAfterPattern,
  258|       |	CTO_SeqAfterExpression,
  259|       |	CTO_EmphClass,
  260|       |
  261|       |	/* Do not change the order of the following opcodes! */
  262|       |	CTO_EmphLetter,
  263|       |	CTO_BegEmphWord,
  264|       |	CTO_EndEmphWord,
  265|       |	CTO_BegEmph,
  266|       |	CTO_EndEmph,
  267|       |	CTO_BegEmphPhrase,
  268|       |	CTO_EndEmphPhrase,
  269|       |	CTO_LenEmphPhrase,
  270|       |	/* End of ordered opcodes */
  271|       |
  272|       |	CTO_CapsModeChars,
  273|       |	CTO_EmphModeChars,
  274|       |	CTO_NoEmphChars,
  275|       |	CTO_BegComp,
  276|       |	CTO_EndComp,
  277|       |	CTO_NoContractSign,
  278|       |	CTO_MultInd,
  279|       |	CTO_CompDots,
  280|       |	CTO_Comp6,
  281|       |	CTO_Class,	/* define a character class */
  282|       |	CTO_After,	/* only match if after character in class */
  283|       |	CTO_Before, /* only match if before character in class 30 */
  284|       |	CTO_NoBack,
  285|       |	CTO_NoFor,
  286|       |	CTO_EmpMatchBefore,
  287|       |	CTO_EmpMatchAfter,
  288|       |	CTO_SwapCc,
  289|       |	CTO_SwapCd,
  290|       |	CTO_SwapDd,
  291|       |	CTO_Space,
  292|       |	CTO_Digit,
  293|       |	CTO_Punctuation,
  294|       |	CTO_Math,
  295|       |	CTO_Sign,
  296|       |	CTO_Letter,
  297|       |	CTO_UpperCase,
  298|       |	CTO_LowerCase,
  299|       |	CTO_Grouping,
  300|       |	CTO_UpLow,
  301|       |	CTO_LitDigit,
  302|       |	CTO_Display,
  303|       |	CTO_Replace,
  304|       |	CTO_Context,
  305|       |	CTO_Correct,
  306|       |	CTO_Pass2,
  307|       |	CTO_Pass3,
  308|       |	CTO_Pass4,
  309|       |	CTO_Repeated,
  310|       |	CTO_RepWord,
  311|       |	CTO_RepEndWord,
  312|       |	CTO_CapsNoCont,
  313|       |	CTO_Always,
  314|       |	CTO_ExactDots,
  315|       |	CTO_NoCross,
  316|       |	CTO_Syllable,
  317|       |	CTO_NoCont,
  318|       |	CTO_CompBrl,
  319|       |	CTO_Literal,
  320|       |	CTO_LargeSign,
  321|       |	CTO_WholeWord,
  322|       |	CTO_PartWord,
  323|       |	CTO_JoinNum,
  324|       |	CTO_JoinableWord,
  325|       |	CTO_LowWord,
  326|       |	CTO_Contraction,
  327|       |	CTO_SuffixableWord, /** whole word or beginning of word */
  328|       |	CTO_PrefixableWord, /** whole word or end of word */
  329|       |	CTO_BegWord,		/** beginning of word only */
  330|       |	CTO_BegMidWord,		/** beginning or middle of word */
  331|       |	CTO_MidWord,		/** middle of word only 20 */
  332|       |	CTO_MidEndWord,		/** middle or end of word */
  333|       |	CTO_EndWord,		/** end of word only */
  334|       |	CTO_PrePunc,		/** punctuation in string at beginning of word */
  335|       |	CTO_PostPunc,		/** punctuation in string at end of word */
  336|       |	CTO_BegNum,			/** beginning of number */
  337|       |	CTO_MidNum,			/** middle of number, e.g., decimal point */
  338|       |	CTO_EndNum,			/** end of number */
  339|       |	CTO_DecPoint,
  340|       |	CTO_Hyphen,
  341|       |	// CTO_Apostrophe,
  342|       |	// CTO_Initial,
  343|       |	CTO_NoBreak,
  344|       |	CTO_Match,
  345|       |	CTO_BackMatch,
  346|       |	CTO_Attribute,
  347|       |	CTO_Base,
  348|       |	CTO_Macro,
  349|       |	CTO_None,
  350|       |
  351|       |	/* More internal opcodes */
  352|       |	CTO_LetterRule,
  353|       |	CTO_NumberRule,
  354|       |	CTO_NoContractRule,
  355|       |
  356|       |	/* Start of (16 x 8) internal opcodes values
  357|       |	 * Do not change the order of the following opcodes! */
  358|       |	CTO_CapsLetterRule,
  359|       |	CTO_BegCapsWordRule,
  360|       |	CTO_EndCapsWordRule,
  361|       |	CTO_BegCapsRule,
  362|       |	CTO_EndCapsRule,
  363|       |	CTO_BegCapsPhraseRule,
  364|       |	CTO_EndCapsPhraseBeforeRule,
  365|       |	CTO_EndCapsPhraseAfterRule,
  366|       |	CTO_Mode2LetterRule,
  367|       |	CTO_BegMode2WordRule,
  368|       |	CTO_EndMode2WordRule,
  369|       |	CTO_BegMode2Rule,
  370|       |	CTO_EndMode2Rule,
  371|       |	CTO_BegMode2PhraseRule,
  372|       |	CTO_EndMode2PhraseBeforeRule,
  373|       |	CTO_EndMode2PhraseAfterRule,
  374|       |	CTO_Mode3LetterRule,
  375|       |	CTO_BegMode3WordRule,
  376|       |	CTO_EndMode3WordRule,
  377|       |	CTO_BegMode3Rule,
  378|       |	CTO_EndMode3Rule,
  379|       |	CTO_BegMode3PhraseRule,
  380|       |	CTO_EndMode3PhraseBeforeRule,
  381|       |	CTO_EndMode3PhraseAfterRule,
  382|       |	CTO_Mode4LetterRule,
  383|       |	CTO_BegMode4WordRule,
  384|       |	CTO_EndMode4WordRule,
  385|       |	CTO_BegMode4Rule,
  386|       |	CTO_EndMode4Rule,
  387|       |	CTO_BegMode4PhraseRule,
  388|       |	CTO_EndMode4PhraseBeforeRule,
  389|       |	CTO_EndMode4PhraseAfterRule,
  390|       |	CTO_Mode5LetterRule,
  391|       |	CTO_BegMode5WordRule,
  392|       |	CTO_EndMode5WordRule,
  393|       |	CTO_BegMode5Rule,
  394|       |	CTO_EndMode5Rule,
  395|       |	CTO_BegMode5PhraseRule,
  396|       |	CTO_EndMode5PhraseBeforeRule,
  397|       |	CTO_EndMode5PhraseAfterRule,
  398|       |	CTO_Mode6LetterRule,
  399|       |	CTO_BegMode6WordRule,
  400|       |	CTO_EndMode6WordRule,
  401|       |	CTO_BegMode6Rule,
  402|       |	CTO_EndMode6Rule,
  403|       |	CTO_BegMode6PhraseRule,
  404|       |	CTO_EndMode6PhraseBeforeRule,
  405|       |	CTO_EndMode6PhraseAfterRule,
  406|       |	CTO_Emph1LetterRule,
  407|       |	CTO_BegEmph1WordRule,
  408|       |	CTO_EndEmph1WordRule,
  409|       |	CTO_BegEmph1Rule,
  410|       |	CTO_EndEmph1Rule,
  411|       |	CTO_BegEmph1PhraseRule,
  412|       |	CTO_EndEmph1PhraseBeforeRule,
  413|       |	CTO_EndEmph1PhraseAfterRule,
  414|       |	CTO_Emph2LetterRule,
  415|       |	CTO_BegEmph2WordRule,
  416|       |	CTO_EndEmph2WordRule,
  417|       |	CTO_BegEmph2Rule,
  418|       |	CTO_EndEmph2Rule,
  419|       |	CTO_BegEmph2PhraseRule,
  420|       |	CTO_EndEmph2PhraseBeforeRule,
  421|       |	CTO_EndEmph2PhraseAfterRule,
  422|       |	CTO_Emph3LetterRule,
  423|       |	CTO_BegEmph3WordRule,
  424|       |	CTO_EndEmph3WordRule,
  425|       |	CTO_BegEmph3Rule,
  426|       |	CTO_EndEmph3Rule,
  427|       |	CTO_BegEmph3PhraseRule,
  428|       |	CTO_EndEmph3PhraseBeforeRule,
  429|       |	CTO_EndEmph3PhraseAfterRule,
  430|       |	CTO_Emph4LetterRule,
  431|       |	CTO_BegEmph4WordRule,
  432|       |	CTO_EndEmph4WordRule,
  433|       |	CTO_BegEmph4Rule,
  434|       |	CTO_EndEmph4Rule,
  435|       |	CTO_BegEmph4PhraseRule,
  436|       |	CTO_EndEmph4PhraseBeforeRule,
  437|       |	CTO_EndEmph4PhraseAfterRule,
  438|       |	CTO_Emph5LetterRule,
  439|       |	CTO_BegEmph5WordRule,
  440|       |	CTO_EndEmph5WordRule,
  441|       |	CTO_BegEmph5Rule,
  442|       |	CTO_EndEmph5Rule,
  443|       |	CTO_BegEmph5PhraseRule,
  444|       |	CTO_EndEmph5PhraseBeforeRule,
  445|       |	CTO_EndEmph5PhraseAfterRule,
  446|       |	CTO_Emph6LetterRule,
  447|       |	CTO_BegEmph6WordRule,
  448|       |	CTO_EndEmph6WordRule,
  449|       |	CTO_BegEmph6Rule,
  450|       |	CTO_EndEmph6Rule,
  451|       |	CTO_BegEmph6PhraseRule,
  452|       |	CTO_EndEmph6PhraseBeforeRule,
  453|       |	CTO_EndEmph6PhraseAfterRule,
  454|       |	CTO_Emph7LetterRule,
  455|       |	CTO_BegEmph7WordRule,
  456|       |	CTO_EndEmph7WordRule,
  457|       |	CTO_BegEmph7Rule,
  458|       |	CTO_EndEmph7Rule,
  459|       |	CTO_BegEmph7PhraseRule,
  460|       |	CTO_EndEmph7PhraseBeforeRule,
  461|       |	CTO_EndEmph7PhraseAfterRule,
  462|       |	CTO_Emph8LetterRule,
  463|       |	CTO_BegEmph8WordRule,
  464|       |	CTO_EndEmph8WordRule,
  465|       |	CTO_BegEmph8Rule,
  466|       |	CTO_EndEmph8Rule,
  467|       |	CTO_BegEmph8PhraseRule,
  468|       |	CTO_EndEmph8PhraseBeforeRule,
  469|       |	CTO_EndEmph8PhraseAfterRule,
  470|       |	CTO_Emph9LetterRule,
  471|       |	CTO_BegEmph9WordRule,
  472|       |	CTO_EndEmph9WordRule,
  473|       |	CTO_BegEmph9Rule,
  474|       |	CTO_EndEmph9Rule,
  475|       |	CTO_BegEmph9PhraseRule,
  476|       |	CTO_EndEmph9PhraseBeforeRule,
  477|       |	CTO_EndEmph9PhraseAfterRule,
  478|       |	CTO_Emph10LetterRule,
  479|       |	CTO_BegEmph10WordRule,
  480|       |	CTO_EndEmph10WordRule,
  481|       |	CTO_BegEmph10Rule,
  482|       |	CTO_EndEmph10Rule,
  483|       |	CTO_BegEmph10PhraseRule,
  484|       |	CTO_EndEmph10PhraseBeforeRule,
  485|       |	CTO_EndEmph10PhraseAfterRule,
  486|       |	/* End of ordered (16 x 8) internal opcodes */
  487|       |
  488|       |	CTO_BegCompRule,
  489|       |	CTO_EndCompRule,
  490|       |	CTO_CapsNoContRule,
  491|       |	CTO_All
  492|       |} TranslationTableOpcode;
  493|       |
  494|       |typedef struct {
  495|       |	const char *sourceFile;
  496|       |	int sourceLine;
  497|       |	TranslationTableOffset charsnext;			/** next chars entry */
  498|       |	TranslationTableOffset dotsnext;			/** next dots entry */
  499|       |	TranslationTableCharacterAttributes after;	/** character types which must follow */
  500|       |	TranslationTableCharacterAttributes before; /** character types which must precede */
  501|       |	TranslationTableOffset patterns;			/** before and after patterns */
  502|       |	TranslationTableOpcode opcode; /** rule for testing validity of replacement */
  503|       |	char nocross;
  504|       |	short charslen;						 /** length of string to be replaced */
  505|       |	short dotslen;						 /** length of replacement string */
  506|       |	widechar charsdots[DEFAULTRULESIZE]; /** find and replacement strings */
  507|       |} TranslationTableRule;
  508|       |
  509|       |typedef struct /* state transition */
  510|       |{
  511|       |	widechar ch;
  512|       |	widechar newState;
  513|       |} HyphenationTrans;
  514|       |
  515|       |typedef union {
  516|       |	HyphenationTrans *pointer;
  517|       |	TranslationTableOffset offset;
  518|       |} PointOff;
  519|       |
  520|       |typedef struct /* one state */
  521|       |{
  522|       |	PointOff trans;
  523|       |	TranslationTableOffset hyphenPattern;
  524|       |	widechar fallbackState;
  525|       |	widechar numTrans;
  526|       |} HyphenationState;
  527|       |
  528|       |typedef struct CharacterClass {
  529|       |	struct CharacterClass *next;
  530|       |	TranslationTableCharacterAttributes attribute;
  531|       |	widechar length;
  532|       |	widechar name[1];
  533|       |} CharacterClass;
  534|       |
  535|       |typedef struct RuleName {
  536|       |	struct RuleName *next;
  537|       |	TranslationTableOffset ruleOffset;
  538|       |	widechar length;
  539|       |	widechar name[1];
  540|       |} RuleName;
  541|       |
  542|       |typedef struct {
  543|       |	/* either typeform or mode should be set, not both */
  544|       |	formtype typeform; /* corresponding value in "typeforms" enum */
  545|       |	TranslationTableCharacterAttributes mode; /* corresponding character attribute */
  546|       |	unsigned int value;						  /* bit field that contains a single "1" */
  547|       |	unsigned short
  548|       |			rule; /* emphasis rules (index in emphRules, emphModeChars and noEmphChars) */
  549|       |} EmphasisClass;
  550|       |
  551|       |typedef struct {
  552|       |	TranslationTableOffset tableSize;
  553|       |	TranslationTableOffset bytesUsed;
  554|       |	TranslationTableOffset charToDots[HASHNUM];
  555|       |	TranslationTableOffset dotsToChar[HASHNUM];
  556|       |	TranslationTableData ruleArea[1]; /** Space for storing all rules and values */
  557|       |} DisplayTableHeader;
  558|       |
  559|       |/**
  560|       | * Translation table header
  561|       | */
  562|       |typedef struct { /* translation table */
  563|       |
  564|       |	/* state needed during compilation */
  565|       |	TranslationTableOffset tableSize;
  566|       |	TranslationTableOffset bytesUsed;
  567|       |	CharacterClass *characterClasses;
  568|       |	TranslationTableCharacterAttributes nextCharacterClassAttribute;
  569|       |	TranslationTableCharacterAttributes nextNumberedCharacterClassAttribute;
  570|       |	RuleName *ruleNames;
  571|       |	TranslationTableCharacterAttributes
  572|       |			numberedAttributes[8]; /* attributes 0-7 used in match rules (could also be
  573|       |								   stored in `characterClasses', but this is slightly
  574|       |								   faster) */
  575|       |	int usesAttributeOrClass;	   /* 1 = attribute, 2 = class */
  576|       |	char *sourceFiles[MAX_SOURCE_FILES + 1];
  577|       |
  578|       |	/* needed for translation or other api functions */
  579|       |	int finalized;
  580|       |	int capsNoCont;
  581|       |	int numPasses;
  582|       |	int corrections;
  583|       |	int syllables;
  584|       |	int usesSequences;
  585|       |	int usesNumericMode;
  586|       |	int hasCapsModeChars;
  587|       |	TranslationTableOffset undefined;
  588|       |	TranslationTableOffset letterSign;
  589|       |	TranslationTableOffset numberSign;
  590|       |	TranslationTableOffset noContractSign;
  591|       |	widechar seqPatterns[SEQPATTERNSIZE];
  592|       |	char *emphClassNames[MAX_EMPH_CLASSES];
  593|       |	EmphasisClass emphClasses[MAX_EMPH_CLASSES];
  594|       |	EmphasisClass modes[MAX_MODES];
  595|       |	int seqPatternsCount;
  596|       |	widechar seqAfterExpression[SEQPATTERNSIZE];
  597|       |	int seqAfterExpressionLength;
  598|       |	TranslationTableOffset emphRules[MAX_EMPH_CLASSES + MAX_MODES]
  599|       |									[9]; /* 9 is the size of the EmphCodeOffset enum */
  600|       |	TranslationTableOffset begComp;
  601|       |	TranslationTableOffset endComp;
  602|       |	TranslationTableOffset hyphenStatesArray;
  603|       |	widechar noLetsignBefore[LETSIGNBEFORESIZE];
  604|       |	int noLetsignBeforeCount;
  605|       |	widechar noLetsign[LETSIGNSIZE];
  606|       |	int noLetsignCount;
  607|       |	widechar noLetsignAfter[LETSIGNAFTERSIZE];
  608|       |	int noLetsignAfterCount;
  609|       |	widechar emphModeChars[MAX_EMPH_CLASSES] /* does not include caps: capsmodechars are
  610|       |											  * currently stored as character attributes
  611|       |											  */
  612|       |						  [EMPHMODECHARSSIZE + 1];
  613|       |	widechar noEmphChars[MAX_EMPH_CLASSES] /* does not include caps */
  614|       |						[NOEMPHCHARSSIZE + 1];
  615|       |	TranslationTableOffset characters[HASHNUM]; /** Character definitions */
  616|       |	TranslationTableOffset dots[HASHNUM];		/** Dot definitions */
  617|       |	TranslationTableOffset forPassRules[MAXPASS + 1];
  618|       |	TranslationTableOffset backPassRules[MAXPASS + 1];
  619|       |	TranslationTableOffset forRules[HASHNUM];  /** chains of forward rules */
  620|       |	TranslationTableOffset backRules[HASHNUM]; /** Chains of backward rules */
  621|       |	TranslationTableData ruleArea[1]; /** Space for storing all rules and values */
  622|       |}  TranslationTableHeader;
  623|       |
  624|       |typedef enum {
  625|       |	alloc_typebuf,
  626|       |	alloc_wordBuffer,
  627|       |	alloc_emphasisBuffer,
  628|       |	alloc_destSpacing,
  629|       |	alloc_passbuf,
  630|       |	alloc_posMapping1,
  631|       |	alloc_posMapping2,
  632|       |	alloc_posMapping3
  633|       |} AllocBuf;
  634|       |
  635|      0|#define MAXPASSBUF 3
  636|       |
  637|       |typedef enum {
  638|       |	begPhraseOffset = 0,
  639|       |	endPhraseBeforeOffset = 1,
  640|       |	endPhraseAfterOffset = 2,
  641|       |	begOffset = 3,
  642|       |	endOffset = 4,
  643|       |	letterOffset = 5,
  644|       |	begWordOffset = 6,
  645|       |	endWordOffset = 7,
  646|       |	lenPhraseOffset = 8
  647|       |} EmphCodeOffset;
  648|       |
  649|       |/* Grouping the begin, end, word and symbol bits and using the type of
  650|       | * a single bit group for representing the emphasis classes allows us
  651|       | * to do simple bit operations. */
  652|       |
  653|       |/* fields contain sums of EmphasisClass.value */
  654|       |/* MAX_EMPH_CLASSES + MAX_MODES may not exceed 16 */
  655|       |typedef struct {
  656|       |	unsigned int begin : 16;
  657|       |	unsigned int end : 16;
  658|       |	unsigned int word : 16;
  659|       |	unsigned int symbol : 16;
  660|       |} EmphasisInfo;
  661|       |
  662|       |typedef enum { noEncoding, bigEndian, littleEndian, ascii8 } EncodingType;
  663|       |
  664|       |typedef struct {
  665|       |	const char *fileName;
  666|       |	const char *sourceFile;
  667|       |	FILE *in;
  668|       |	int lineNumber;
  669|       |	EncodingType encoding;
  670|       |	int status;
  671|       |	int linelen;
  672|       |	int linepos;
  673|       |	int checkencoding[2];
  674|       |	widechar line[MAXSTRING];
  675|       |} FileInfo;
  676|       |
  677|       |/* The following function definitions are hooks into
  678|       | * compileTranslationTable.c. Some are used by other library modules.
  679|       | * Others are used by tools like lou_allround.c and lou_debug.c. */
  680|       |
  681|       |/**
  682|       | * Comma separated list of directories to search for tables.
  683|       | */
  684|       |char *EXPORT_CALL
  685|       |_lou_getTablePath(void);
  686|       |
  687|       |/**
  688|       | * Resolve tableList against base.
  689|       | */
  690|       |char **EXPORT_CALL
  691|       |_lou_resolveTable(const char *tableList, const char *base);
  692|       |
  693|       |/**
  694|       | * The default table resolver
  695|       | */
  696|       |char **EXPORT_CALL
  697|       |_lou_defaultTableResolver(const char *tableList, const char *base);
  698|       |
  699|       |/**
  700|       | * Return single-cell dot pattern corresponding to a character.
  701|       | * TODO: move to commonTranslationFunctions.c
  702|       | */
  703|       |widechar EXPORT_CALL
  704|       |_lou_getDotsForChar(widechar c, const DisplayTableHeader *table);
  705|       |
  706|       |/**
  707|       | * Return character corresponding to a single-cell dot pattern.
  708|       | * TODO: move to commonTranslationFunctions.c
  709|       | */
  710|       |widechar EXPORT_CALL
  711|       |_lou_getCharForDots(widechar d, const DisplayTableHeader *table);
  712|       |
  713|       |void EXPORT_CALL
  714|       |_lou_getTable(const char *tableList, const char *displayTableList,
  715|       |		const TranslationTableHeader **translationTable,
  716|       |		const DisplayTableHeader **displayTable);
  717|       |
  718|       |const TranslationTableHeader *EXPORT_CALL
  719|       |_lou_getTranslationTable(const char *tableList);
  720|       |
  721|       |const DisplayTableHeader *EXPORT_CALL
  722|       |_lou_getDisplayTable(const char *tableList);
  723|       |
  724|       |int EXPORT_CALL
  725|       |_lou_compileTranslationRule(const char *tableList, const char *inString);
  726|       |
  727|       |int EXPORT_CALL
  728|       |_lou_compileDisplayRule(const char *tableList, const char *inString);
  729|       |
  730|       |/**
  731|       | * Allocate memory for internal buffers
  732|       | *
  733|       | * Used by lou_translateString.c and lou_backTranslateString.c ONLY
  734|       | * to allocate memory for internal buffers.
  735|       | * TODO: move to utils.c
  736|       | */
  737|       |void *EXPORT_CALL
  738|       |_lou_allocMem(AllocBuf buffer, int index, int srcmax, int destmax);
  739|       |
  740|       |/**
  741|       | * Hash function for character strings
  742|       | *
  743|       | * @param lowercase Whether to convert the string to lowercase because
  744|       | *                  making the hash of it.
  745|       | */
  746|       |unsigned long int EXPORT_CALL
  747|       |_lou_stringHash(const widechar *c, int lowercase, const TranslationTableHeader *table);
  748|       |
  749|       |/**
  750|       | * Hash function for single characters
  751|       | */
  752|       |unsigned long int EXPORT_CALL
  753|       |_lou_charHash(widechar c);
  754|       |
  755|       |/**
  756|       | * Return a string in the same format as the characters operand in opcodes
  757|       | */
  758|       |const char *EXPORT_CALL
  759|       |_lou_showString(widechar const *chars, int length, int forceHex);
  760|       |
  761|       |/**
  762|       | * Print out dot numbers
  763|       | *
  764|       | * @return a string containing the dot numbers. The longest possible
  765|       | * output is "\123456789ABCDEF0/"
  766|       | */
  767|       |const char *EXPORT_CALL
  768|       |_lou_unknownDots(widechar dots);
  769|       |
  770|       |/**
  771|       | * Return a character string in the format of the dots operand
  772|       | */
  773|       |const char *EXPORT_CALL
  774|       |_lou_showDots(widechar const *dots, int length);
  775|       |
  776|       |/**
  777|       | * Return a character string where the attributes are indicated
  778|       | * by the attribute letters used in multipass opcodes
  779|       | */
  780|       |char *EXPORT_CALL
  781|       |_lou_showAttributes(TranslationTableCharacterAttributes a);
  782|       |
  783|       |/**
  784|       | * Return number of the opcode
  785|       | *
  786|       | * @param toFind the opcodes
  787|       | */
  788|       |TranslationTableOpcode EXPORT_CALL
  789|       |_lou_findOpcodeNumber(const char *tofind);
  790|       |
  791|       |/**
  792|       | * Return the name of the opcode associated with an opcode number
  793|       | *
  794|       | * @param opcode an opcode
  795|       | */
  796|       |const char *EXPORT_CALL
  797|       |_lou_findOpcodeName(TranslationTableOpcode opcode);
  798|       |
  799|       |/**
  800|       | * Convert string to wide characters
  801|       | *
  802|       | * Takes a character string and produces a sequence of wide characters.
  803|       | * Opposite of _lou_showString.
  804|       | *
  805|       | * @param inString the input string
  806|       | * @param outString the output wide char sequence
  807|       | * @return length of the widechar sequence.
  808|       | */
  809|       |int EXPORT_CALL
  810|       |_lou_extParseChars(const char *inString, widechar *outString);
  811|       |
  812|       |/**
  813|       | * Convert string to wide characters containing dot patterns
  814|       | *
  815|       | * Takes a character string and produces a sequence of wide characters
  816|       | * containing dot patterns. Opposite of _lou_showDots.
  817|       | * @param inString the input string
  818|       | * @param outString the output wide char sequence
  819|       | * @return length of the widechar sequence.
  820|       | */
  821|       |int EXPORT_CALL
  822|       |_lou_extParseDots(const char *inString, widechar *outString);
  823|       |
  824|       |int EXPORT_CALL
  825|       |_lou_translate(const char *tableList, const char *displayTableList, const widechar *inbuf,
  826|       |		int *inlen, widechar *outbuf, int *outlen, formtype *typeform, char *spacing,
  827|       |		int *outputPos, int *inputPos, int *cursorPos, int mode,
  828|       |		const TranslationTableRule **rules, int *rulesLen);
  829|       |
  830|       |int EXPORT_CALL
  831|       |_lou_backTranslate(const char *tableList, const char *displayTableList,
  832|       |		const widechar *inbuf, int *inlen, widechar *outbuf, int *outlen,
  833|       |		formtype *typeform, char *spacing, int *outputPos, int *inputPos, int *cursorPos,
  834|       |		int mode, const TranslationTableRule **rules, int *rulesLen);
  835|       |
  836|       |void EXPORT_CALL
  837|       |_lou_resetPassVariables(void);
  838|       |
  839|       |int EXPORT_CALL
  840|       |_lou_handlePassVariableTest(const widechar *instructions, int *IC, int *itsTrue);
  841|       |
  842|       |int EXPORT_CALL
  843|       |_lou_handlePassVariableAction(const widechar *instructions, int *IC);
  844|       |
  845|       |int EXPORT_CALL
  846|       |_lou_pattern_compile(const widechar *input, const int input_max, widechar *expr_data,
  847|       |		const int expr_max, TranslationTableHeader *table, const FileInfo *nested);
  848|       |
  849|       |void EXPORT_CALL
  850|       |_lou_pattern_reverse(widechar *expr_data);
  851|       |
  852|       |int EXPORT_CALL
  853|       |_lou_pattern_check(const widechar *input, const int input_start, const int input_minmax,
  854|       |		const int input_dir, const widechar *expr_data,
  855|       |		const TranslationTableHeader *table);
  856|       |
  857|       |/**
  858|       | * Read a line of widechar's from an input file
  859|       | */
  860|       |int EXPORT_CALL
  861|       |_lou_getALine(FileInfo *info);
  862|       |
  863|       |#ifdef DEBUG
  864|       |/* Can be inserted in code to be used as a breakpoint in gdb */
  865|       |void EXPORT_CALL
  866|       |_lou_debugHook(void);
  867|       |#endif
  868|       |
  869|       |/**
  870|       | * Print an out-of-memory message and exit
  871|       | */
  872|       |void EXPORT_CALL
  873|       |_lou_outOfMemory(void);
  874|       |
  875|       |/**
  876|       | * Helper for logging a widechar buffer
  877|       | */
  878|       |void EXPORT_CALL
  879|       |_lou_logWidecharBuf(logLevels level, const char *msg, const widechar *wbuf, int wlen);
  880|       |
  881|       |void EXPORT_CALL
  882|       |_lou_logMessage(logLevels level, const char *format, ...);
  883|       |
  884|       |extern int translation_direction;
  885|       |
  886|       |/**
  887|       | * Return 1 if given translation mode is valid. Return 0 otherwise.
  888|       | */
  889|       |int EXPORT_CALL
  890|       |_lou_isValidMode(int mode);
  891|       |
  892|       |/**
  893|       | * Return the default braille representation for a character.
  894|       | */
  895|       |widechar EXPORT_CALL
  896|       |_lou_charToFallbackDots(widechar c);
  897|       |
  898|       |static inline int
  899|      0|isASCII(widechar c) {
  900|      0|	return (c >= 0X20) && (c < 0X7F);
  901|      0|}
  ------------------
  | Unexecuted instantiation: compileTranslationTable.c:isASCII
  ------------------
  | Unexecuted instantiation: lou_translateString.c:isASCII
  ------------------
  | Unexecuted instantiation: lou_backTranslateString.c:isASCII
  ------------------
  | Unexecuted instantiation: commonTranslationFunctions.c:isASCII
  ------------------
  | Unexecuted instantiation: pattern.c:isASCII
  ------------------
  | Unexecuted instantiation: logging.c:isASCII
  ------------------
  | Unexecuted instantiation: utils.c:isASCII
  ------------------
  902|       |
  903|       |#ifdef __cplusplus
  904|       |}
  905|       |#endif /* __cplusplus */
  906|       |
  907|       |#endif /* __LOUIS_H_ */

/home/vito/MASTER_CSI/S2/TER/fuzzing/liblouis/liblouis/liblouis.h:
    1|       |/* liblouis Braille Translation and Back-Translation Library
    2|       |
    3|       |   Based on the Linux screenreader BRLTTY, copyright (C) 1999-2006 by The
    4|       |   BRLTTY Team
    5|       |
    6|       |   Copyright (C) 2004, 2005, 2006 ViewPlus Technologies, Inc. www.viewplus.com
    7|       |   Copyright (C) 2004, 2005, 2006 JJB Software, Inc. www.jjb-software.com
    8|       |   Copyright (C) 2016 Mike Gray, American Printing House for the Blind
    9|       |   Copyright (C) 2016 Davy Kager, Dedicon
   10|       |
   11|       |   This file is part of liblouis.
   12|       |
   13|       |   liblouis is free software: you can redistribute it and/or modify it
   14|       |   under the terms of the GNU Lesser General Public License as published
   15|       |   by the Free Software Foundation, either version 2.1 of the License, or
   16|       |   (at your option) any later version.
   17|       |
   18|       |   liblouis is distributed in the hope that it will be useful, but
   19|       |   WITHOUT ANY WARRANTY; without even the implied warranty of
   20|       |   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
   21|       |   Lesser General Public License for more details.
   22|       |
   23|       |   You should have received a copy of the GNU Lesser General Public
   24|       |   License along with liblouis. If not, see <http://www.gnu.org/licenses/>.
   25|       |*/
   26|       |
   27|       |/**
   28|       | * @file
   29|       | * @brief Public API of liblouis
   30|       | */
   31|       |
   32|       |#ifndef __LIBLOUIS_H_
   33|       |#define __LIBLOUIS_H_
   34|       |#ifdef __cplusplus
   35|       |extern "C" {
   36|       |#endif /* __cplusplus */
   37|       |
   38|       |// clang-format interacts badly with @foo@
   39|       |// clang-format off
   40|       |typedef unsigned short int widechar;
   41|       |// clang-format on
   42|       |typedef unsigned short formtype;
   43|       |
   44|       |#ifdef _MSC_VER
   45|       |#ifdef _EXPORTING
   46|       |#define LIBLOUIS_API __declspec(dllexport)
   47|       |#else
   48|       |#define LIBLOUIS_API __declspec(dllimport)
   49|       |#endif
   50|       |#else
   51|       |#define LIBLOUIS_API
   52|       |#endif
   53|       |
   54|       |#ifdef __EMSCRIPTEN__
   55|       |#include "emscripten.h"
   56|       |#define EXPORT_CALL EMSCRIPTEN_KEEPALIVE
   57|       |#elif defined(_WIN32)
   58|       |#define EXPORT_CALL __stdcall
   59|       |LIBLOUIS_API
   60|       |char *EXPORT_CALL
   61|       |lou_getProgramPath(void);
   62|       |#else
   63|       |#define EXPORT_CALL
   64|       |#endif
   65|       |
   66|       |typedef enum {
   67|       |	plain_text = 0x0000,
   68|       |	emph_1 = 0x0001,
   69|       |	emph_2 = 0x0002,
   70|       |	emph_3 = 0x0004,
   71|       |	emph_4 = 0x0008,
   72|       |	emph_5 = 0x0010,
   73|       |	emph_6 = 0x0020,
   74|       |	emph_7 = 0x0040,
   75|       |	emph_8 = 0x0080,
   76|       |	emph_9 = 0x0100,
   77|       |	emph_10 = 0x0200,
   78|       |	computer_braille = 0x0400,
   79|       |	no_translate = 0x0800,
   80|       |	no_contract = 0x1000,
   81|       |	// SYLLABLE_MARKER_1  0x2000,
   82|       |	// SYLLABLE_MARKER_1  0x4000
   83|       |	// CAPSEMPH  0x4000
   84|       |} typeforms;
   85|       |
   86|      0|#define italic emph_1
   87|       |#define underline emph_2
   88|       |#define bold emph_3
   89|       |
   90|       |#define comp_emph_1 emph_1
   91|       |#define comp_emph_2 emph_2
   92|       |#define comp_emph_3 emph_3
   93|       |
   94|       |#define EMPH_NAME_BOLD "bold"
   95|       |#define EMPH_NAME_ITALIC "italic"
   96|       |#define EMPH_NAME_UNDERLINE "underline"
   97|       |
   98|       |typedef enum {
   99|       |	noContractions = 1,
  100|       |	compbrlAtCursor = 2,
  101|       |	dotsIO = 4,
  102|       |	// for historic reasons 8 and 16 are free
  103|       |	compbrlLeftCursor = 32,
  104|       |	ucBrl = 64,
  105|       |	noUndefined = 128,
  106|       |	partialTrans = 256
  107|       |} translationModes;
  108|       |
  109|       |#define noUndefinedDots noUndefined
  110|       |
  111|       |LIBLOUIS_API
  112|       |const char *EXPORT_CALL
  113|       |lou_version(void);
  114|       |
  115|       |/**
  116|       | * Return the size of widechar
  117|       | */
  118|       |LIBLOUIS_API
  119|       |int EXPORT_CALL
  120|       |lou_charSize(void);
  121|       |
  122|       |LIBLOUIS_API
  123|       |int EXPORT_CALL
  124|       |lou_translateString(const char *tableList, const widechar *inbuf, int *inlen,
  125|       |		widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int mode);
  126|       |
  127|       |LIBLOUIS_API
  128|       |int EXPORT_CALL
  129|       |lou_translate(const char *tableList, const widechar *inbuf, int *inlen, widechar *outbuf,
  130|       |		int *outlen, formtype *typeform, char *spacing, int *outputPos, int *inputPos,
  131|       |		int *cursorPos, int mode);
  132|       |
  133|       |LIBLOUIS_API
  134|       |int EXPORT_CALL
  135|       |lou_translatePrehyphenated(const char *tableList, const widechar *inbuf, int *inlen,
  136|       |		widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,
  137|       |		int *inputPos, int *cursorPos, char *inputHyphens, char *outputHyphens, int mode);
  138|       |
  139|       |LIBLOUIS_API
  140|       |int EXPORT_CALL
  141|       |lou_hyphenate(
  142|       |		const char *tableList, const widechar *inbuf, int inlen, char *hyphens, int mode);
  143|       |
  144|       |/**
  145|       | * Convert a string of dot patterns to a string of chars
  146|       | *
  147|       | * @param[in]  tableList comma separated list of braille tables
  148|       | * @param[in]  inbuf widechar string of dot patterns, either in liblouis format or Unicode
  149|       | * braille
  150|       | * @param[out] outbuf widechar string corresponding to the dot patterns in `inbuf`
  151|       | * @param[in,out] length of both `inbuf` and `outbuf`
  152|       | * @param[in] mode (deprecated)
  153|       | *
  154|       | * @return 1 on success and 0 on failure.
  155|       | */
  156|       |LIBLOUIS_API
  157|       |int EXPORT_CALL
  158|       |lou_dotsToChar(
  159|       |		const char *tableList, widechar *inbuf, widechar *outbuf, int length, int mode);
  160|       |LIBLOUIS_API
  161|       |int EXPORT_CALL
  162|       |lou_charToDots(const char *tableList, const widechar *inbuf, widechar *outbuf, int length,
  163|       |		int mode);
  164|       |LIBLOUIS_API
  165|       |int EXPORT_CALL
  166|       |lou_backTranslateString(const char *tableList, const widechar *inbuf, int *inlen,
  167|       |		widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int mode);
  168|       |
  169|       |LIBLOUIS_API
  170|       |int EXPORT_CALL
  171|       |lou_backTranslate(const char *tableList, const widechar *inbuf, int *inlen,
  172|       |		widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,
  173|       |		int *inputPos, int *cursorPos, int mode);
  174|       |/**
  175|       | * Print error messages to a file
  176|       | *
  177|       | * @deprecated As of 2.6.0, applications using liblouis should
  178|       | * implement their own logging system.
  179|       | */
  180|       |LIBLOUIS_API
  181|       |void EXPORT_CALL
  182|       |lou_logPrint(const char *format, ...);
  183|       |
  184|       |/**
  185|       | * Specify the name of the file to be used by lou_logPrint.
  186|       | *
  187|       | * If it is not used, this file is stderr
  188|       | *
  189|       | * @deprecated As of 2.6.0, applications using liblouis should
  190|       | * implement their own logging system.
  191|       | */
  192|       |LIBLOUIS_API
  193|       |void EXPORT_CALL
  194|       |lou_logFile(const char *filename);
  195|       |
  196|       |/**
  197|       | * Read a character from a file, whether big-endian, little-endian or ASCII8
  198|       | *
  199|       | * and return it as an integer. EOF at end of file. Mode = 1 on first
  200|       | * call, any other value thereafter
  201|       | */
  202|       |LIBLOUIS_API
  203|       |int EXPORT_CALL
  204|       |lou_readCharFromFile(const char *fileName, int *mode);
  205|       |
  206|       |/**
  207|       | * Close the log file so it can be read by other functions.
  208|       | *
  209|       | * @deprecated As of 2.6.0, applications using liblouis should
  210|       | * implement their own logging system.
  211|       | */
  212|       |LIBLOUIS_API
  213|       |void EXPORT_CALL
  214|       |lou_logEnd(void);
  215|       |
  216|       |/**
  217|       | * Load and compile a translation table
  218|       | *
  219|       | * Check the table for errors. If none are found load the table into
  220|       | * memory and return a pointer to it. If errors are found return a
  221|       | * null pointer. It is called by lou_translateString() and
  222|       | * lou_backTranslateString() and also by functions in liblouisutdml
  223|       | * and by the tools.
  224|       | */
  225|       |LIBLOUIS_API
  226|       |const void *EXPORT_CALL
  227|       |lou_getTable(const char *tableList);
  228|       |
  229|       |/**
  230|       | * Check a translation table for errors.
  231|       | *
  232|       | * If no errors are found it load the table into memory and returns a
  233|       | * non-zero value. Else the return value is 0.
  234|       | */
  235|       |LIBLOUIS_API
  236|       |int EXPORT_CALL
  237|       |lou_checkTable(const char *tableList);
  238|       |
  239|       |/**
  240|       | * Register a new table resolver. Overrides the default resolver. */
  241|       |LIBLOUIS_API
  242|       |void EXPORT_CALL
  243|       |lou_registerTableResolver(
  244|       |		char **(EXPORT_CALL *resolver)(const char *table, const char *base));
  245|       |
  246|       |/**
  247|       | * Compile a table entry on the fly at run-time
  248|       | *
  249|       | * This function enables you to compile a table entry on the fly at
  250|       | * run-time. The new entry is added to tableList and remains in
  251|       | * force until lou_free() is called. If tableList has not
  252|       | * previously been loaded it is loaded and compiled.
  253|       | *
  254|       | * @param inString contains the table entry to be added. It may be
  255|       | * anything valid. Error messages will be produced if it is invalid.
  256|       | *
  257|       | * @return 1 on success and 0 on failure.
  258|       | */
  259|       |LIBLOUIS_API
  260|       |int EXPORT_CALL
  261|       |lou_compileString(const char *tableList, const char *inString);
  262|       |
  263|       |/**
  264|       | * Get the typeform bit for the named emphasis class.
  265|       | *
  266|       | * If the table defines the specified emphasis class the corresponding
  267|       | * typeform is returned. Else the return value is 0.
  268|       | */
  269|       |LIBLOUIS_API
  270|       |formtype EXPORT_CALL
  271|       |lou_getTypeformForEmphClass(const char *tableList, const char *emphClass);
  272|       |
  273|       |/**
  274|       | * Return the emphasis class names declared in tableList as a
  275|       | * NULL-terminated array of strings. The array is acquired with malloc()
  276|       | * and should be released with free(). The strings must not be released,
  277|       | * and are no longer valid after lou_free() has been called.
  278|       | */
  279|       |LIBLOUIS_API
  280|       |char const **EXPORT_CALL
  281|       |lou_getEmphClasses(const char *tableList);
  282|       |
  283|       |/**
  284|       | * Set the path used for searching for tables and liblouisutdml files.
  285|       | *
  286|       | * Overrides the installation path. */
  287|       |LIBLOUIS_API
  288|       |char *EXPORT_CALL
  289|       |lou_setDataPath(const char *path);
  290|       |
  291|       |/**
  292|       | * Get the path set in the previous function. */
  293|       |LIBLOUIS_API
  294|       |char *EXPORT_CALL
  295|       |lou_getDataPath(void);
  296|       |
  297|       |typedef enum {
  298|       |	LOU_LOG_ALL = 0,
  299|       |	LOU_LOG_DEBUG = 10000,
  300|       |	LOU_LOG_INFO = 20000,
  301|       |	LOU_LOG_WARN = 30000,
  302|       |	LOU_LOG_ERROR = 40000,
  303|       |	LOU_LOG_FATAL = 50000,
  304|       |	LOU_LOG_OFF = 60000
  305|       |} logLevels;
  306|       |
  307|       |typedef void(EXPORT_CALL *logcallback)(logLevels level, const char *message);
  308|       |
  309|       |/**
  310|       | * Register logging callbacks
  311|       | * Set to NULL for default callback.
  312|       | */
  313|       |LIBLOUIS_API
  314|       |void EXPORT_CALL
  315|       |lou_registerLogCallback(logcallback callback);
  316|       |
  317|       |/**
  318|       | * Set the level for logging callback to be called at
  319|       | */
  320|       |LIBLOUIS_API
  321|       |void EXPORT_CALL
  322|       |lou_setLogLevel(logLevels level);
  323|       |
  324|       |typedef enum { LOU_ROW_BRAILLE = 0X2800 } LOU_UnicodeConstants;
  325|       |
  326|       |/* ========================= Sort-of private API ========================= */
  327|       |
  328|       |/**
  329|       | * Definitions of braille dots
  330|       | */
  331|       |typedef enum BrailleDots {
  332|       |	LOU_DOT_1 = 0X01,	 /** dot 1 */
  333|       |	LOU_DOT_2 = 0X02,	 /** dot 2 */
  334|       |	LOU_DOT_3 = 0X04,	 /** dot 3 */
  335|       |	LOU_DOT_4 = 0X08,	 /** dot 4 */
  336|       |	LOU_DOT_5 = 0X10,	 /** dot 5 */
  337|       |	LOU_DOT_6 = 0X20,	 /** dot 6 */
  338|       |	LOU_DOT_7 = 0X40,	 /** dot 7 */
  339|       |	LOU_DOT_8 = 0X80,	 /** dot 8 */
  340|       |	LOU_DOT_9 = 0X100,	 /** virtual dot 9 */
  341|       |	LOU_DOT_10 = 0X200,	 /** virtual dot A */
  342|       |	LOU_DOT_11 = 0X400,	 /** virtual dot B */
  343|       |	LOU_DOT_12 = 0X800,	 /** virtual dot C */
  344|       |	LOU_DOT_13 = 0X1000, /** virtual dot D */
  345|       |	LOU_DOT_14 = 0X2000, /** virtual dot E */
  346|       |	LOU_DOT_15 = 0X4000, /** virtual dot F */
  347|       |	LOU_DOTS = 0X8000	 /** if this bit is true, the widechar represents a dot pattern */
  348|       |} BrailleDots;
  349|       |
  350|       |/**
  351|       | * A sentinel, used in liblouisutdml
  352|       | */
  353|      0|#define LOU_ENDSEGMENT 0xffff
  354|       |
  355|       |/* =========================  BETA API ========================= */
  356|       |
  357|       |// Use the following two function with care, API is subject to change!
  358|       |
  359|       |/**
  360|       | * Parse, analyze and index tables.
  361|       | *
  362|       | * This function must be called prior to lou_findTable() and
  363|       | * lou_listTables(). Table names must be provided as a NULL-terminated
  364|       | * array of strings. Each table should resolve to exactly one file. An
  365|       | * error message is given when a table contains invalid or duplicate
  366|       | * metadata fields.
  367|       | */
  368|       |LIBLOUIS_API
  369|       |void EXPORT_CALL
  370|       |lou_indexTables(const char **tables);
  371|       |
  372|       |/**
  373|       | * Find the best match for a query.
  374|       | *
  375|       | * Returns the name of the table, or NULL when no match can be
  376|       | * found. If lou_indexTables() has not been previously called, the
  377|       | * table search path specified with LOUIS_TABLEPATH will be indexed
  378|       | * first. An error message is given when the query is invalid. Freeing
  379|       | * the memory of the returned string is the responsibility of the
  380|       | * caller.
  381|       | */
  382|       |LIBLOUIS_API
  383|       |char *EXPORT_CALL
  384|       |lou_findTable(const char *query);
  385|       |
  386|       |/**
  387|       | * Find all matches for a query, best match first.
  388|       | *
  389|       | * Returns the names of the matched table as a NULL-terminated array
  390|       | * of string. If lou_indexTables() has not been previously called, the
  391|       | * table search path specified with LOUIS_TABLEPATH will be indexed
  392|       | * first. An error message is given when the query is invalid. Freeing
  393|       | * the memory of the returned array and strings is the responsibility
  394|       | * of the caller.
  395|       | */
  396|       |LIBLOUIS_API
  397|       |char **EXPORT_CALL
  398|       |lou_findTables(const char *query);
  399|       |
  400|       |/**
  401|       | * Read metadata from a file.
  402|       | *
  403|       | * Returns the value of the first occuring metadata field specified by
  404|       | * `key' in `table', or NULL when the field does not exist. Freeing
  405|       | * the memory of the returned string is the responsibility of the
  406|       | * caller.
  407|       | */
  408|       |LIBLOUIS_API
  409|       |char *EXPORT_CALL
  410|       |lou_getTableInfo(const char *table, const char *key);
  411|       |
  412|       |/**
  413|       | * List available tables.
  414|       | *
  415|       | * Returns the names of available tables as a NULL-terminated array of
  416|       | * strings. Only tables that are discoverable, i.e. the have active
  417|       | * metadata, are listed. If lou_indexTables() has not been previously
  418|       | * called, the table search path specified with LOUIS_TABLEPATH will
  419|       | * be indexed first. Freeing the memory of the returned array and
  420|       | * strings is the responsibility of the caller.
  421|       | */
  422|       |LIBLOUIS_API
  423|       |char **EXPORT_CALL
  424|       |lou_listTables(void);
  425|       |
  426|       |/* ====================== END OF BETA API ====================== */
  427|       |
  428|       |/**
  429|       | * Free all memory allocated by liblouis.
  430|       | *
  431|       | * This function should be called at the end of the application to
  432|       | * free all memory allocated by liblouis.
  433|       | */
  434|       |LIBLOUIS_API
  435|       |void EXPORT_CALL
  436|       |lou_free(void);
  437|       |
  438|       |#ifdef __cplusplus
  439|       |}
  440|       |#endif /* __cplusplus */
  441|       |#endif /* __LIBLOUIS_H_ */

/home/vito/MASTER_CSI/S2/TER/fuzzing/liblouis/liblouis/logging.c:
    1|       |/* liblouis Braille Translation and Back-Translation  Library
    2|       |
    3|       |   Copyright (C) 2004, 2005, 2006 ViewPlus Technologies, Inc. www.viewplus.com
    4|       |   Copyright (C) 2004, 2005, 2006 JJB Software, Inc. www.jjb-software.com
    5|       |
    6|       |   This file is part of liblouis.
    7|       |
    8|       |   liblouis is free software: you can redistribute it and/or modify it
    9|       |   under the terms of the GNU Lesser General Public License as published
   10|       |   by the Free Software Foundation, either version 2.1 of the License, or
   11|       |   (at your option) any later version.
   12|       |
   13|       |   liblouis is distributed in the hope that it will be useful, but
   14|       |   WITHOUT ANY WARRANTY; without even the implied warranty of
   15|       |   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
   16|       |   Lesser General Public License for more details.
   17|       |
   18|       |   You should have received a copy of the GNU Lesser General Public
   19|       |   License along with liblouis. If not, see <http://www.gnu.org/licenses/>.
   20|       |*/
   21|       |
   22|       |/**
   23|       | * @file
   24|       | * @brief Logging
   25|       | */
   26|       |
   27|       |#include <stddef.h>
   28|       |#include <stdlib.h>
   29|       |#include <stdio.h>
   30|       |#include <stdarg.h>
   31|       |#include <string.h>
   32|       |
   33|       |#include "internal.h"
   34|       |
   35|       |void EXPORT_CALL
   36|      0|_lou_logWidecharBuf(logLevels level, const char *msg, const widechar *wbuf, int wlen) {
   37|      0|	/* When calculating output size:
   38|      0|	 * Each wdiechar is represented in hex, thus needing two bytes for each
   39|      0|	 * byte in the widechar (sizeof(widechar) * 2)
   40|      0|	 * Allow space for the "0x%X " formatting (+ 3)
   41|      0|	 * Number of characters in widechar buffer (wlen * )
   42|      0|	 * Give space for additional message (+ strlen(msg))
   43|      0|	 * Remember the null terminator (+ 1)
   44|      0|	 */
   45|      0|	int logBufSize = (wlen * ((sizeof(widechar) * 3) + 3)) + 3 + (int)strlen(msg);
   46|      0|	char *logMsg = malloc(logBufSize);
   47|      0|	char *p = logMsg;
   48|      0|	const char *formatString;
   49|      0|	int i = 0;
   50|      0|	if (sizeof(widechar) == 2)
   51|      0|		formatString = "0x%04X ";
   52|      0|	else
   53|      0|		formatString = "0x%08X ";
   54|      0|	for (i = 0; i < (int)strlen(msg); i++) logMsg[i] = msg[i];
   55|      0|	p += strlen(msg);
   56|      0|	for (i = 0; i < wlen; i++) {
   57|      0|		p += sprintf(p, formatString, wbuf[i]);
   58|      0|	}
   59|      0|	*p = '~';
   60|      0|	p++;
   61|      0|	*p = ' ';
   62|      0|	p++;
   63|      0|	for (i = 0; i < wlen; i++) {
   64|      0|		if (wbuf[i] & 0xff00)
   65|      0|			*p = ' ';
   66|      0|		else
   67|      0|			*p = (char)wbuf[i];
   68|      0|		p++;
   69|      0|	}
   70|      0|	*p = '\0';
   71|      0|	_lou_logMessage(level, "%s", logMsg);
   72|      0|	free(logMsg);
   73|      0|}
   74|       |
   75|       |static void EXPORT_CALL
   76|      0|defaultLogCallback(logLevels level, const char *message) {
   77|      0|	lou_logPrint("%s",
   78|      0|			message);  // lou_logPrint takes formatting, protect against % in message
   79|      0|}
   80|       |
   81|       |static logcallback logCallbackFunction = defaultLogCallback;
   82|       |void EXPORT_CALL
   83|      0|lou_registerLogCallback(logcallback callback) {
   84|      0|	if (callback == NULL)
   85|      0|		logCallbackFunction = defaultLogCallback;
   86|      0|	else
   87|      0|		logCallbackFunction = callback;
   88|      0|}
   89|       |
   90|       |static logLevels logLevel = LOU_LOG_INFO;
   91|       |void EXPORT_CALL
   92|      0|lou_setLogLevel(logLevels level) {
   93|      0|	logLevel = level;
   94|      0|}
   95|       |
   96|       |void EXPORT_CALL
   97|      0|_lou_logMessage(logLevels level, const char *format, ...) {
   98|      0|	if (format == NULL) return;
   99|      0|	if (level < logLevel) return;
  100|      0|	if (logCallbackFunction != NULL) {
  101|       |#ifdef _WIN32
  102|       |		double f = 2.3;	 // Needed to force VC++ runtime floating point support
  103|       |#endif
  104|       |		char *s;
  105|      0|		size_t len;
  106|      0|		va_list argp;
  107|      0|		va_start(argp, format);
  108|      0|		len = vsnprintf(0, 0, format, argp);
  109|      0|		va_end(argp);
  110|      0|		if ((s = malloc(len + 1)) != 0) {
  111|      0|			va_start(argp, format);
  112|      0|			vsnprintf(s, len + 1, format, argp);
  113|      0|			va_end(argp);
  114|      0|			logCallbackFunction(level, s);
  115|      0|			free(s);
  116|      0|		}
  117|      0|	}
  118|      0|}
  119|       |
  120|       |static FILE *logFile = NULL;
  121|       |static char initialLogFileName[256] = "";
  122|       |
  123|       |void EXPORT_CALL
  124|      0|lou_logFile(const char *fileName) {
  125|      0|	if (logFile) {
  126|      0|		fclose(logFile);
  127|      0|		logFile = NULL;
  128|      0|	}
  129|      0|	if (fileName == NULL || fileName[0] == 0) return;
  130|      0|	if (initialLogFileName[0] == 0) strcpy(initialLogFileName, fileName);
  131|      0|	logFile = fopen(fileName, "a");
  132|      0|	if (logFile == NULL && initialLogFileName[0] != 0)
  133|      0|		logFile = fopen(initialLogFileName, "a");
  134|      0|	if (logFile == NULL) {
  135|      0|		fprintf(stderr, "Cannot open log file %s\n", fileName);
  136|      0|		logFile = stderr;
  137|      0|	}
  138|      0|}
  139|       |
  140|       |void EXPORT_CALL
  141|      0|lou_logPrint(const char *format, ...) {
  142|      0|#ifndef __SYMBIAN32__
  143|      0|	va_list argp;
  144|      0|	if (format == NULL) return;
  145|      0|	if (logFile == NULL) logFile = fopen(initialLogFileName, "a");
  146|      0|	if (logFile == NULL) logFile = stderr;
  147|      0|	va_start(argp, format);
  148|      0|	vfprintf(logFile, format, argp);
  149|      0|	fprintf(logFile, "\n");
  150|      0|	fflush(logFile);
  151|      0|	va_end(argp);
  152|      0|#endif
  153|      0|}
  154|       |
  155|       |/* Close the log file */
  156|       |void EXPORT_CALL
  157|      0|lou_logEnd(void) {
  158|      0|	if (logFile != NULL && logFile != stderr) fclose(logFile);
  159|      0|	logFile = NULL;
  160|      0|}

/home/vito/MASTER_CSI/S2/TER/fuzzing/liblouis/liblouis/lou_backTranslateString.c:
    1|       |/* liblouis Braille Translation and Back-Translation Library
    2|       |
    3|       |   Based on the Linux screenreader BRLTTY, copyright (C) 1999-2006 by The
    4|       |   BRLTTY Team
    5|       |
    6|       |   Copyright (C) 2004, 2005, 2006 ViewPlus Technologies, Inc. www.viewplus.com
    7|       |   Copyright (C) 2004, 2005, 2006 JJB Software, Inc. www.jjb-software.com
    8|       |
    9|       |   This file is part of liblouis.
   10|       |
   11|       |   liblouis is free software: you can redistribute it and/or modify it
   12|       |   under the terms of the GNU Lesser General Public License as published
   13|       |   by the Free Software Foundation, either version 2.1 of the License, or
   14|       |   (at your option) any later version.
   15|       |
   16|       |   liblouis is distributed in the hope that it will be useful, but
   17|       |   WITHOUT ANY WARRANTY; without even the implied warranty of
   18|       |   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
   19|       |   Lesser General Public License for more details.
   20|       |
   21|       |   You should have received a copy of the GNU Lesser General Public
   22|       |   License along with liblouis. If not, see <http://www.gnu.org/licenses/>.
   23|       |*/
   24|       |
   25|       |/**
   26|       | * @file
   27|       | * @brief Translate from braille
   28|       | */
   29|       |
   30|       |#include <stdio.h>
   31|       |#include <stdlib.h>
   32|       |#include <string.h>
   33|       |
   34|       |#include "internal.h"
   35|       |
   36|       |typedef struct {
   37|       |	int size;
   38|       |	widechar **buffers;
   39|       |	int *inUse;
   40|       |	widechar *(*alloc)(int index, int length);
   41|       |	void (*free)(widechar *);
   42|       |} StringBufferPool;
   43|       |
   44|       |static widechar *
   45|      0|allocStringBuffer(int index, int length) {
   46|      0|	return _lou_allocMem(alloc_passbuf, index, 0, length);
   47|      0|}
   48|       |
   49|       |static const StringBufferPool *stringBufferPool = NULL;
   50|       |
   51|       |static void
   52|      0|initStringBufferPool() {
   53|      0|	static widechar *stringBuffers[MAXPASSBUF] = { NULL };
   54|      0|	static int stringBuffersInUse[MAXPASSBUF] = { 0 };
   55|      0|	StringBufferPool *pool = malloc(sizeof(StringBufferPool));
   56|      0|	pool->size = MAXPASSBUF;
   57|      0|	pool->buffers = stringBuffers;
   58|      0|	pool->inUse = stringBuffersInUse;
   59|      0|	pool->alloc = &allocStringBuffer;
   60|      0|	pool->free = NULL;
   61|      0|	stringBufferPool = pool;
   62|      0|}
   63|       |
   64|       |static int
   65|      0|getStringBuffer(int length) {
   66|      0|	int i;
   67|      0|	for (i = 0; i < stringBufferPool->size; i++) {
   68|      0|		if (!stringBufferPool->inUse[i]) {
   69|      0|			stringBufferPool->buffers[i] = stringBufferPool->alloc(i, length);
   70|      0|			stringBufferPool->inUse[i] = 1;
   71|      0|			return i;
   72|      0|		}
   73|      0|	}
   74|      0|	_lou_outOfMemory();
   75|      0|	return -1;
   76|      0|}
   77|       |
   78|       |static int
   79|      0|releaseStringBuffer(int idx) {
   80|      0|	if (idx >= 0 && idx < stringBufferPool->size) {
   81|      0|		int inUse = stringBufferPool->inUse[idx];
   82|      0|		if (inUse && stringBufferPool->free)
   83|      0|			stringBufferPool->free(stringBufferPool->buffers[idx]);
   84|      0|		stringBufferPool->inUse[idx] = 0;
   85|      0|		return inUse;
   86|      0|	}
   87|      0|	return 0;
   88|      0|}
   89|       |
   90|       |typedef struct {
   91|       |	int bufferIndex;
   92|       |	const widechar *chars;
   93|       |	int length;
   94|       |} InString;
   95|       |
   96|       |typedef struct {
   97|       |	int bufferIndex;
   98|       |	widechar *chars;
   99|       |	int maxlength;
  100|       |	int length;
  101|       |} OutString;
  102|       |
  103|       |typedef struct {
  104|       |	int startMatch;
  105|       |	int startReplace;
  106|       |	int endReplace;
  107|       |	int endMatch;
  108|       |} PassRuleMatch;
  109|       |
  110|       |static int
  111|       |backTranslateString(const TranslationTableHeader *table, int mode, int currentPass,
  112|       |		const InString *input, OutString *output, char *spacebuf, int *posMapping,
  113|       |		int *realInlen, int *cursorPosition, int *cursorStatus,
  114|       |		const TranslationTableRule **appliedRules, int *appliedRulesCount,
  115|       |		int maxAppliedRules);
  116|       |static int
  117|       |makeCorrections(const TranslationTableHeader *table, int mode, int currentPass,
  118|       |		const InString *input, OutString *output, int *posMapping, int *realInlen,
  119|       |		int *cursorPosition, int *cursorStatus, const TranslationTableRule **appliedRules,
  120|       |		int *appliedRulesCount, int maxAppliedRules);
  121|       |static int
  122|       |translatePass(const TranslationTableHeader *table, int mode, int currentPass,
  123|       |		const InString *input, OutString *output, int *posMapping, int *realInlen,
  124|       |		int *cursorPosition, int *cursorStatus, const TranslationTableRule **appliedRules,
  125|       |		int *appliedRulesCount, int maxAppliedRules);
  126|       |static void
  127|       |passSelectRule(const TranslationTableHeader *table, int pos, int currentPass,
  128|       |		const InString *input, TranslationTableOpcode *currentOpcode,
  129|       |		const TranslationTableRule **currentRule, const widechar **passInstructions,
  130|       |		int *passIC, PassRuleMatch *match);
  131|       |
  132|       |int EXPORT_CALL
  133|       |lou_backTranslateString(const char *tableList, const widechar *inbuf, int *inlen,
  134|      0|		widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int modex) {
  135|      0|	return lou_backTranslate(tableList, inbuf, inlen, outbuf, outlen, typeform, spacing,
  136|      0|			NULL, NULL, NULL, modex);
  137|      0|}
  138|       |
  139|       |int EXPORT_CALL
  140|       |lou_backTranslate(const char *tableList, const widechar *inbuf, int *inlen,
  141|       |		widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,
  142|      0|		int *inputPos, int *cursorPos, int modex) {
  143|      0|	return _lou_backTranslate(tableList, tableList, inbuf, inlen, outbuf, outlen,
  144|      0|			typeform, spacing, outputPos, inputPos, cursorPos, modex, NULL, NULL);
  145|      0|}
  146|       |
  147|       |int EXPORT_CALL
  148|       |_lou_backTranslate(const char *tableList, const char *displayTableList,
  149|       |		const widechar *inbuf, int *inlen, widechar *outbuf, int *outlen,
  150|       |		formtype *typeform, char *spacing, int *outputPos, int *inputPos, int *cursorPos,
  151|      0|		int mode, const TranslationTableRule **rules, int *rulesLen) {
  152|      0|	const TranslationTableHeader *table;
  153|      0|	const DisplayTableHeader *displayTable;
  154|      0|	InString input;
  155|      0|	OutString output;
  156|      0|	unsigned char *typebuf = NULL;
  157|      0|	char *spacebuf;
  158|      0|	// posMapping contains position mapping info between the output of the current pass
  159|      0|	// and the initial input. It is 1 longer than the (consumed) input. The values are
  160|      0|	// monotonically increasing and can range between -1 and the output length. At the end
  161|      0|	// the position info is passed to the user as an inputPos and outputPos array.
  162|      0|	// inputPos has the length of the final output and has values ranging from 0 to
  163|      0|	// inlen-1. outputPos has the length of the (consumed) initial input and has values
  164|      0|	// ranging from 0 to outlen-1.
  165|      0|	int *posMapping = NULL;
  166|      0|	int *posMapping1;
  167|      0|	int *posMapping2;
  168|      0|	int *posMapping3;
  169|      0|	int cursorPosition;
  170|      0|	int cursorStatus;
  171|      0|	const TranslationTableRule **appliedRules;
  172|      0|	int maxAppliedRules;
  173|      0|	int appliedRulesCount;
  174|      0|	int k;
  175|      0|	int goodTrans = 1;
  176|      0|	int idx;
  177|      0|	if (tableList == NULL || inbuf == NULL || inlen == NULL || outbuf == NULL ||
  178|      0|			outlen == NULL)
  179|      0|		return 0;
  180|      0|	if (displayTableList == NULL) displayTableList = tableList;
  181|      0|	_lou_getTable(tableList, displayTableList, &table, &displayTable);
  182|      0|	if (table == NULL) return 0;
  183|      0|
  184|      0|	if (!_lou_isValidMode(mode))
  185|      0|		_lou_logMessage(LOU_LOG_ERROR, "Invalid mode parameter: %d", mode);
  186|      0|
  187|      0|	if (!stringBufferPool) initStringBufferPool();
  188|      0|	for (idx = 0; idx < stringBufferPool->size; idx++) releaseStringBuffer(idx);
  189|      0|	{
  190|      0|		widechar *passbuf1;
  191|      0|		int srcmax;
  192|      0|		k = 0;
  193|      0|		while (k < *inlen && inbuf[k]) k++;
  194|      0|		srcmax = k;
  195|      0|		idx = getStringBuffer(srcmax);
  196|      0|		passbuf1 = stringBufferPool->buffers[idx];
  197|      0|		for (k = 0; k < srcmax; k++)
  198|      0|			if ((mode & dotsIO))
  199|      0|				passbuf1[k] = inbuf[k] | LOU_DOTS;
  200|      0|			else
  201|      0|				passbuf1[k] = _lou_getDotsForChar(inbuf[k], displayTable);
  202|      0|		passbuf1[srcmax] = _lou_getDotsForChar(' ', displayTable);
  203|      0|		input = (InString){ .chars = passbuf1, .length = srcmax, .bufferIndex = idx };
  204|      0|	}
  205|      0|	idx = getStringBuffer(*outlen);
  206|      0|	output = (OutString){ .chars = stringBufferPool->buffers[idx],
  207|      0|		.maxlength = *outlen,
  208|      0|		.length = 0,
  209|      0|		.bufferIndex = idx };
  210|      0|	typebuf = (unsigned char *)typeform;
  211|      0|	spacebuf = spacing;
  212|      0|	if (outputPos != NULL)
  213|      0|		for (k = 0; k < input.length; k++) outputPos[k] = -1;
  214|      0|	if (cursorPos != NULL)
  215|      0|		cursorPosition = *cursorPos;
  216|      0|	else
  217|      0|		cursorPosition = -1;
  218|      0|	cursorStatus = 0;
  219|      0|	if (typebuf != NULL) memset(typebuf, '0', *outlen);
  220|      0|	if (spacebuf != NULL) memset(spacebuf, '*', *outlen);
  221|      0|	if (!(posMapping1 = _lou_allocMem(alloc_posMapping1, 0, input.length, *outlen)))
  222|      0|		return 0;
  223|      0|	if (table->numPasses > 1 || table->corrections) {
  224|      0|		if (!(posMapping2 = _lou_allocMem(alloc_posMapping2, 0, input.length, *outlen)))
  225|      0|			return 0;
  226|      0|		if (!(posMapping3 = _lou_allocMem(alloc_posMapping3, 0, input.length, *outlen)))
  227|      0|			return 0;
  228|      0|	}
  229|      0|	appliedRulesCount = 0;
  230|      0|	if (rules != NULL && rulesLen != NULL) {
  231|      0|		appliedRules = rules;
  232|      0|		maxAppliedRules = *rulesLen;
  233|      0|	} else {
  234|      0|		appliedRules = NULL;
  235|      0|		maxAppliedRules = 0;
  236|      0|	}
  237|      0|
  238|      0|	posMapping = posMapping1;
  239|      0|	int currentPass = table->numPasses;
  240|      0|	int lastPass = table->corrections ? 0 : 1;
  241|      0|	int *passPosMapping = posMapping;
  242|      0|	while (1) {
  243|      0|		int realInlen;
  244|      0|		switch (currentPass) {
  245|      0|		case 1:
  246|      0|			goodTrans = backTranslateString(table, mode, currentPass, &input, &output,
  247|      0|					spacebuf, passPosMapping, &realInlen, &cursorPosition, &cursorStatus,
  248|      0|					appliedRules, &appliedRulesCount, maxAppliedRules);
  249|      0|			break;
  250|      0|		case 0:
  251|      0|			goodTrans = makeCorrections(table, mode, currentPass, &input, &output,
  252|      0|					passPosMapping, &realInlen, &cursorPosition, &cursorStatus,
  253|      0|					appliedRules, &appliedRulesCount, maxAppliedRules);
  254|      0|			break;
  255|      0|		default:
  256|      0|			goodTrans = translatePass(table, mode, currentPass, &input, &output,
  257|      0|					passPosMapping, &realInlen, &cursorPosition, &cursorStatus,
  258|      0|					appliedRules, &appliedRulesCount, maxAppliedRules);
  259|      0|			break;
  260|      0|		}
  261|      0|		passPosMapping[realInlen] = output.length;
  262|      0|		if (passPosMapping == posMapping) {
  263|      0|			passPosMapping = posMapping2;
  264|      0|			if (realInlen < input.length) *inlen = realInlen;
  265|      0|		} else {
  266|      0|			int *prevPosMapping = posMapping3;
  267|      0|			memcpy((int *)prevPosMapping, posMapping, (*inlen + 1) * sizeof(int));
  268|      0|			for (k = 0; k <= *inlen; k++) {
  269|      0|				if (prevPosMapping[k] < 0)
  270|      0|					posMapping[k] = passPosMapping[0];
  271|      0|				else if (prevPosMapping[k] < realInlen)
  272|      0|					posMapping[k] = passPosMapping[prevPosMapping[k]];
  273|      0|				else if (prevPosMapping[k] == realInlen) {
  274|      0|					// outputPos is allowed to point to right after the last output
  275|      0|					// character if the input character was deleted
  276|      0|					if (realInlen < input.length) {
  277|      0|						// however if there was back-tracking, we know that this is not
  278|      0|						// the case
  279|      0|						*inlen = k;
  280|      0|						posMapping[k] = output.length;
  281|      0|						break;
  282|      0|					} else
  283|      0|						posMapping[k] = passPosMapping[prevPosMapping[k]];
  284|      0|				} else {
  285|      0|					// this means there has been back-tracking to a point within a segment
  286|      0|					// that was atomic in the previous pass
  287|      0|					// it is not clear what should happen in this case
  288|      0|					*inlen = k;
  289|      0|					posMapping[k] = output.length;
  290|      0|					break;
  291|      0|				}
  292|      0|			}
  293|      0|		}
  294|      0|		currentPass--;
  295|      0|		if (currentPass >= lastPass && goodTrans) {
  296|      0|			releaseStringBuffer(input.bufferIndex);
  297|      0|			input = (InString){ .chars = output.chars,
  298|      0|				.length = output.length,
  299|      0|				.bufferIndex = output.bufferIndex };
  300|      0|			idx = getStringBuffer(*outlen);
  301|      0|			output = (OutString){ .chars = stringBufferPool->buffers[idx],
  302|      0|				.maxlength = *outlen,
  303|      0|				.length = 0,
  304|      0|				.bufferIndex = idx };
  305|      0|			continue;
  306|      0|		}
  307|      0|		break;
  308|      0|	}
  309|      0|	if (goodTrans) {
  310|      0|		for (k = 0; k < output.length; k++) outbuf[k] = output.chars[k];
  311|      0|		*outlen = output.length;
  312|      0|		if (inputPos != NULL) {
  313|      0|			int inpos = -1;
  314|      0|			int outpos = -1;
  315|      0|			for (k = 0; k < *inlen; k++)
  316|      0|				if (posMapping[k] > outpos) {
  317|      0|					while (outpos < posMapping[k]) {
  318|      0|						if (outpos >= 0 && outpos < *outlen)
  319|      0|							inputPos[outpos] = inpos < 0 ? 0 : inpos;
  320|      0|						outpos++;
  321|      0|					}
  322|      0|					inpos = k;
  323|      0|				}
  324|      0|			if (outpos < 0) outpos = 0;
  325|      0|			while (outpos < *outlen) inputPos[outpos++] = inpos;
  326|      0|		}
  327|      0|		if (outputPos != NULL) {
  328|      0|			for (k = 0; k < *inlen; k++)
  329|      0|				if (posMapping[k] < 0)
  330|      0|					outputPos[k] = 0;
  331|      0|				else if (posMapping[k] > *outlen - 1)
  332|      0|					outputPos[k] = *outlen - 1;
  333|      0|				else
  334|      0|					outputPos[k] = posMapping[k];
  335|      0|		}
  336|      0|	}
  337|      0|	if (cursorPos != NULL && *cursorPos != -1) {
  338|      0|		if (outputPos != NULL)
  339|      0|			*cursorPos = outputPos[*cursorPos];
  340|      0|		else
  341|      0|			*cursorPos = cursorPosition;
  342|      0|	}
  343|      0|	if (rulesLen != NULL) *rulesLen = appliedRulesCount;
  344|      0|	return goodTrans;
  345|      0|}
  346|       |
  347|       |static TranslationTableCharacter *
  348|      0|getChar(widechar c, const TranslationTableHeader *table) {
  349|      0|	static TranslationTableCharacter notFound = { NULL, -1, 0, 0, 0, CTC_Space, 0, 0, 32,
  350|      0|		0, 0 };
  351|      0|	unsigned long int makeHash = _lou_charHash(c);
  352|      0|	TranslationTableOffset bucket = table->characters[makeHash];
  353|      0|	while (bucket) {
  354|      0|		TranslationTableCharacter *character =
  355|      0|				(TranslationTableCharacter *)&table->ruleArea[bucket];
  356|      0|		if (character->value == c) return character;
  357|      0|		bucket = character->next;
  358|      0|	}
  359|      0|	notFound.value = c;
  360|      0|	return &notFound;
  361|      0|}
  362|       |
  363|       |static TranslationTableCharacter *
  364|      0|getDots(widechar c, const TranslationTableHeader *table) {
  365|      0|	static TranslationTableCharacter notFound = { NULL, -1, 0, 0, 0, CTC_Space, 0, 0,
  366|      0|		LOU_DOTS, 0, 0 };
  367|      0|	unsigned long int makeHash = _lou_charHash(c);
  368|      0|	TranslationTableOffset bucket = table->dots[makeHash];
  369|      0|	while (bucket) {
  370|      0|		TranslationTableCharacter *character =
  371|      0|				(TranslationTableCharacter *)&table->ruleArea[bucket];
  372|      0|		if (character->value == c) return character;
  373|      0|		bucket = character->next;
  374|      0|	}
  375|      0|	notFound.value = c;
  376|      0|	return &notFound;
  377|      0|}
  378|       |
  379|       |static int
  380|       |checkDotsAttr(const widechar d, const TranslationTableCharacterAttributes a,
  381|      0|		const TranslationTableHeader *table) {
  382|      0|	static widechar prevd = 0;
  383|      0|	static TranslationTableCharacterAttributes preva = 0;
  384|      0|	if (d != prevd) {
  385|      0|		preva = (getDots(d, table))->attributes;
  386|      0|		prevd = d;
  387|      0|	}
  388|      0|	return ((preva & a) ? 1 : 0);
  389|      0|}
  390|       |
  391|       |static int
  392|      0|compareDots(const widechar *address1, const widechar *address2, int count) {
  393|      0|	int k;
  394|      0|	if (!count) return 0;
  395|      0|	for (k = 0; k < count; k++)
  396|      0|		if (address1[k] != address2[k]) return 0;
  397|      0|	return 1;
  398|      0|}
  399|       |
  400|       |static void
  401|       |back_setBefore(const TranslationTableHeader *table, OutString *output,
  402|      0|		TranslationTableCharacterAttributes *beforeAttributes) {
  403|      0|	widechar before = (output->length == 0) ? ' ' : output->chars[output->length - 1];
  404|      0|	*beforeAttributes = (getChar(before, table))->attributes;
  405|      0|}
  406|       |
  407|       |static void
  408|       |back_setAfter(int length, const TranslationTableHeader *table, int pos,
  409|      0|		const InString *input, TranslationTableCharacterAttributes *afterAttributes) {
  410|      0|	widechar after = (pos + length < input->length) ? input->chars[pos + length] : ' ';
  411|      0|	*afterAttributes = (getDots(after, table))->attributes;
  412|      0|}
  413|       |
  414|       |static int
  415|      0|isBegWord(const TranslationTableHeader *table, OutString *output) {
  416|      0|	/* See if this is really the beginning of a word. Look at what has
  417|      0|	 * already been translated. */
  418|      0|	int k;
  419|      0|	if (output->length == 0) return 1;
  420|      0|	for (k = output->length - 1; k >= 0; k--) {
  421|      0|		const TranslationTableCharacter *ch = getChar(output->chars[k], table);
  422|      0|		if (ch->attributes & CTC_Space) break;
  423|      0|		if (ch->attributes & (CTC_Letter | CTC_Digit | CTC_Math | CTC_Sign)) return 0;
  424|      0|	}
  425|      0|	return 1;
  426|      0|}
  427|       |
  428|       |static int
  429|       |isEndWord(const TranslationTableHeader *table, int pos, int mode, const InString *input,
  430|      0|		int currentDotslen) {
  431|      0|	if (mode & partialTrans) return 0;
  432|      0|	/* See if this is really the end of a word. */
  433|      0|	int k;
  434|      0|	const TranslationTableCharacter *dots;
  435|      0|	TranslationTableOffset testRuleOffset;
  436|      0|	TranslationTableRule *testRule;
  437|      0|	for (k = pos + currentDotslen; k < input->length; k++) {
  438|      0|		int postpuncFound = 0;
  439|      0|		int TranslationFound = 0;
  440|      0|		dots = getDots(input->chars[k], table);
  441|      0|		testRuleOffset = dots->otherRules;
  442|      0|		if (dots->attributes & CTC_Space) break;
  443|      0|		if (dots->attributes & CTC_Letter) return 0;
  444|      0|		while (testRuleOffset) {
  445|      0|			testRule = (TranslationTableRule *)&table->ruleArea[testRuleOffset];
  446|      0|			/* #360: Don't treat begword/midword as definite translations here
  447|      0|			 * because we don't know whether they apply yet. Subsequent
  448|      0|			 * input will allow us to determine whether the word continues.
  449|      0|			 */
  450|      0|			if (testRule->charslen > 1 && testRule->opcode != CTO_BegWord &&
  451|      0|					testRule->opcode != CTO_MidWord)
  452|      0|				TranslationFound = 1;
  453|      0|			if (testRule->opcode == CTO_PostPunc) postpuncFound = 1;
  454|      0|			if (testRule->opcode == CTO_Hyphen) return 1;
  455|      0|			testRuleOffset = testRule->dotsnext;
  456|      0|		}
  457|      0|		if (TranslationFound && !postpuncFound) return 0;
  458|      0|	}
  459|      0|	return 1;
  460|      0|}
  461|       |static int
  462|       |findBrailleIndicatorRule(TranslationTableOffset offset,
  463|       |		const TranslationTableHeader *table, int *currentDotslen,
  464|      0|		TranslationTableOpcode *currentOpcode, const TranslationTableRule **currentRule) {
  465|      0|	if (!offset) return 0;
  466|      0|	*currentRule = (TranslationTableRule *)&table->ruleArea[offset];
  467|      0|	*currentOpcode = (*currentRule)->opcode;
  468|      0|	*currentDotslen = (*currentRule)->dotslen;
  469|      0|	return 1;
  470|      0|}
  471|       |
  472|       |static int
  473|       |handleMultind(const TranslationTableHeader *table, int *currentDotslen,
  474|       |		TranslationTableOpcode *currentOpcode, const TranslationTableRule **currentRule,
  475|      0|		int *doingMultind, const TranslationTableRule *multindRule) {
  476|      0|	/* Handle multille braille indicators */
  477|      0|	int found = 0;
  478|      0|	if (!*doingMultind) return 0;
  479|      0|	switch (multindRule->charsdots[multindRule->charslen - *doingMultind]) {
  480|      0|	case CTO_CapsLetterRule:  // FIXME: make sure this works
  481|      0|		found = findBrailleIndicatorRule(table->emphRules[MAX_EMPH_CLASSES][letterOffset],
  482|      0|				table, currentDotslen, currentOpcode, currentRule);
  483|      0|		break;
  484|      0|	// NOTE:  following fixme is based on the names at the time of
  485|      0|	//        commit f22f91eb510cb4eef33dfb4950a297235dd2f9f1.
  486|      0|	// FIXME: the next two opcodes were begcaps/endcaps,
  487|      0|	//        and they were aliased to opcodes capsword/capswordstop.
  488|      0|	//        However, the table attributes they use are
  489|      0|	//        table->beginCapitalSign and table->endCapitalSign.
  490|      0|	//        These are actually compiled with firstlettercaps/lastlettercaps.
  491|      0|	//        Which to use here?
  492|      0|	case CTO_BegCapsWordRule:
  493|      0|		found = findBrailleIndicatorRule(
  494|      0|				table->emphRules[MAX_EMPH_CLASSES][begWordOffset], table, currentDotslen,
  495|      0|				currentOpcode, currentRule);
  496|      0|		break;
  497|      0|	case CTO_EndCapsWordRule:
  498|      0|		found = findBrailleIndicatorRule(
  499|      0|				table->emphRules[MAX_EMPH_CLASSES][endWordOffset], table, currentDotslen,
  500|      0|				currentOpcode, currentRule);
  501|      0|		break;
  502|      0|	case CTO_LetterSign:
  503|      0|		found = findBrailleIndicatorRule(
  504|      0|				table->letterSign, table, currentDotslen, currentOpcode, currentRule);
  505|      0|		break;
  506|      0|	case CTO_NoContractSign:
  507|      0|		found = findBrailleIndicatorRule(
  508|      0|				table->noContractSign, table, currentDotslen, currentOpcode, currentRule);
  509|      0|		break;
  510|      0|	case CTO_NumberSign:
  511|      0|		found = findBrailleIndicatorRule(
  512|      0|				table->numberSign, table, currentDotslen, currentOpcode, currentRule);
  513|      0|		break;
  514|      0|	case CTO_EndEmph1PhraseBeforeRule:
  515|      0|		found = findBrailleIndicatorRule(table->emphRules[0][endPhraseBeforeOffset],
  516|      0|				table, currentDotslen, currentOpcode, currentRule);
  517|      0|		break;
  518|      0|	case CTO_BegEmph1Rule:
  519|      0|		found = findBrailleIndicatorRule(table->emphRules[0][begOffset], table,
  520|      0|				currentDotslen, currentOpcode, currentRule);
  521|      0|		break;
  522|      0|	case CTO_EndEmph1Rule:
  523|      0|		found = findBrailleIndicatorRule(table->emphRules[0][endOffset], table,
  524|      0|				currentDotslen, currentOpcode, currentRule);
  525|      0|		break;
  526|      0|	case CTO_EndEmph2PhraseBeforeRule:
  527|      0|		found = findBrailleIndicatorRule(table->emphRules[1][endPhraseBeforeOffset],
  528|      0|				table, currentDotslen, currentOpcode, currentRule);
  529|      0|		break;
  530|      0|	case CTO_BegEmph2Rule:
  531|      0|		found = findBrailleIndicatorRule(table->emphRules[1][begOffset], table,
  532|      0|				currentDotslen, currentOpcode, currentRule);
  533|      0|		break;
  534|      0|	case CTO_EndEmph2Rule:
  535|      0|		found = findBrailleIndicatorRule(table->emphRules[1][endOffset], table,
  536|      0|				currentDotslen, currentOpcode, currentRule);
  537|      0|		break;
  538|      0|	case CTO_EndEmph3PhraseBeforeRule:
  539|      0|		found = findBrailleIndicatorRule(table->emphRules[2][endPhraseBeforeOffset],
  540|      0|				table, currentDotslen, currentOpcode, currentRule);
  541|      0|		break;
  542|      0|	case CTO_BegEmph3Rule:
  543|      0|		found = findBrailleIndicatorRule(table->emphRules[2][begOffset], table,
  544|      0|				currentDotslen, currentOpcode, currentRule);
  545|      0|		break;
  546|      0|	case CTO_EndEmph3Rule:
  547|      0|		found = findBrailleIndicatorRule(table->emphRules[2][endOffset], table,
  548|      0|				currentDotslen, currentOpcode, currentRule);
  549|      0|		break;
  550|      0|	case CTO_BegComp:
  551|      0|		found = findBrailleIndicatorRule(
  552|      0|				table->begComp, table, currentDotslen, currentOpcode, currentRule);
  553|      0|		break;
  554|      0|	case CTO_EndComp:
  555|      0|		found = findBrailleIndicatorRule(
  556|      0|				table->endComp, table, currentDotslen, currentOpcode, currentRule);
  557|      0|		break;
  558|      0|	default:
  559|      0|		found = 0;
  560|      0|		break;
  561|      0|	}
  562|      0|	(*doingMultind)--;
  563|      0|	return found;
  564|      0|}
  565|       |
  566|       |static int
  567|       |back_passDoTest(const TranslationTableHeader *table, int pos, const InString *input,
  568|       |		TranslationTableOpcode currentOpcode, const TranslationTableRule *currentRule,
  569|       |		const widechar **passInstructions, int *passIC, PassRuleMatch *match);
  570|       |static int
  571|       |back_passDoAction(const TranslationTableHeader *table, int *pos, int mode,
  572|       |		const InString *input, OutString *output, int *posMapping, int *cursorPosition,
  573|       |		int *cursorStatus, int *nextUpper, int allUpper, int allUpperPhrase,
  574|       |		TranslationTableOpcode currentOpcode, const TranslationTableRule *currentRule,
  575|       |		const widechar *passInstructions, int passIC, PassRuleMatch match);
  576|       |
  577|       |static int
  578|       |findBackPassRule(const TranslationTableHeader *table, int pos, int currentPass,
  579|       |		const InString *input, TranslationTableOpcode *currentOpcode,
  580|       |		const TranslationTableRule **currentRule, const widechar **passInstructions,
  581|      0|		int *passIC, PassRuleMatch *match) {
  582|      0|	TranslationTableOffset ruleOffset;
  583|      0|	ruleOffset = table->backPassRules[currentPass];
  584|      0|
  585|      0|	while (ruleOffset) {
  586|      0|		*currentRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];
  587|      0|		*currentOpcode = (*currentRule)->opcode;
  588|      0|
  589|      0|		switch (*currentOpcode) {
  590|      0|		case CTO_Correct:
  591|      0|			if (currentPass != 0) goto NEXT_RULE;
  592|      0|			break;
  593|      0|		case CTO_Context:
  594|      0|			if (currentPass != 1) goto NEXT_RULE;
  595|      0|			break;
  596|      0|		case CTO_Pass2:
  597|      0|			if (currentPass != 2) goto NEXT_RULE;
  598|      0|			break;
  599|      0|		case CTO_Pass3:
  600|      0|			if (currentPass != 3) goto NEXT_RULE;
  601|      0|			break;
  602|      0|		case CTO_Pass4:
  603|      0|			if (currentPass != 4) goto NEXT_RULE;
  604|      0|			break;
  605|      0|		default:
  606|      0|			goto NEXT_RULE;
  607|      0|		}
  608|      0|
  609|      0|		if (back_passDoTest(table, pos, input, *currentOpcode, *currentRule,
  610|      0|					passInstructions, passIC, match))
  611|      0|			return 1;
  612|      0|
  613|      0|	NEXT_RULE:
  614|      0|		ruleOffset = (*currentRule)->dotsnext;
  615|      0|	}
  616|      0|
  617|      0|	return 0;
  618|      0|}
  619|       |
  620|       |static void
  621|       |back_selectRule(const TranslationTableHeader *table, int pos, int mode,
  622|       |		const InString *input, OutString *output, int itsANumber, int itsALetter,
  623|       |		int *currentDotslen, TranslationTableOpcode *currentOpcode,
  624|       |		const TranslationTableRule **currentRule, TranslationTableOpcode previousOpcode,
  625|       |		int *doingMultind, const TranslationTableRule **multindRule,
  626|       |		TranslationTableCharacterAttributes beforeAttributes,
  627|      0|		const widechar **passInstructions, int *passIC, PassRuleMatch *patternMatch) {
  628|      0|	/* check for valid back-translations */
  629|      0|	int length = input->length - pos;
  630|      0|	TranslationTableOffset ruleOffset = 0;
  631|      0|	static TranslationTableRule pseudoRule = { 0 };
  632|      0|	unsigned long int makeHash = 0;
  633|      0|	const TranslationTableCharacter *dots = getDots(input->chars[pos], table);
  634|      0|	int tryThis;
  635|      0|	if (handleMultind(table, currentDotslen, currentOpcode, currentRule, doingMultind,
  636|      0|				*multindRule))
  637|      0|		return;
  638|      0|	for (tryThis = 0; tryThis < 3; tryThis++) {
  639|      0|		switch (tryThis) {
  640|      0|		case 0:
  641|      0|			if (length < 2 || (itsANumber && (dots->attributes & CTC_LitDigit))) break;
  642|      0|			/* Hash function optimized for backward translation */
  643|      0|			makeHash = (unsigned long int)dots->value << 8;
  644|      0|			makeHash += (unsigned long int)(getDots(input->chars[pos + 1], table))->value;
  645|      0|			makeHash %= HASHNUM;
  646|      0|			ruleOffset = table->backRules[makeHash];
  647|      0|			break;
  648|      0|		case 1:
  649|      0|			if (!(length >= 1)) break;
  650|      0|			length = 1;
  651|      0|			ruleOffset = dots->otherRules;
  652|      0|			break;
  653|      0|		case 2: /* No rule found */
  654|      0|			*currentRule = &pseudoRule;
  655|      0|			*currentOpcode = pseudoRule.opcode = CTO_None;
  656|      0|			*currentDotslen = pseudoRule.dotslen = 1;
  657|      0|			pseudoRule.charsdots[0] = input->chars[pos];
  658|      0|			pseudoRule.charslen = 0;
  659|      0|			return;
  660|      0|			break;
  661|      0|		}
  662|      0|		while (ruleOffset) {
  663|      0|			const widechar *currentDots;
  664|      0|			*currentRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];
  665|      0|			*currentOpcode = (*currentRule)->opcode;
  666|      0|			if (*currentOpcode == CTO_Context) {
  667|      0|				currentDots = &(*currentRule)->charsdots[0];
  668|      0|				*currentDotslen = (*currentRule)->charslen;
  669|      0|			} else {
  670|      0|				currentDots = &(*currentRule)->charsdots[(*currentRule)->charslen];
  671|      0|				*currentDotslen = (*currentRule)->dotslen;
  672|      0|			}
  673|      0|			if (((*currentDotslen <= length) &&
  674|      0|						compareDots(&input->chars[pos], currentDots, *currentDotslen))) {
  675|      0|				TranslationTableCharacterAttributes afterAttributes;
  676|      0|				/* check this rule */
  677|      0|				back_setAfter(*currentDotslen, table, pos, input, &afterAttributes);
  678|      0|				if ((!((*currentRule)->after & ~CTC_EmpMatch) ||
  679|      0|							(beforeAttributes & (*currentRule)->after)) &&
  680|      0|						(!((*currentRule)->before & ~CTC_EmpMatch) ||
  681|      0|								(afterAttributes & (*currentRule)->before))) {
  682|      0|					switch (*currentOpcode) { /* check validity of this Translation */
  683|      0|					case CTO_Context:
  684|      0|						if (back_passDoTest(table, pos, input, *currentOpcode,
  685|      0|									*currentRule, passInstructions, passIC, patternMatch))
  686|      0|							return;
  687|      0|						break;
  688|      0|					case CTO_Space:
  689|      0|					case CTO_Digit:
  690|      0|					case CTO_Letter:
  691|      0|					case CTO_UpperCase:
  692|      0|					case CTO_LowerCase:
  693|      0|					case CTO_Punctuation:
  694|      0|					case CTO_Math:
  695|      0|					case CTO_Sign:
  696|      0|					case CTO_ExactDots:
  697|      0|					case CTO_Repeated:
  698|      0|					case CTO_Replace:
  699|      0|					case CTO_Hyphen:
  700|      0|						return;
  701|      0|					case CTO_LitDigit:
  702|      0|						if (itsANumber) return;
  703|      0|						break;
  704|      0|					case CTO_CapsLetterRule:
  705|      0|					case CTO_BegCapsRule:
  706|      0|					case CTO_EndCapsRule:
  707|      0|					case CTO_BegCapsWordRule:
  708|      0|					case CTO_EndCapsWordRule:
  709|      0|					case CTO_BegEmph1Rule:
  710|      0|					case CTO_EndEmph1Rule:
  711|      0|					case CTO_BegEmph2Rule:
  712|      0|					case CTO_EndEmph2Rule:
  713|      0|					case CTO_BegEmph3Rule:
  714|      0|					case CTO_EndEmph3Rule:
  715|      0|					case CTO_NumberRule:
  716|      0|					case CTO_BegCompRule:
  717|      0|					case CTO_EndCompRule:
  718|      0|						return;
  719|      0|					case CTO_LetterRule:
  720|      0|					case CTO_NoContractRule:
  721|      0|						// BF: This is just a heuristic test. During forward translation,
  722|      0|						// the
  723|      0|						// nocontractsign is inserted either when in numeric mode and the
  724|      0|						// next
  725|      0|						// character is not numeric (CTC_Digit | CTC_LitDigit |
  726|      0|						// CTC_NumericMode | CTC_MidEndNumericMode),
  727|      0|						// or when a "contraction" rule is matched and the characters are
  728|      0|						// preceded and followed by space or punctuation (CTC_Space |
  729|      0|						// CTC_Punctuation).
  730|      0|						if (!(beforeAttributes & CTC_Letter) &&
  731|      0|								(afterAttributes & (CTC_Letter | CTC_Sign)))
  732|      0|							return;
  733|      0|						break;
  734|      0|					case CTO_MultInd:
  735|      0|						*doingMultind = *currentDotslen;
  736|      0|						*multindRule = *currentRule;
  737|      0|						if (handleMultind(table, currentDotslen, currentOpcode,
  738|      0|									currentRule, doingMultind, *multindRule))
  739|      0|							return;
  740|      0|						break;
  741|      0|					case CTO_LargeSign:
  742|      0|						return;
  743|      0|					case CTO_WholeWord:
  744|      0|						if (mode & partialTrans) break;
  745|      0|						if (itsALetter || itsANumber) break;
  746|      0|					case CTO_Contraction:
  747|      0|						if ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&
  748|      0|								((afterAttributes & CTC_Space) ||
  749|      0|										isEndWord(table, pos, mode, input,
  750|      0|												*currentDotslen)))
  751|      0|							return;
  752|      0|						break;
  753|      0|					case CTO_LowWord:
  754|      0|						if (mode & partialTrans) break;
  755|      0|						if ((beforeAttributes & CTC_Space) &&
  756|      0|								(afterAttributes & CTC_Space) &&
  757|      0|								(previousOpcode != CTO_JoinableWord))
  758|      0|							return;
  759|      0|						break;
  760|      0|					case CTO_JoinNum:
  761|      0|					case CTO_JoinableWord:
  762|      0|						if ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&
  763|      0|								(!(afterAttributes & CTC_Space) || mode & partialTrans))
  764|      0|							return;
  765|      0|						break;
  766|      0|					case CTO_SuffixableWord:
  767|      0|						if (beforeAttributes & (CTC_Space | CTC_Punctuation)) return;
  768|      0|						break;
  769|      0|					case CTO_PrefixableWord:
  770|      0|						if ((beforeAttributes &
  771|      0|									(CTC_Space | CTC_Letter | CTC_Punctuation)) &&
  772|      0|								isEndWord(table, pos, mode, input, *currentDotslen))
  773|      0|							return;
  774|      0|						break;
  775|      0|					case CTO_BegWord:
  776|      0|						if ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&
  777|      0|								(!isEndWord(table, pos, mode, input, *currentDotslen)))
  778|      0|							return;
  779|      0|						break;
  780|      0|					case CTO_BegMidWord:
  781|      0|						if ((beforeAttributes &
  782|      0|									(CTC_Letter | CTC_Space | CTC_Punctuation)) &&
  783|      0|								(!isEndWord(table, pos, mode, input, *currentDotslen)))
  784|      0|							return;
  785|      0|						break;
  786|      0|					case CTO_PartWord:
  787|      0|						if (!(beforeAttributes & CTC_LitDigit) &&
  788|      0|								(beforeAttributes & CTC_Letter ||
  789|      0|										!isEndWord(table, pos, mode, input,
  790|      0|												*currentDotslen)))
  791|      0|							return;
  792|      0|						break;
  793|      0|					case CTO_MidWord:
  794|      0|						if (beforeAttributes & CTC_Letter &&
  795|      0|								!isEndWord(table, pos, mode, input, *currentDotslen))
  796|      0|							return;
  797|      0|						break;
  798|      0|					case CTO_MidEndWord:
  799|      0|						if ((beforeAttributes & CTC_Letter)) return;
  800|      0|						break;
  801|      0|					case CTO_EndWord:
  802|      0|						if ((beforeAttributes & CTC_Letter) &&
  803|      0|								isEndWord(table, pos, mode, input, *currentDotslen))
  804|      0|							return;
  805|      0|						break;
  806|      0|					case CTO_BegNum:
  807|      0|						if (beforeAttributes & (CTC_Space | CTC_Punctuation) &&
  808|      0|								(afterAttributes & (CTC_LitDigit | CTC_Sign)))
  809|      0|							return;
  810|      0|						break;
  811|      0|					case CTO_MidNum:
  812|      0|						if (beforeAttributes & CTC_Digit &&
  813|      0|								afterAttributes & CTC_LitDigit)
  814|      0|							return;
  815|      0|						break;
  816|      0|					case CTO_EndNum:
  817|      0|						if (itsANumber && !(afterAttributes & CTC_LitDigit)) return;
  818|      0|						break;
  819|      0|					case CTO_DecPoint:
  820|      0|						if (afterAttributes & (CTC_Digit | CTC_LitDigit)) return;
  821|      0|						break;
  822|      0|					case CTO_PrePunc:
  823|      0|						if (isBegWord(table, output)) return;
  824|      0|						break;
  825|      0|
  826|      0|					case CTO_PostPunc:
  827|      0|						if (isEndWord(table, pos, mode, input, *currentDotslen)) return;
  828|      0|						break;
  829|      0|					case CTO_Always:
  830|      0|						if ((beforeAttributes & CTC_LitDigit) &&
  831|      0|								(afterAttributes & CTC_LitDigit) &&
  832|      0|								(*currentRule)->charslen > 1)
  833|      0|							break;
  834|      0|						return;
  835|      0|
  836|      0|					case CTO_BackMatch: {
  837|      0|						widechar *patterns, *pattern;
  838|      0|
  839|      0|						// if(dontContract || (mode & noContractions))
  840|      0|						//	break;
  841|      0|						// if(checkEmphasisChange(0))
  842|      0|						//	break;
  843|      0|
  844|      0|						patterns = (widechar *)&table->ruleArea[(*currentRule)->patterns];
  845|      0|
  846|      0|						/* check before pattern */
  847|      0|						pattern = &patterns[1];
  848|      0|						if (!_lou_pattern_check(
  849|      0|									input->chars, pos - 1, -1, -1, pattern, table))
  850|      0|							break;
  851|      0|
  852|      0|						/* check after pattern */
  853|      0|						pattern = &patterns[patterns[0]];
  854|      0|						if (!_lou_pattern_check(input->chars,
  855|      0|									pos + (*currentRule)->dotslen, input->length, 1,
  856|      0|									pattern, table))
  857|      0|							break;
  858|      0|
  859|      0|						return;
  860|      0|					}
  861|      0|					default:
  862|      0|						break;
  863|      0|					}
  864|      0|				}
  865|      0|			} /* Done with checking this rule */
  866|      0|			ruleOffset = (*currentRule)->dotsnext;
  867|      0|		}
  868|      0|	}
  869|      0|}
  870|       |
  871|       |static widechar
  872|       |toLowercase(
  873|      0|		const TranslationTableHeader *table, const TranslationTableCharacter *character) {
  874|      0|	if (character->mode & CTC_UpperCase) {
  875|      0|		const TranslationTableCharacter *c = character;
  876|      0|		if (c->basechar) c = (TranslationTableCharacter *)&table->ruleArea[c->basechar];
  877|      0|		while (1) {
  878|      0|			if ((c->mode & (character->mode & ~CTC_UpperCase)) ==
  879|      0|					(character->mode & ~CTC_UpperCase))
  880|      0|				return c->value;
  881|      0|			if (!c->linked) break;
  882|      0|			c = (TranslationTableCharacter *)&table->ruleArea[c->linked];
  883|      0|		}
  884|      0|	}
  885|      0|	return character->value;
  886|      0|}
  887|       |
  888|       |static widechar
  889|       |toUppercase(
  890|      0|		const TranslationTableHeader *table, const TranslationTableCharacter *character) {
  891|      0|	const TranslationTableCharacter *c = character;
  892|      0|	if (c->basechar) c = (TranslationTableCharacter *)&table->ruleArea[c->basechar];
  893|      0|	while (c->linked) {
  894|      0|		c = (TranslationTableCharacter *)&table->ruleArea[c->linked];
  895|      0|		if ((c->mode & (character->mode | CTC_UpperCase)) ==
  896|      0|				(character->mode | CTC_UpperCase))
  897|      0|			return c->value;
  898|      0|	}
  899|      0|	return character->value;
  900|      0|}
  901|       |
  902|       |static int
  903|       |putchars(const widechar *chars, int count, const TranslationTableHeader *table,
  904|      0|		OutString *output, int *nextUpper, int allUpper, int allUpperPhrase) {
  905|      0|	int k = 0;
  906|      0|	if (!count || (output->length + count) > output->maxlength) return 0;
  907|      0|	if (*nextUpper) {
  908|      0|		output->chars[(output->length)++] =
  909|      0|				toUppercase(table, getChar(chars[k++], table));
  910|      0|		*nextUpper = 0;
  911|      0|	}
  912|      0|	if (!allUpper && !allUpperPhrase) {
  913|      0|		memcpy(&output->chars[output->length], &chars[k], CHARSIZE * (count - k));
  914|      0|		output->length += count - k;
  915|      0|	} else
  916|      0|		for (; k < count; k++)
  917|      0|			output->chars[(output->length)++] =
  918|      0|					toUppercase(table, getChar(chars[k], table));
  919|      0|	return 1;
  920|      0|}
  921|       |
  922|       |static int
  923|       |back_updatePositions(const widechar *outChars, int inLength, int outLength,
  924|       |		const TranslationTableHeader *table, int pos, const InString *input,
  925|       |		OutString *output, int *posMapping, int *cursorPosition, int *cursorStatus,
  926|      0|		int *nextUpper, int allUpper, int allUpperPhrase) {
  927|      0|	int k;
  928|      0|	if ((output->length + outLength) > output->maxlength ||
  929|      0|			(pos + inLength) > input->length)
  930|      0|		return 0;
  931|      0|	if (!*cursorStatus && *cursorPosition >= pos && *cursorPosition < (pos + inLength)) {
  932|      0|		*cursorPosition = output->length + outLength / 2;
  933|      0|		*cursorStatus = 1;
  934|      0|	}
  935|      0|	for (k = 0; k < inLength; k++) posMapping[pos + k] = output->length;
  936|      0|	return putchars(
  937|      0|			outChars, outLength, table, output, nextUpper, allUpper, allUpperPhrase);
  938|      0|}
  939|       |
  940|       |static int
  941|      0|undefinedDots(widechar dots, int mode, OutString *output, int pos, int *posMapping) {
  942|      0|	posMapping[pos] = output->length;
  943|      0|	if (mode & noUndefined) return 1;
  944|      0|
  945|      0|	/* Print out dot numbers */
  946|      0|	const char *buffer = _lou_unknownDots(dots);
  947|      0|	size_t buflen = strlen(buffer);
  948|      0|	if ((output->length + buflen) > output->maxlength) return 0;
  949|      0|
  950|      0|	for (unsigned int k = 0; k < buflen; k += 1) {
  951|      0|		output->chars[output->length++] = buffer[k];
  952|      0|	}
  953|      0|
  954|      0|	return 1;
  955|      0|}
  956|       |
  957|       |static int
  958|       |putCharacter(widechar dots, const TranslationTableHeader *table, int pos, int mode,
  959|       |		const InString *input, OutString *output, int *posMapping, int *cursorPosition,
  960|      0|		int *cursorStatus, int *nextUpper, int allUpper, int allUpperPhrase) {
  961|      0|	/* Output character(s) corresponding to a Unicode braille Character */
  962|      0|	TranslationTableOffset offset = (getDots(dots, table))->definitionRule;
  963|      0|	if (offset) {
  964|      0|		const TranslationTableRule *rule =
  965|      0|				(TranslationTableRule *)&table->ruleArea[offset];
  966|      0|		return back_updatePositions(&rule->charsdots[0], rule->dotslen, rule->charslen,
  967|      0|				table, pos, input, output, posMapping, cursorPosition, cursorStatus,
  968|      0|				nextUpper, allUpper, allUpperPhrase);
  969|      0|	}
  970|      0|	return undefinedDots(dots, mode, output, pos, posMapping);
  971|      0|}
  972|       |
  973|       |static int
  974|       |putCharacters(const widechar *characters, int count, const TranslationTableHeader *table,
  975|       |		int pos, int mode, const InString *input, OutString *output, int *posMapping,
  976|       |		int *cursorPosition, int *cursorStatus, int *nextUpper, int allUpper,
  977|      0|		int allUpperPhrase) {
  978|      0|	int k;
  979|      0|	for (k = 0; k < count; k++)
  980|      0|		if (!putCharacter(characters[k], table, pos, mode, input, output, posMapping,
  981|      0|					cursorPosition, cursorStatus, nextUpper, allUpper, allUpperPhrase))
  982|      0|			return 0;
  983|      0|	return 1;
  984|      0|}
  985|       |
  986|       |static int
  987|       |insertSpace(const TranslationTableHeader *table, int pos, const InString *input,
  988|       |		OutString *output, char *spacebuf, int *posMapping, int *cursorPosition,
  989|      0|		int *cursorStatus, int *nextUpper, int allUpper, int allUpperPhrase) {
  990|      0|	widechar c = ' ';
  991|      0|	if (!back_updatePositions(&c, 1, 1, table, pos, input, output, posMapping,
  992|      0|				cursorPosition, cursorStatus, nextUpper, allUpper, allUpperPhrase))
  993|      0|		return 0;
  994|      0|	if (spacebuf) spacebuf[output->length - 1] = '1';
  995|      0|	return 1;
  996|      0|}
  997|       |
  998|       |static int
  999|       |compareChars(const widechar *address1, const widechar *address2, int count,
 1000|      0|		const TranslationTableHeader *table) {
 1001|      0|	int k;
 1002|      0|	if (!count) return 0;
 1003|      0|	for (k = 0; k < count; k++)
 1004|      0|		if (toLowercase(table, getChar(address1[k], table)) !=
 1005|      0|				toLowercase(table, getChar(address2[k], table)))
 1006|      0|			return 0;
 1007|      0|	return 1;
 1008|      0|}
 1009|       |
 1010|       |static int
 1011|       |makeCorrections(const TranslationTableHeader *table, int mode, int currentPass,
 1012|       |		const InString *input, OutString *output, int *posMapping, int *realInlen,
 1013|       |		int *cursorPosition, int *cursorStatus, const TranslationTableRule **appliedRules,
 1014|      0|		int *appliedRulesCount, int maxAppliedRules) {
 1015|      0|	int pos;
 1016|      0|	int posIncremented = 1;
 1017|      0|	int nextUpper = 0;
 1018|      0|	int allUpper = 0;
 1019|      0|	int allUpperPhrase = 0;
 1020|      0|	if (!table->corrections) return 1;
 1021|      0|	pos = 0;
 1022|      0|	output->length = 0;
 1023|      0|	_lou_resetPassVariables();
 1024|      0|	while (pos < input->length) {
 1025|      0|		int posBefore = pos;
 1026|      0|		TranslationTableOpcode currentOpcode;
 1027|      0|		const TranslationTableRule *currentRule; /* pointer to current rule in table */
 1028|      0|		const widechar *passInstructions;
 1029|      0|		int passIC; /* Instruction counter */
 1030|      0|		PassRuleMatch patternMatch;
 1031|      0|		int length = input->length - pos;
 1032|      0|		const TranslationTableCharacter *character = getChar(input->chars[pos], table);
 1033|      0|		const TranslationTableCharacter *character2;
 1034|      0|		int tryThis = 0;
 1035|      0|		if (!(posIncremented &&
 1036|      0|					findBackPassRule(table, pos, currentPass, input, &currentOpcode,
 1037|      0|							&currentRule, &passInstructions, &passIC, &patternMatch)))
 1038|      0|			while (tryThis < 3) {
 1039|      0|				TranslationTableOffset ruleOffset = 0;
 1040|      0|				unsigned long int makeHash = 0;
 1041|      0|				switch (tryThis) {
 1042|      0|				case 0:
 1043|      0|					if (!(length >= 2)) break;
 1044|      0|					makeHash = (unsigned long int)toLowercase(table, character) << 8;
 1045|      0|					character2 = getChar(input->chars[pos + 1], table);
 1046|      0|					makeHash += (unsigned long int)toLowercase(table, character2);
 1047|      0|					makeHash %= HASHNUM;
 1048|      0|					ruleOffset = table->forRules[makeHash];
 1049|      0|					break;
 1050|      0|				case 1:
 1051|      0|					if (!(length >= 1)) break;
 1052|      0|					length = 1;
 1053|      0|					ruleOffset = character->otherRules;
 1054|      0|					break;
 1055|      0|				case 2: /* No rule found */
 1056|      0|					currentOpcode = CTO_Always;
 1057|      0|					ruleOffset = 0;
 1058|      0|					break;
 1059|      0|				}
 1060|      0|				while (ruleOffset) {
 1061|      0|					currentRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];
 1062|      0|					currentOpcode = currentRule->opcode;
 1063|      0|					int currentCharslen = currentRule->charslen;
 1064|      0|					if (tryThis == 1 ||
 1065|      0|							(currentCharslen <= length &&
 1066|      0|									compareChars(&currentRule->charsdots[0],
 1067|      0|											&input->chars[pos], currentCharslen,
 1068|      0|											table))) {
 1069|      0|						if (currentOpcode == CTO_Correct &&
 1070|      0|								back_passDoTest(table, pos, input, currentOpcode,
 1071|      0|										currentRule, &passInstructions, &passIC,
 1072|      0|										&patternMatch)) {
 1073|      0|							tryThis = 4;
 1074|      0|							break;
 1075|      0|						}
 1076|      0|					}
 1077|      0|					ruleOffset = currentRule->dotsnext;
 1078|      0|				}
 1079|      0|				tryThis++;
 1080|      0|			}
 1081|      0|		switch (currentOpcode) {
 1082|      0|		case CTO_Always:
 1083|      0|			if (output->length >= output->maxlength) goto failure;
 1084|      0|			posMapping[pos] = output->length;
 1085|      0|			output->chars[(output->length)++] = input->chars[pos++];
 1086|      0|			break;
 1087|      0|		case CTO_Correct:
 1088|      0|			if (appliedRules != NULL && *appliedRulesCount < maxAppliedRules)
 1089|      0|				appliedRules[(*appliedRulesCount)++] = currentRule;
 1090|      0|			if (!back_passDoAction(table, &pos, mode, input, output, posMapping,
 1091|      0|						cursorPosition, cursorStatus, &nextUpper, allUpper,
 1092|      0|						allUpperPhrase, currentOpcode, currentRule, passInstructions,
 1093|      0|						passIC, patternMatch))
 1094|      0|				goto failure;
 1095|      0|			break;
 1096|      0|		default:
 1097|      0|			break;
 1098|      0|		}
 1099|      0|		posIncremented = pos > posBefore;
 1100|      0|	}
 1101|      0|failure:
 1102|      0|	*realInlen = pos;
 1103|      0|	return 1;
 1104|      0|}
 1105|       |
 1106|       |static int
 1107|       |backTranslateString(const TranslationTableHeader *table, int mode, int currentPass,
 1108|       |		const InString *input, OutString *output, char *spacebuf, int *posMapping,
 1109|       |		int *realInlen, int *cursorPosition, int *cursorStatus,
 1110|       |		const TranslationTableRule **appliedRules, int *appliedRulesCount,
 1111|      0|		int maxAppliedRules) {
 1112|      0|	int pos;
 1113|      0|	int nextUpper;
 1114|      0|	int allUpper;
 1115|      0|	int allUpperPhrase;
 1116|      0|	int itsANumber;
 1117|      0|	int itsALetter;
 1118|      0|	/* Back translation */
 1119|      0|	int srcword = 0;
 1120|      0|	int destword = 0; /* last word translated */
 1121|      0|	TranslationTableOpcode previousOpcode;
 1122|      0|	int doingMultind = 0;
 1123|      0|	const TranslationTableRule *multindRule;
 1124|      0|	_lou_resetPassVariables();
 1125|      0|	translation_direction = 0;
 1126|      0|	nextUpper = allUpper = allUpperPhrase = itsANumber = itsALetter = 0;
 1127|      0|	previousOpcode = CTO_None;
 1128|      0|	pos = output->length = 0;
 1129|      0|	while (pos < input->length) {
 1130|      0|		/* the main translation loop */
 1131|      0|		int currentDotslen; /* length of current find string */
 1132|      0|		TranslationTableOpcode currentOpcode;
 1133|      0|		const TranslationTableRule *currentRule; /* pointer to current rule in table */
 1134|      0|		TranslationTableCharacterAttributes beforeAttributes;
 1135|      0|		const widechar *passInstructions;
 1136|      0|		int passIC; /* Instruction counter */
 1137|      0|		PassRuleMatch patternMatch;
 1138|      0|		back_setBefore(table, output, &beforeAttributes);
 1139|      0|		if ((allUpper == 1) && (beforeAttributes & CTC_UpperCase))
 1140|      0|			// Capsword in progress
 1141|      0|			allUpper = 2;
 1142|      0|		else if ((allUpper == 2) && !(beforeAttributes & CTC_UpperCase) &&
 1143|      0|				!(beforeAttributes & CTC_CapsMode))
 1144|      0|			// terminate capsword
 1145|      0|			allUpper = 0;
 1146|      0|		if ((itsANumber == 2) && output->length > 0 &&
 1147|      0|				!(beforeAttributes & CTC_LitDigit) &&
 1148|      0|				!(beforeAttributes & CTC_NumericMode) &&
 1149|      0|				!(beforeAttributes & CTC_MidEndNumericMode))
 1150|      0|			itsANumber = 0;
 1151|      0|		back_selectRule(table, pos, mode, input, output, itsANumber, itsALetter,
 1152|      0|				&currentDotslen, &currentOpcode, &currentRule, previousOpcode,
 1153|      0|				&doingMultind, &multindRule, beforeAttributes, &passInstructions, &passIC,
 1154|      0|				&patternMatch);
 1155|      0|		if (appliedRules != NULL && *appliedRulesCount < maxAppliedRules)
 1156|      0|			appliedRules[(*appliedRulesCount)++] = currentRule;
 1157|      0|		/* processing before replacement */
 1158|      0|		switch (currentOpcode) {
 1159|      0|		case CTO_LargeSign:
 1160|      0|			if (previousOpcode == CTO_LargeSign)
 1161|      0|				if (!insertSpace(table, pos, input, output, spacebuf, posMapping,
 1162|      0|							cursorPosition, cursorStatus, &nextUpper, allUpper,
 1163|      0|							allUpperPhrase))
 1164|      0|					goto failure;
 1165|      0|			break;
 1166|      0|		case CTO_CapsLetterRule:
 1167|      0|			nextUpper = 1;
 1168|      0|			allUpper = 0;
 1169|      0|			itsANumber = 0;
 1170|      0|			while (currentDotslen-- > 0) posMapping[pos++] = output->length;
 1171|      0|			continue;
 1172|      0|			break;
 1173|      0|		case CTO_BegCapsWordRule:
 1174|      0|			allUpper = 1;
 1175|      0|			itsANumber = 0;
 1176|      0|			while (currentDotslen-- > 0) posMapping[pos++] = output->length;
 1177|      0|			continue;
 1178|      0|			break;
 1179|      0|		case CTO_BegCapsRule:
 1180|      0|			allUpperPhrase = 1;
 1181|      0|			itsANumber = 0;
 1182|      0|			while (currentDotslen-- > 0) posMapping[pos++] = output->length;
 1183|      0|			continue;
 1184|      0|			break;
 1185|      0|		case CTO_EndCapsWordRule:
 1186|      0|			allUpper = 0;
 1187|      0|			itsANumber = 0;
 1188|      0|			while (currentDotslen-- > 0) posMapping[pos++] = output->length;
 1189|      0|			continue;
 1190|      0|			break;
 1191|      0|		case CTO_EndCapsRule:
 1192|      0|			allUpperPhrase = 0;
 1193|      0|			itsANumber = 0;
 1194|      0|			while (currentDotslen-- > 0) posMapping[pos++] = output->length;
 1195|      0|			continue;
 1196|      0|			break;
 1197|      0|		case CTO_LetterRule:
 1198|      0|		case CTO_NoContractRule:
 1199|      0|			itsALetter = 1;
 1200|      0|			itsANumber = 0;
 1201|      0|			while (currentDotslen-- > 0) posMapping[pos++] = output->length;
 1202|      0|			continue;
 1203|      0|			break;
 1204|      0|		case CTO_NumberRule:
 1205|      0|			itsANumber = 1;	 // Starting number
 1206|      0|			allUpper = 0;
 1207|      0|			while (currentDotslen-- > 0) posMapping[pos++] = output->length;
 1208|      0|			continue;
 1209|      0|			break;
 1210|      0|		case CTO_LitDigit:
 1211|      0|			itsANumber = 2;	 // In the middle of a number
 1212|      0|			break;
 1213|      0|		case CTO_BegCompRule:
 1214|      0|			itsANumber = 0;
 1215|      0|		case CTO_BegEmph1Rule:
 1216|      0|		case CTO_BegEmph2Rule:
 1217|      0|		case CTO_BegEmph3Rule:
 1218|      0|		case CTO_EndEmph1Rule:
 1219|      0|		case CTO_EndEmph2Rule:
 1220|      0|		case CTO_EndEmph3Rule:
 1221|      0|		case CTO_EndCompRule:
 1222|      0|			while (currentDotslen-- > 0) posMapping[pos++] = output->length;
 1223|      0|			continue;
 1224|      0|			break;
 1225|      0|
 1226|      0|		default:
 1227|      0|			break;
 1228|      0|		}
 1229|      0|
 1230|      0|		/* replacement processing */
 1231|      0|		switch (currentOpcode) {
 1232|      0|		case CTO_Context:
 1233|      0|			if (!back_passDoAction(table, &pos, mode, input, output, posMapping,
 1234|      0|						cursorPosition, cursorStatus, &nextUpper, allUpper,
 1235|      0|						allUpperPhrase, currentOpcode, currentRule, passInstructions,
 1236|      0|						passIC, patternMatch))
 1237|      0|				return 0;
 1238|      0|			break;
 1239|      0|		case CTO_Replace:
 1240|      0|			while (currentDotslen-- > 0) posMapping[pos++] = output->length;
 1241|      0|			if (!putCharacters(&currentRule->charsdots[0], currentRule->charslen, table,
 1242|      0|						pos, mode, input, output, posMapping, cursorPosition,
 1243|      0|						cursorStatus, &nextUpper, allUpper, allUpperPhrase))
 1244|      0|				goto failure;
 1245|      0|			break;
 1246|      0|		case CTO_None:
 1247|      0|			if (!undefinedDots(input->chars[pos], mode, output, pos, posMapping))
 1248|      0|				goto failure;
 1249|      0|			pos++;
 1250|      0|			break;
 1251|      0|		case CTO_BegNum:
 1252|      0|			itsANumber = 1;
 1253|      0|			goto insertChars;
 1254|      0|		case CTO_EndNum:
 1255|      0|			itsANumber = 0;
 1256|      0|			goto insertChars;
 1257|      0|		case CTO_Space:
 1258|      0|			itsALetter = itsANumber = allUpper = nextUpper = 0;
 1259|      0|			goto insertChars;
 1260|      0|		default:
 1261|      0|		insertChars:
 1262|      0|			if (currentRule->charslen) {
 1263|      0|				if (!back_updatePositions(&currentRule->charsdots[0],
 1264|      0|							currentRule->dotslen, currentRule->charslen, table, pos,
 1265|      0|							input, output, posMapping, cursorPosition, cursorStatus,
 1266|      0|							&nextUpper, allUpper, allUpperPhrase))
 1267|      0|					goto failure;
 1268|      0|				pos += currentDotslen;
 1269|      0|			} else {
 1270|      0|				int srclim = pos + currentDotslen;
 1271|      0|				while (1) {
 1272|      0|					if (!putCharacter(input->chars[pos], table, pos, mode, input, output,
 1273|      0|								posMapping, cursorPosition, cursorStatus, &nextUpper,
 1274|      0|								allUpper, allUpperPhrase))
 1275|      0|						goto failure;
 1276|      0|					if (++pos == srclim) break;
 1277|      0|				}
 1278|      0|			}
 1279|      0|		}
 1280|      0|
 1281|      0|		/* processing after replacement */
 1282|      0|		switch (currentOpcode) {
 1283|      0|		case CTO_JoinNum:
 1284|      0|		case CTO_JoinableWord:
 1285|      0|			if (!insertSpace(table, pos, input, output, spacebuf, posMapping,
 1286|      0|						cursorPosition, cursorStatus, &nextUpper, allUpper,
 1287|      0|						allUpperPhrase))
 1288|      0|				goto failure;
 1289|      0|			break;
 1290|      0|		default:
 1291|      0|			passSelectRule(table, pos, currentPass, input, &currentOpcode, &currentRule,
 1292|      0|					&passInstructions, &passIC, &patternMatch);
 1293|      0|			if (currentOpcode == CTO_Context) {
 1294|      0|				back_passDoAction(table, &pos, mode, input, output, posMapping,
 1295|      0|						cursorPosition, cursorStatus, &nextUpper, allUpper,
 1296|      0|						allUpperPhrase, currentOpcode, currentRule, passInstructions,
 1297|      0|						passIC, patternMatch);
 1298|      0|			}
 1299|      0|			break;
 1300|      0|		}
 1301|      0|		if (((pos > 0) && checkDotsAttr(input->chars[pos - 1], CTC_Space, table) &&
 1302|      0|					(currentOpcode != CTO_JoinableWord))) {
 1303|      0|			srcword = pos;
 1304|      0|			destword = output->length;
 1305|      0|		}
 1306|      0|		if ((currentOpcode >= CTO_Always && currentOpcode <= CTO_None) ||
 1307|      0|				(currentOpcode >= CTO_Digit && currentOpcode <= CTO_LitDigit))
 1308|      0|			previousOpcode = currentOpcode;
 1309|      0|	} /* end of translation loop */
 1310|      0|failure:
 1311|      0|
 1312|      0|	if (destword != 0 && pos < input->length &&
 1313|      0|			!checkDotsAttr(input->chars[pos], CTC_Space, table)) {
 1314|      0|		pos = srcword;
 1315|      0|		output->length = destword;
 1316|      0|	}
 1317|      0|	if (pos < input->length) {
 1318|      0|		while (checkDotsAttr(input->chars[pos], CTC_Space, table))
 1319|      0|			if (++pos == input->length) break;
 1320|      0|	}
 1321|      0|	*realInlen = pos;
 1322|      0|	return 1;
 1323|      0|} /* translation completed */
 1324|       |
 1325|       |/* Multipass translation */
 1326|       |
 1327|       |static int
 1328|       |matchCurrentInput(
 1329|      0|		const InString *input, int pos, const widechar *passInstructions, int passIC) {
 1330|      0|	int k;
 1331|      0|	int kk = pos;
 1332|      0|	for (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)
 1333|      0|		if (passInstructions[k] != input->chars[kk++]) return 0;
 1334|      0|	return 1;
 1335|      0|}
 1336|       |
 1337|       |static int
 1338|       |back_swapTest(const TranslationTableHeader *table, const InString *input, int *pos,
 1339|      0|		const widechar *passInstructions, int passIC) {
 1340|      0|	int curLen;
 1341|      0|	int curTest;
 1342|      0|	int curSrc = *pos;
 1343|      0|	TranslationTableOffset swapRuleOffset;
 1344|      0|	TranslationTableRule *swapRule;
 1345|      0|	swapRuleOffset = (passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];
 1346|      0|	swapRule = (TranslationTableRule *)&table->ruleArea[swapRuleOffset];
 1347|      0|	for (curLen = 0; curLen < passInstructions[passIC] + 3; curLen++) {
 1348|      0|		for (curTest = 0; curTest < swapRule->charslen; curTest++) {
 1349|      0|			if (input->chars[curSrc] == swapRule->charsdots[curTest]) break;
 1350|      0|		}
 1351|      0|		if (curTest == swapRule->charslen) return 0;
 1352|      0|		curSrc++;
 1353|      0|	}
 1354|      0|	if (passInstructions[passIC + 2] == passInstructions[passIC + 3]) {
 1355|      0|		*pos = curSrc;
 1356|      0|		return 1;
 1357|      0|	}
 1358|      0|	while (curLen < passInstructions[passIC + 4]) {
 1359|      0|		for (curTest = 0; curTest < swapRule->charslen; curTest++) {
 1360|      0|			if (input->chars[curSrc] != swapRule->charsdots[curTest]) break;
 1361|      0|		}
 1362|      0|		if (curTest < swapRule->charslen)
 1363|      0|			if (curTest < swapRule->charslen) {
 1364|      0|				*pos = curSrc;
 1365|      0|				return 1;
 1366|      0|			}
 1367|      0|		curSrc++;
 1368|      0|		curLen++;
 1369|      0|	}
 1370|      0|	*pos = curSrc;
 1371|      0|	return 1;
 1372|      0|}
 1373|       |
 1374|       |static int
 1375|       |back_swapReplace(int start, int end, const TranslationTableHeader *table,
 1376|       |		const InString *input, OutString *output, int *posMapping,
 1377|      0|		const widechar *passInstructions, int passIC) {
 1378|      0|	TranslationTableOffset swapRuleOffset;
 1379|      0|	TranslationTableRule *swapRule;
 1380|      0|	widechar *replacements;
 1381|      0|	int p;
 1382|      0|	int lastPos = 0;
 1383|      0|	int lastRep = 0;
 1384|      0|	swapRuleOffset = (passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];
 1385|      0|	swapRule = (TranslationTableRule *)&table->ruleArea[swapRuleOffset];
 1386|      0|	replacements = &swapRule->charsdots[swapRule->charslen];
 1387|      0|	for (p = start; p < end; p++) {
 1388|      0|		int rep;
 1389|      0|		int test;
 1390|      0|		int k;
 1391|      0|		for (test = 0; test < swapRule->charslen; test++)
 1392|      0|			if (input->chars[p] == swapRule->charsdots[test]) break;
 1393|      0|		if (test == swapRule->charslen) return p;
 1394|      0|		if (test >= lastRep) {
 1395|      0|			k = lastPos;
 1396|      0|			rep = lastRep;
 1397|      0|		} else {
 1398|      0|			k = 0;
 1399|      0|			rep = 0;
 1400|      0|		}
 1401|      0|		while (k < swapRule->dotslen) {
 1402|      0|			if (rep == test) {
 1403|      0|				int l = replacements[k] - 1;
 1404|      0|				if (output->length + l >= output->maxlength) return 0;
 1405|      0|				posMapping[p] = output->length;
 1406|      0|				memcpy(&output->chars[output->length], &replacements[k + 1],
 1407|      0|						l * CHARSIZE);
 1408|      0|				output->length += l;
 1409|      0|				lastPos = k;
 1410|      0|				lastRep = rep;
 1411|      0|				break;
 1412|      0|			}
 1413|      0|			rep++;
 1414|      0|			k += replacements[k];
 1415|      0|		}
 1416|      0|	}
 1417|      0|	return p;
 1418|      0|}
 1419|       |
 1420|       |static int
 1421|       |back_passDoTest(const TranslationTableHeader *table, int pos, const InString *input,
 1422|       |		TranslationTableOpcode currentOpcode, const TranslationTableRule *currentRule,
 1423|      0|		const widechar **passInstructions, int *passIC, PassRuleMatch *match) {
 1424|      0|	int k;
 1425|      0|	int m;
 1426|      0|	int not = 0;
 1427|      0|	TranslationTableCharacterAttributes attributes;
 1428|      0|	*passInstructions = &currentRule->charsdots[currentRule->charslen];
 1429|      0|	*passIC = 0;
 1430|      0|	match->startMatch = match->endMatch = pos;
 1431|      0|	match->startReplace = -1;
 1432|      0|	if (currentOpcode == CTO_Correct)
 1433|      0|		m = 0;
 1434|      0|	else
 1435|      0|		m = 1;
 1436|      0|	while (*passIC < currentRule->dotslen) {
 1437|      0|		int itsTrue = 1;
 1438|      0|		if (pos > input->length) return 0;
 1439|      0|		switch ((*passInstructions)[*passIC]) {
 1440|      0|		case pass_first:
 1441|      0|			if (pos != 0) itsTrue = 0;
 1442|      0|			(*passIC)++;
 1443|      0|			break;
 1444|      0|		case pass_last:
 1445|      0|			if (pos != input->length) itsTrue = 0;
 1446|      0|			(*passIC)++;
 1447|      0|			break;
 1448|      0|		case pass_lookback:
 1449|      0|			pos -= (*passInstructions)[*passIC + 1];
 1450|      0|			if (pos < 0) {
 1451|      0|				pos = 0;
 1452|      0|				itsTrue = 0;
 1453|      0|			}
 1454|      0|			*passIC += 2;
 1455|      0|			break;
 1456|      0|		case pass_not:
 1457|      0|			not = !not;
 1458|      0|			(*passIC)++;
 1459|      0|			continue;
 1460|      0|		case pass_string:
 1461|      0|		case pass_dots:
 1462|      0|			itsTrue = matchCurrentInput(input, pos, *passInstructions, *passIC);
 1463|      0|			pos += (*passInstructions)[*passIC + 1];
 1464|      0|			*passIC += (*passInstructions)[*passIC + 1] + 2;
 1465|      0|			break;
 1466|      0|		case pass_startReplace:
 1467|      0|			match->startReplace = pos;
 1468|      0|			(*passIC)++;
 1469|      0|			break;
 1470|      0|		case pass_endReplace:
 1471|      0|			match->endReplace = pos;
 1472|      0|			(*passIC)++;
 1473|      0|			break;
 1474|      0|		case pass_attributes:
 1475|      0|			attributes = (*passInstructions)[*passIC + 1];
 1476|      0|			attributes <<= 16;
 1477|      0|			attributes |= (*passInstructions)[*passIC + 2];
 1478|      0|			attributes <<= 16;
 1479|      0|			attributes |= (*passInstructions)[*passIC + 3];
 1480|      0|			attributes <<= 16;
 1481|      0|			attributes |= (*passInstructions)[*passIC + 4];
 1482|      0|			for (k = 0; k < (*passInstructions)[*passIC + 5]; k++) {
 1483|      0|				if (pos >= input->length) {
 1484|      0|					itsTrue = 0;
 1485|      0|					break;
 1486|      0|				}
 1487|      0|				if (!((m ? getDots(input->chars[pos], table)
 1488|      0|						 : getChar(input->chars[pos], table))
 1489|      0|									->attributes &
 1490|      0|							attributes)) {
 1491|      0|					itsTrue = 0;
 1492|      0|					break;
 1493|      0|				}
 1494|      0|				pos++;
 1495|      0|			}
 1496|      0|			if (itsTrue) {
 1497|      0|				for (k = (*passInstructions)[*passIC + 5];
 1498|      0|						k < (*passInstructions)[*passIC + 6] && pos < input->length;
 1499|      0|						k++) {
 1500|      0|					if (!((m ? getDots(input->chars[pos], table)
 1501|      0|							 : getChar(input->chars[pos], table))
 1502|      0|										->attributes &
 1503|      0|								attributes))
 1504|      0|						break;
 1505|      0|					pos++;
 1506|      0|				}
 1507|      0|			}
 1508|      0|			*passIC += 7;
 1509|      0|			break;
 1510|      0|		case pass_swap:
 1511|      0|			itsTrue = back_swapTest(table, input, &pos, *passInstructions, *passIC);
 1512|      0|			*passIC += 5;
 1513|      0|			break;
 1514|      0|		case pass_endTest: {
 1515|      0|			(*passIC)++;
 1516|      0|			match->endMatch = pos;
 1517|      0|			if (match->startReplace == -1) {
 1518|      0|				match->startReplace = match->startMatch;
 1519|      0|				match->endReplace = match->endMatch;
 1520|      0|			}
 1521|      0|			return 1;
 1522|      0|			break;
 1523|      0|		}
 1524|      0|		default:
 1525|      0|			if (_lou_handlePassVariableTest(*passInstructions, passIC, &itsTrue)) break;
 1526|      0|			return 0;
 1527|      0|		}
 1528|      0|		if ((!not&&!itsTrue) || (not&&itsTrue)) return 0;
 1529|      0|		not = 0;
 1530|      0|	}
 1531|      0|	return 1;
 1532|      0|}
 1533|       |
 1534|       |static int
 1535|       |copyCharacters(int from, int to, const TranslationTableHeader *table, int mode,
 1536|       |		const InString *input, OutString *output, int *posMapping, int *cursorPosition,
 1537|       |		int *cursorStatus, int *nextUpper, int allUpper, int allUpperPhrase,
 1538|      0|		TranslationTableOpcode currentOpcode) {
 1539|      0|	if (currentOpcode == CTO_Context) {
 1540|      0|		while (from < to) {
 1541|      0|			if (!putCharacter(input->chars[from], table, from, mode, input, output,
 1542|      0|						posMapping, cursorPosition, cursorStatus, nextUpper, allUpper,
 1543|      0|						allUpperPhrase))
 1544|      0|				return 0;
 1545|      0|			from++;
 1546|      0|		}
 1547|      0|	} else {
 1548|      0|		if (to > from) {
 1549|      0|			if ((output->length + to - from) > output->maxlength) return 0;
 1550|      0|			while (to > from) {
 1551|      0|				posMapping[from] = output->length;
 1552|      0|				output->chars[output->length] = input->chars[from];
 1553|      0|				output->length++;
 1554|      0|				from++;
 1555|      0|			}
 1556|      0|		}
 1557|      0|	}
 1558|      0|
 1559|      0|	return 1;
 1560|      0|}
 1561|       |
 1562|       |static int
 1563|       |back_passDoAction(const TranslationTableHeader *table, int *pos, int mode,
 1564|       |		const InString *input, OutString *output, int *posMapping, int *cursorPosition,
 1565|       |		int *cursorStatus, int *nextUpper, int allUpper, int allUpperPhrase,
 1566|       |		TranslationTableOpcode currentOpcode, const TranslationTableRule *currentRule,
 1567|      0|		const widechar *passInstructions, int passIC, PassRuleMatch match) {
 1568|      0|	int k;
 1569|      0|	int destStartMatch = output->length;
 1570|      0|	int destStartReplace;
 1571|      0|	int newPos = match.endReplace;
 1572|      0|
 1573|      0|	if (!copyCharacters(match.startMatch, match.startReplace, table, mode, input, output,
 1574|      0|				posMapping, cursorPosition, cursorStatus, nextUpper, allUpper,
 1575|      0|				allUpperPhrase, currentOpcode))
 1576|      0|		return 0;
 1577|      0|	destStartReplace = output->length;
 1578|      0|
 1579|      0|	for (k = match.startReplace; k < match.endReplace; k++)
 1580|      0|		posMapping[k] = output->length;
 1581|      0|	while (passIC < currentRule->dotslen) switch (passInstructions[passIC]) {
 1582|      0|		case pass_string:
 1583|      0|		case pass_dots:
 1584|      0|			if ((output->length + passInstructions[passIC + 1]) > output->maxlength)
 1585|      0|				return 0;
 1586|      0|			memcpy(&output->chars[output->length], &passInstructions[passIC + 2],
 1587|      0|					passInstructions[passIC + 1] * sizeof(*output->chars));
 1588|      0|			output->length += passInstructions[passIC + 1];
 1589|      0|			passIC += passInstructions[passIC + 1] + 2;
 1590|      0|			break;
 1591|      0|		case pass_swap:
 1592|      0|			if (!back_swapReplace(match.startReplace, match.endReplace, table, input,
 1593|      0|						output, posMapping, passInstructions, passIC))
 1594|      0|				return 0;
 1595|      0|			passIC += 3;
 1596|      0|			break;
 1597|      0|		case pass_omit:
 1598|      0|			passIC++;
 1599|      0|			break;
 1600|      0|		case pass_copy: {
 1601|      0|			int count = destStartReplace - destStartMatch;
 1602|      0|			if (count > 0) {
 1603|      0|				memmove(&output->chars[destStartMatch], &output->chars[destStartReplace],
 1604|      0|						count * sizeof(*output->chars));
 1605|      0|				output->length -= count;
 1606|      0|				destStartReplace = destStartMatch;
 1607|      0|			}
 1608|      0|		}
 1609|      0|
 1610|      0|			if (!copyCharacters(match.startReplace, match.endReplace, table, mode, input,
 1611|      0|						output, posMapping, cursorPosition, cursorStatus, nextUpper,
 1612|      0|						allUpper, allUpperPhrase, currentOpcode))
 1613|      0|				return 0;
 1614|      0|			newPos = match.endMatch;
 1615|      0|			passIC++;
 1616|      0|			break;
 1617|      0|		default:
 1618|      0|			if (_lou_handlePassVariableAction(passInstructions, &passIC)) break;
 1619|      0|			return 0;
 1620|      0|		}
 1621|      0|	*pos = newPos;
 1622|      0|	return 1;
 1623|      0|}
 1624|       |
 1625|       |static void
 1626|       |passSelectRule(const TranslationTableHeader *table, int pos, int currentPass,
 1627|       |		const InString *input, TranslationTableOpcode *currentOpcode,
 1628|       |		const TranslationTableRule **currentRule, const widechar **passInstructions,
 1629|      0|		int *passIC, PassRuleMatch *match) {
 1630|      0|	if (!findBackPassRule(table, pos, currentPass, input, currentOpcode, currentRule,
 1631|      0|				passInstructions, passIC, match)) {
 1632|      0|		*currentOpcode = CTO_Always;
 1633|      0|	}
 1634|      0|}
 1635|       |
 1636|       |static int
 1637|       |translatePass(const TranslationTableHeader *table, int mode, int currentPass,
 1638|       |		const InString *input, OutString *output, int *posMapping, int *realInlen,
 1639|       |		int *cursorPosition, int *cursorStatus, const TranslationTableRule **appliedRules,
 1640|      0|		int *appliedRulesCount, int maxAppliedRules) {
 1641|      0|	int pos;
 1642|      0|	int posIncremented = 1;
 1643|      0|	int nextUpper = 0;
 1644|      0|	int allUpper = 0;
 1645|      0|	int allUpperPhrase = 0;
 1646|      0|	pos = output->length = 0;
 1647|      0|	_lou_resetPassVariables();
 1648|      0|	while (pos < input->length) { /* the main multipass translation loop */
 1649|      0|		int posBefore = pos;
 1650|      0|		TranslationTableOpcode currentOpcode;
 1651|      0|		const TranslationTableRule *currentRule; /* pointer to current rule in table */
 1652|      0|		const widechar *passInstructions;
 1653|      0|		int passIC; /* Instruction counter */
 1654|      0|		PassRuleMatch patternMatch;
 1655|      0|		if (!posIncremented)
 1656|      0|			currentOpcode = CTO_Always;
 1657|      0|		else
 1658|      0|			passSelectRule(table, pos, currentPass, input, &currentOpcode, &currentRule,
 1659|      0|					&passInstructions, &passIC, &patternMatch);
 1660|      0|		switch (currentOpcode) {
 1661|      0|		case CTO_Pass2:
 1662|      0|		case CTO_Pass3:
 1663|      0|		case CTO_Pass4:
 1664|      0|			if (appliedRules != NULL && *appliedRulesCount < maxAppliedRules)
 1665|      0|				appliedRules[(*appliedRulesCount)++] = currentRule;
 1666|      0|			if (!back_passDoAction(table, &pos, mode, input, output, posMapping,
 1667|      0|						cursorPosition, cursorStatus, &nextUpper, allUpper,
 1668|      0|						allUpperPhrase, currentOpcode, currentRule, passInstructions,
 1669|      0|						passIC, patternMatch))
 1670|      0|				goto failure;
 1671|      0|			break;
 1672|      0|		case CTO_Always:
 1673|      0|			if ((output->length + 1) > output->maxlength) goto failure;
 1674|      0|			posMapping[pos] = output->length;
 1675|      0|			output->chars[(output->length)++] = input->chars[pos++];
 1676|      0|			break;
 1677|      0|		default:
 1678|      0|			goto failure;
 1679|      0|		}
 1680|      0|		posIncremented = pos > posBefore;
 1681|      0|	}
 1682|      0|failure:
 1683|      0|	if (pos < input->length) {
 1684|      0|		while (checkDotsAttr(input->chars[pos], CTC_Space, table))
 1685|      0|			if (++pos == input->length) break;
 1686|      0|	}
 1687|      0|	*realInlen = pos;
 1688|      0|	return 1;
 1689|      0|}

/home/vito/MASTER_CSI/S2/TER/fuzzing/liblouis/liblouis/lou_translateString.c:
    1|       |/* liblouis Braille Translation and Back-Translation Library
    2|       |
    3|       |   Based on the Linux screenreader BRLTTY, copyright (C) 1999-2006 by The
    4|       |   BRLTTY Team
    5|       |
    6|       |   Copyright (C) 2004, 2005, 2006 ViewPlus Technologies, Inc. www.viewplus.com
    7|       |   Copyright (C) 2004, 2005, 2006 JJB Software, Inc. www.jjb-software.com
    8|       |   Copyright (C) 2016 Mike Gray, American Printing House for the Blind
    9|       |   Copyright (C) 2016 Davy Kager, Dedicon
   10|       |
   11|       |   This file is part of liblouis.
   12|       |
   13|       |   liblouis is free software: you can redistribute it and/or modify it
   14|       |   under the terms of the GNU Lesser General Public License as published
   15|       |   by the Free Software Foundation, either version 2.1 of the License, or
   16|       |   (at your option) any later version.
   17|       |
   18|       |   liblouis is distributed in the hope that it will be useful, but
   19|       |   WITHOUT ANY WARRANTY; without even the implied warranty of
   20|       |   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
   21|       |   Lesser General Public License for more details.
   22|       |
   23|       |   You should have received a copy of the GNU Lesser General Public
   24|       |   License along with liblouis. If not, see <http://www.gnu.org/licenses/>.
   25|       |*/
   26|       |
   27|       |/**
   28|       | * @file
   29|       | * @brief Translate to braille
   30|       | */
   31|       |
   32|       |#include <stdio.h>
   33|       |#include <stdlib.h>
   34|       |#include <string.h>
   35|       |
   36|       |#include "internal.h"
   37|       |
   38|       |/* additional bits in typebuf */
   39|      0|#define SYLLABLE_MARKER_1 0x2000
   40|      0|#define SYLLABLE_MARKER_2 0x4000
   41|      0|#define CAPSEMPH 0x8000
   42|       |
   43|      0|#define EMPHASIS 0x3fff	 // all typeform bits that can be used
   44|       |
   45|       |/* bits for wordBuffer */
   46|      0|#define WORD_CHAR 0x00000001
   47|      0|#define WORD_RESET 0x00000002
   48|      0|#define WORD_WHOLE 0x00000004
   49|       |
   50|       |typedef struct {
   51|       |	int size;
   52|       |	widechar **buffers;
   53|       |	int *inUse;
   54|       |	widechar *(*alloc)(int index, int length);
   55|       |	void (*free)(widechar *);
   56|       |} StringBufferPool;
   57|       |
   58|       |static widechar *
   59|      0|allocStringBuffer(int index, int length) {
   60|      0|	return _lou_allocMem(alloc_passbuf, index, 0, length);
   61|      0|}
   62|       |
   63|       |static const StringBufferPool *stringBufferPool = NULL;
   64|       |
   65|       |static void
   66|      0|initStringBufferPool() {
   67|      0|	static widechar *stringBuffers[MAXPASSBUF] = { NULL };
   68|      0|	static int stringBuffersInUse[MAXPASSBUF] = { 0 };
   69|      0|	StringBufferPool *pool = malloc(sizeof(StringBufferPool));
   70|      0|	pool->size = MAXPASSBUF;
   71|      0|	pool->buffers = stringBuffers;
   72|      0|	pool->inUse = stringBuffersInUse;
   73|      0|	pool->alloc = &allocStringBuffer;
   74|      0|	pool->free = NULL;
   75|      0|	stringBufferPool = pool;
   76|      0|}
   77|       |
   78|       |static int
   79|      0|getStringBuffer(int length) {
   80|      0|	int i;
   81|      0|	for (i = 0; i < stringBufferPool->size; i++) {
   82|      0|		if (!stringBufferPool->inUse[i]) {
   83|      0|			stringBufferPool->buffers[i] = stringBufferPool->alloc(i, length);
   84|      0|			stringBufferPool->inUse[i] = 1;
   85|      0|			return i;
   86|      0|		}
   87|      0|	}
   88|      0|	_lou_outOfMemory();
   89|      0|	return -1;
   90|      0|}
   91|       |
   92|       |static int
   93|      0|releaseStringBuffer(int idx) {
   94|      0|	if (idx >= 0 && idx < stringBufferPool->size) {
   95|      0|		int inUse = stringBufferPool->inUse[idx];
   96|      0|		if (inUse && stringBufferPool->free)
   97|      0|			stringBufferPool->free(stringBufferPool->buffers[idx]);
   98|      0|		stringBufferPool->inUse[idx] = 0;
   99|      0|		return inUse;
  100|      0|	}
  101|      0|	return 0;
  102|      0|}
  103|       |
  104|       |typedef struct {
  105|       |	int bufferIndex;
  106|       |	const widechar *chars;
  107|       |	int length;
  108|       |} InString;
  109|       |
  110|       |typedef struct {
  111|       |	int bufferIndex;
  112|       |	widechar *chars;
  113|       |	int maxlength;
  114|       |	int length;
  115|       |} OutString;
  116|       |
  117|       |typedef struct {
  118|       |	int startMatch;
  119|       |	int startReplace;
  120|       |	int endReplace;
  121|       |	int endMatch;
  122|       |} PassRuleMatch;
  123|       |
  124|       |static int
  125|       |putCharacter(widechar c, const TranslationTableHeader *table, int pos,
  126|       |		const InString *input, OutString *output, int *posMapping, int *cursorPosition,
  127|       |		int *cursorStatus, int mode);
  128|       |static int
  129|       |passDoTest(const TranslationTableHeader *table, int pos, const InString *input,
  130|       |		int transOpcode, const TranslationTableRule *transRule, int *passCharDots,
  131|       |		const widechar **passInstructions, int *passIC, PassRuleMatch *match,
  132|       |		TranslationTableRule **groupingRule, widechar *groupingOp);
  133|       |static int
  134|       |passDoAction(const TranslationTableHeader *table, const InString **input,
  135|       |		OutString *output, int *posMapping, int transOpcode,
  136|       |		const TranslationTableRule **transRule, int passCharDots,
  137|       |		const widechar *passInstructions, int passIC, int *pos, PassRuleMatch match,
  138|       |		int *cursorPosition, int *cursorStatus, TranslationTableRule *groupingRule,
  139|       |		widechar groupingOp, int mode);
  140|       |
  141|       |static const TranslationTableRule **appliedRules;
  142|       |static int maxAppliedRules;
  143|       |static int appliedRulesCount;
  144|       |
  145|       |static TranslationTableCharacter *
  146|      0|getChar(widechar c, const TranslationTableHeader *table) {
  147|      0|	static TranslationTableCharacter notFound = { NULL, -1, 0, 0, 0, CTC_Space, 0, 0, 32,
  148|      0|		0, 0 };
  149|      0|	const TranslationTableOffset bucket = table->characters[_lou_charHash(c)];
  150|      0|	TranslationTableOffset offset = bucket;
  151|      0|	while (offset) {
  152|      0|		TranslationTableCharacter *character =
  153|      0|				(TranslationTableCharacter *)&table->ruleArea[offset];
  154|      0|		if (character->value == c) return character;
  155|      0|		offset = character->next;
  156|      0|	}
  157|      0|	notFound.value = c;
  158|      0|	return &notFound;
  159|      0|}
  160|       |
  161|       |static TranslationTableCharacter *
  162|      0|getDots(widechar c, const TranslationTableHeader *table) {
  163|      0|	static TranslationTableCharacter notFound = { NULL, -1, 0, 0, 0, CTC_Space, 0, 0,
  164|      0|		LOU_DOTS, 0, 0 };
  165|      0|	const TranslationTableOffset bucket = table->dots[_lou_charHash(c)];
  166|      0|	TranslationTableOffset offset = bucket;
  167|      0|	while (offset) {
  168|      0|		TranslationTableCharacter *character =
  169|      0|				(TranslationTableCharacter *)&table->ruleArea[offset];
  170|      0|		if (character->value == c) return character;
  171|      0|		offset = character->next;
  172|      0|	}
  173|      0|	notFound.value = c;
  174|      0|	return &notFound;
  175|      0|}
  176|       |
  177|       |static int
  178|       |checkCharAttr(const widechar c, const TranslationTableCharacterAttributes a,
  179|      0|		const TranslationTableHeader *table) {
  180|      0|	return (((getChar(c, table))->attributes & a) ? 1 : 0);
  181|      0|}
  182|       |
  183|       |static int
  184|       |checkDotsAttr(const widechar c, const TranslationTableCharacterAttributes a,
  185|      0|		const TranslationTableHeader *table) {
  186|      0|	return (((getDots(c, table))->attributes & a) ? 1 : 0);
  187|      0|}
  188|       |
  189|       |static int
  190|       |checkCharAttr_safe(const InString *input, int pos,
  191|       |		const TranslationTableCharacterAttributes a,
  192|      0|		const TranslationTableHeader *table) {
  193|      0|	return ((pos < input->length) ? checkCharAttr(input->chars[pos], a, table) : 0);
  194|      0|}
  195|       |
  196|       |static int
  197|       |findForPassRule(const TranslationTableHeader *table, int pos, int currentPass,
  198|       |		const InString *input, int *transOpcode, const TranslationTableRule **transRule,
  199|       |		int *transCharslen, int *passCharDots, widechar const **passInstructions,
  200|       |		int *passIC, PassRuleMatch *match, TranslationTableRule **groupingRule,
  201|      0|		widechar *groupingOp) {
  202|      0|	int save_transCharslen = *transCharslen;
  203|      0|	const TranslationTableRule *save_transRule = *transRule;
  204|      0|	TranslationTableOpcode save_transOpcode = *transOpcode;
  205|      0|	TranslationTableOffset ruleOffset;
  206|      0|	ruleOffset = table->forPassRules[currentPass];
  207|      0|	*transCharslen = 0;
  208|      0|	while (ruleOffset) {
  209|      0|		*transRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];
  210|      0|		*transOpcode = (*transRule)->opcode;
  211|      0|		if (passDoTest(table, pos, input, *transOpcode, *transRule, passCharDots,
  212|      0|					passInstructions, passIC, match, groupingRule, groupingOp))
  213|      0|			return 1;
  214|      0|		ruleOffset = (*transRule)->charsnext;
  215|      0|	}
  216|      0|	*transCharslen = save_transCharslen;
  217|      0|	*transRule = save_transRule;
  218|      0|	*transOpcode = save_transOpcode;
  219|      0|	return 0;
  220|      0|}
  221|       |
  222|       |static widechar
  223|       |toLowercase(
  224|      0|		const TranslationTableHeader *table, const TranslationTableCharacter *character) {
  225|      0|	if (character->mode & CTC_UpperCase) {
  226|      0|		const TranslationTableCharacter *c = character;
  227|      0|		if (c->basechar) c = (TranslationTableCharacter *)&table->ruleArea[c->basechar];
  228|      0|		while (1) {
  229|      0|			if ((c->mode & (character->mode & ~CTC_UpperCase)) ==
  230|      0|					(character->mode & ~CTC_UpperCase))
  231|      0|				return c->value;
  232|      0|			if (!c->linked) break;
  233|      0|			c = (TranslationTableCharacter *)&table->ruleArea[c->linked];
  234|      0|		}
  235|      0|	}
  236|      0|	return character->value;
  237|      0|}
  238|       |
  239|       |static int
  240|       |compareChars(const widechar *address1, const widechar *address2, int count,
  241|      0|		const TranslationTableHeader *table) {
  242|      0|	int k;
  243|      0|	if (!count) return 0;
  244|      0|	for (k = 0; k < count; k++)
  245|      0|		if (toLowercase(table, getChar(address1[k], table)) !=
  246|      0|				toLowercase(table, getChar(address2[k], table)))
  247|      0|			return 0;
  248|      0|	return 1;
  249|      0|}
  250|       |
  251|       |static int
  252|       |makeCorrections(const TranslationTableHeader *table, const InString *input,
  253|       |		OutString *output, int *posMapping, formtype *typebuf, int *realInlen,
  254|      0|		int *cursorPosition, int *cursorStatus, int mode) {
  255|      0|	int pos;
  256|      0|	int transOpcode;
  257|      0|	const TranslationTableRule *transRule;
  258|      0|	int transCharslen;
  259|      0|	int passCharDots;
  260|      0|	const widechar *passInstructions;
  261|      0|	int passIC; /* Instruction counter */
  262|      0|	PassRuleMatch patternMatch;
  263|      0|	TranslationTableRule *groupingRule;
  264|      0|	widechar groupingOp;
  265|      0|	const InString *origInput = input;
  266|      0|	if (!table->corrections) return 1;
  267|      0|	pos = 0;
  268|      0|	output->length = 0;
  269|      0|	int posIncremented = 1;
  270|      0|	_lou_resetPassVariables();
  271|      0|	while (pos < input->length) {
  272|      0|		int length = input->length - pos;
  273|      0|		int tryThis = 0;
  274|      0|		// check posIncremented to avoid endless loop
  275|      0|		if (!(posIncremented &&
  276|      0|					findForPassRule(table, pos, 0, input, &transOpcode, &transRule,
  277|      0|							&transCharslen, &passCharDots, &passInstructions, &passIC,
  278|      0|							&patternMatch, &groupingRule, &groupingOp)))
  279|      0|			while (tryThis < 3) {
  280|      0|				TranslationTableOffset ruleOffset = 0;
  281|      0|				switch (tryThis) {
  282|      0|				case 0:
  283|      0|					if (!(length >= 2)) break;
  284|      0|					ruleOffset = table->forRules[_lou_stringHash(
  285|      0|							&input->chars[pos], 1, table)];
  286|      0|					break;
  287|      0|				case 1:
  288|      0|					if (!(length >= 1)) break;
  289|      0|					length = 1;
  290|      0|					ruleOffset = getChar(input->chars[pos], table)->otherRules;
  291|      0|					break;
  292|      0|				case 2: /* No rule found */
  293|      0|					transOpcode = CTO_Always;
  294|      0|					ruleOffset = 0;
  295|      0|					break;
  296|      0|				}
  297|      0|				while (ruleOffset) {
  298|      0|					transRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];
  299|      0|					transOpcode = transRule->opcode;
  300|      0|					transCharslen = transRule->charslen;
  301|      0|					if (tryThis == 1 ||
  302|      0|							(transCharslen <= length &&
  303|      0|									compareChars(&transRule->charsdots[0],
  304|      0|											&input->chars[pos], transCharslen, table))) {
  305|      0|						if (posIncremented && transOpcode == CTO_Correct &&
  306|      0|								passDoTest(table, pos, input, transOpcode, transRule,
  307|      0|										&passCharDots, &passInstructions, &passIC,
  308|      0|										&patternMatch, &groupingRule, &groupingOp)) {
  309|      0|							tryThis = 4;
  310|      0|							break;
  311|      0|						}
  312|      0|					}
  313|      0|					ruleOffset = transRule->charsnext;
  314|      0|				}
  315|      0|				tryThis++;
  316|      0|			}
  317|      0|		posIncremented = 1;
  318|      0|
  319|      0|		switch (transOpcode) {
  320|      0|		case CTO_Always:
  321|      0|			if (output->length >= output->maxlength) goto failure;
  322|      0|			posMapping[output->length] = pos;
  323|      0|			output->chars[output->length++] = input->chars[pos++];
  324|      0|			break;
  325|      0|		case CTO_Correct: {
  326|      0|			const InString *inputBefore = input;
  327|      0|			int posBefore = pos;
  328|      0|			if (appliedRules != NULL && appliedRulesCount < maxAppliedRules)
  329|      0|				appliedRules[appliedRulesCount++] = transRule;
  330|      0|			if (!passDoAction(table, &input, output, posMapping, transOpcode, &transRule,
  331|      0|						passCharDots, passInstructions, passIC, &pos, patternMatch,
  332|      0|						cursorPosition, cursorStatus, groupingRule, groupingOp, mode))
  333|      0|				goto failure;
  334|      0|			if (input->bufferIndex != inputBefore->bufferIndex &&
  335|      0|					inputBefore->bufferIndex != origInput->bufferIndex)
  336|      0|				releaseStringBuffer(inputBefore->bufferIndex);
  337|      0|			if (pos == posBefore) posIncremented = 0;
  338|      0|			break;
  339|      0|		}
  340|      0|		default:
  341|      0|			break;
  342|      0|		}
  343|      0|	}
  344|      0|
  345|      0|	{  // We have to transform typebuf accordingly
  346|      0|		int k;
  347|      0|		formtype *typebuf_temp;
  348|      0|		if ((typebuf_temp = malloc(output->length * sizeof(formtype))) == NULL)
  349|      0|			_lou_outOfMemory();
  350|      0|		for (k = 0; k < output->length; k++)
  351|      0|			// posMapping will never be < 0 but in theory it could
  352|      0|			if (posMapping[k] < 0)
  353|      0|				typebuf_temp[k] = typebuf[0];  // prepend to next
  354|      0|			else if (posMapping[k] >= input->length)
  355|      0|				typebuf_temp[k] = typebuf[input->length - 1];  // append to previous
  356|      0|			else
  357|      0|				typebuf_temp[k] = typebuf[posMapping[k]];
  358|      0|		memcpy(typebuf, typebuf_temp, output->length * sizeof(formtype));
  359|      0|		free(typebuf_temp);
  360|      0|	}
  361|      0|
  362|      0|failure:
  363|      0|	*realInlen = pos;
  364|      0|	if (input->bufferIndex != origInput->bufferIndex)
  365|      0|		releaseStringBuffer(input->bufferIndex);
  366|      0|	return 1;
  367|      0|}
  368|       |
  369|       |static int
  370|       |matchCurrentInput(
  371|      0|		const InString *input, int pos, const widechar *passInstructions, int passIC) {
  372|      0|	int k;
  373|      0|	int kk = pos;
  374|      0|	for (k = passIC + 2;
  375|      0|			((k < passIC + 2 + passInstructions[passIC + 1]) && (kk < input->length));
  376|      0|			k++)
  377|      0|		if (input->chars[kk] == LOU_ENDSEGMENT ||
  378|      0|				passInstructions[k] != input->chars[kk++])
  379|      0|			return 0;
  380|      0|	return 1;
  381|      0|}
  382|       |
  383|       |static int
  384|       |swapTest(int swapIC, int *pos, const TranslationTableHeader *table, const InString *input,
  385|      0|		const widechar *passInstructions) {
  386|      0|	int p = *pos;
  387|      0|	TranslationTableOffset swapRuleOffset;
  388|      0|	TranslationTableRule *swapRule;
  389|      0|	swapRuleOffset = (passInstructions[swapIC + 1] << 16) | passInstructions[swapIC + 2];
  390|      0|	swapRule = (TranslationTableRule *)&table->ruleArea[swapRuleOffset];
  391|      0|	while (p - *pos < passInstructions[swapIC + 3]) {
  392|      0|		int test;
  393|      0|		if (p >= input->length) return 0;
  394|      0|		if (swapRule->opcode == CTO_SwapDd) {
  395|      0|			for (test = 1; test < swapRule->charslen; test += 2) {
  396|      0|				if (input->chars[p] == swapRule->charsdots[test]) break;
  397|      0|			}
  398|      0|		} else {
  399|      0|			for (test = 0; test < swapRule->charslen; test++) {
  400|      0|				if (input->chars[p] == swapRule->charsdots[test]) break;
  401|      0|			}
  402|      0|		}
  403|      0|		if (test >= swapRule->charslen) return 0;
  404|      0|		p++;
  405|      0|	}
  406|      0|	if (passInstructions[swapIC + 3] == passInstructions[swapIC + 4]) {
  407|      0|		*pos = p;
  408|      0|		return 1;
  409|      0|	}
  410|      0|	while (p - *pos < passInstructions[swapIC + 4]) {
  411|      0|		int test;
  412|      0|		if (p >= input->length) {
  413|      0|			*pos = p;
  414|      0|			return 1;
  415|      0|		}
  416|      0|		if (swapRule->opcode == CTO_SwapDd) {
  417|      0|			for (test = 1; test < swapRule->charslen; test += 2) {
  418|      0|				if (input->chars[p] == swapRule->charsdots[test]) break;
  419|      0|			}
  420|      0|		} else {
  421|      0|			for (test = 0; test < swapRule->charslen; test++) {
  422|      0|				if (input->chars[p] == swapRule->charsdots[test]) break;
  423|      0|			}
  424|      0|		}
  425|      0|		if (test >= swapRule->charslen) {
  426|      0|			*pos = p;
  427|      0|			return 1;
  428|      0|		}
  429|      0|		p++;
  430|      0|	}
  431|      0|	*pos = p;
  432|      0|	return 1;
  433|      0|}
  434|       |
  435|       |static int
  436|       |swapReplace(int start, int end, const TranslationTableHeader *table,
  437|       |		const InString *input, OutString *output, int *posMapping,
  438|      0|		const widechar *passInstructions, int passIC) {
  439|      0|	TranslationTableOffset swapRuleOffset;
  440|      0|	TranslationTableRule *swapRule;
  441|      0|	widechar *replacements;
  442|      0|	int p;
  443|      0|	swapRuleOffset = (passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];
  444|      0|	swapRule = (TranslationTableRule *)&table->ruleArea[swapRuleOffset];
  445|      0|	replacements = &swapRule->charsdots[swapRule->charslen];
  446|      0|	for (p = start; p < end; p++) {
  447|      0|		int rep;
  448|      0|		int test;
  449|      0|		int k;
  450|      0|		if (swapRule->opcode == CTO_SwapDd) {
  451|      0|			// A sequence of dot patterns is encoded as the length of the first dot
  452|      0|			// pattern (single widechar) followed by the contents of the first dot pattern
  453|      0|			// (one widechar per cell) followed by the length of the second dot pattern,
  454|      0|			// etc. See the function `compileSwapDots'. Because the third operand of a
  455|      0|			// swapdd rule can only contain single-cell dot patterns, the elements at
  456|      0|			// index 0, 2, ... are "1" and the elements at index 1, 3, ... are the dot
  457|      0|			// patterns.
  458|      0|			for (test = 0; test * 2 + 1 < swapRule->charslen; test++)
  459|      0|				if (input->chars[p] == swapRule->charsdots[test * 2 + 1]) break;
  460|      0|			if (test * 2 == swapRule->charslen) continue;
  461|      0|		} else {
  462|      0|			for (test = 0; test < swapRule->charslen; test++)
  463|      0|				if (input->chars[p] == swapRule->charsdots[test]) break;
  464|      0|			if (test == swapRule->charslen) continue;
  465|      0|		}
  466|      0|		k = 0;
  467|      0|		for (rep = 0; rep < test; rep++)
  468|      0|			if (swapRule->opcode == CTO_SwapCc)
  469|      0|				k++;
  470|      0|			else
  471|      0|				k += replacements[k];
  472|      0|		if (swapRule->opcode == CTO_SwapCc) {
  473|      0|			if ((output->length + 1) > output->maxlength) return 0;
  474|      0|			posMapping[output->length] = p;
  475|      0|			output->chars[output->length++] = replacements[k];
  476|      0|		} else {
  477|      0|			int l = replacements[k] - 1;
  478|      0|			int d = output->length + l;
  479|      0|			if (d > output->maxlength) return 0;
  480|      0|			while (--d >= output->length) posMapping[d] = p;
  481|      0|			memcpy(&output->chars[output->length], &replacements[k + 1],
  482|      0|					l * sizeof(*output->chars));
  483|      0|			output->length += l;
  484|      0|		}
  485|      0|	}
  486|      0|	return 1;
  487|      0|}
  488|       |
  489|       |static int
  490|       |replaceGrouping(const TranslationTableHeader *table, const InString **input,
  491|       |		OutString *output, int transOpcode, int passCharDots,
  492|       |		const widechar *passInstructions, int passIC, int startReplace,
  493|      0|		TranslationTableRule *groupingRule, widechar groupingOp) {
  494|      0|	widechar startCharDots = groupingRule->charsdots[2 * passCharDots];
  495|      0|	widechar endCharDots = groupingRule->charsdots[2 * passCharDots + 1];
  496|      0|	int p;
  497|      0|	int level = 0;
  498|      0|	TranslationTableOffset replaceOffset =
  499|      0|			passInstructions[passIC + 1] << 16 | (passInstructions[passIC + 2] & 0xff);
  500|      0|	TranslationTableRule *replaceRule =
  501|      0|			(TranslationTableRule *)&table->ruleArea[replaceOffset];
  502|      0|	widechar replaceStart = replaceRule->charsdots[2 * passCharDots];
  503|      0|	widechar replaceEnd = replaceRule->charsdots[2 * passCharDots + 1];
  504|      0|	if (groupingOp == pass_groupstart) {
  505|      0|		for (p = startReplace + 1; p < (*input)->length; p++) {
  506|      0|			if ((*input)->chars[p] == startCharDots) level--;
  507|      0|			if ((*input)->chars[p] == endCharDots) level++;
  508|      0|			if (level == 1) break;
  509|      0|		}
  510|      0|		if (p == (*input)->length)
  511|      0|			return 0;
  512|      0|		else {
  513|      0|			// Create a new string instead of modifying it. This is slightly less
  514|      0|			// efficient, but makes the code more readable. Grouping is not a much used
  515|      0|			// feature anyway.
  516|      0|			int idx = getStringBuffer((*input)->length);
  517|      0|			widechar *chars = stringBufferPool->buffers[idx];
  518|      0|			memcpy(chars, (*input)->chars, (*input)->length * sizeof(widechar));
  519|      0|			chars[startReplace] = replaceStart;
  520|      0|			chars[p] = replaceEnd;
  521|      0|			static InString stringStore;
  522|      0|			stringStore = (InString){
  523|      0|				.chars = chars, .length = (*input)->length, .bufferIndex = idx
  524|      0|			};
  525|      0|			*input = &stringStore;
  526|      0|		}
  527|      0|	} else {
  528|      0|		if (transOpcode == CTO_Context) {
  529|      0|			startCharDots = groupingRule->charsdots[2];
  530|      0|			endCharDots = groupingRule->charsdots[3];
  531|      0|			replaceStart = replaceRule->charsdots[2];
  532|      0|			replaceEnd = replaceRule->charsdots[3];
  533|      0|		}
  534|      0|		output->chars[output->length] = replaceEnd;
  535|      0|		for (p = output->length - 1; p >= 0; p--) {
  536|      0|			if (output->chars[p] == endCharDots) level--;
  537|      0|			if (output->chars[p] == startCharDots) level++;
  538|      0|			if (level == 1) break;
  539|      0|		}
  540|      0|		if (p < 0) return 0;
  541|      0|		output->chars[p] = replaceStart;
  542|      0|		output->length++;
  543|      0|	}
  544|      0|	return 1;
  545|      0|}
  546|       |
  547|       |static int
  548|       |removeGrouping(const InString **input, OutString *output, int passCharDots,
  549|      0|		int startReplace, TranslationTableRule *groupingRule, widechar groupingOp) {
  550|      0|	widechar startCharDots = groupingRule->charsdots[2 * passCharDots];
  551|      0|	widechar endCharDots = groupingRule->charsdots[2 * passCharDots + 1];
  552|      0|	int p;
  553|      0|	int level = 0;
  554|      0|	if (groupingOp == pass_groupstart) {
  555|      0|		for (p = startReplace + 1; p < (*input)->length; p++) {
  556|      0|			if ((*input)->chars[p] == startCharDots) level--;
  557|      0|			if ((*input)->chars[p] == endCharDots) level++;
  558|      0|			if (level == 1) break;
  559|      0|		}
  560|      0|		if (p == (*input)->length)
  561|      0|			return 0;
  562|      0|		else {
  563|      0|			// Create a new string instead of modifying it. This is slightly less
  564|      0|			// efficient, but makes the code more readable. Grouping is not a much used
  565|      0|			// feature anyway.
  566|      0|			int idx = getStringBuffer((*input)->length);
  567|      0|			widechar *chars = stringBufferPool->buffers[idx];
  568|      0|			int len = 0;
  569|      0|			int k;
  570|      0|			for (k = 0; k < (*input)->length; k++) {
  571|      0|				if (k == p) continue;
  572|      0|				chars[len++] = (*input)->chars[k];
  573|      0|			}
  574|      0|			static InString stringStore;
  575|      0|			stringStore = (InString){ .chars = chars, .length = len, .bufferIndex = idx };
  576|      0|			*input = &stringStore;
  577|      0|		}
  578|      0|	} else {
  579|      0|		for (p = output->length - 1; p >= 0; p--) {
  580|      0|			if (output->chars[p] == endCharDots) level--;
  581|      0|			if (output->chars[p] == startCharDots) level++;
  582|      0|			if (level == 1) break;
  583|      0|		}
  584|      0|		if (p < 0) return 0;
  585|      0|		p++;
  586|      0|		for (; p < output->length; p++) output->chars[p - 1] = output->chars[p];
  587|      0|		output->length--;
  588|      0|	}
  589|      0|	return 1;
  590|      0|}
  591|       |
  592|       |static int
  593|       |doPassSearch(const TranslationTableHeader *table, const InString *input,
  594|       |		const TranslationTableRule *transRule, int passCharDots, int pos,
  595|       |		const widechar *passInstructions, int passIC, int *searchIC, int *searchPos,
  596|      0|		TranslationTableRule *groupingRule, widechar groupingOp) {
  597|      0|	int level = 0;
  598|      0|	int k, kk;
  599|      0|	int not = 0;  // whether next operand should be reversed
  600|      0|	TranslationTableOffset ruleOffset;
  601|      0|	TranslationTableRule *rule;
  602|      0|	TranslationTableCharacterAttributes attributes;
  603|      0|	while (pos < input->length) {
  604|      0|		*searchIC = passIC + 1;
  605|      0|		*searchPos = pos;
  606|      0|		while (*searchIC < transRule->dotslen) {
  607|      0|			int itsTrue = 1;  // whether we have a match or not
  608|      0|			if (*searchPos > input->length) return 0;
  609|      0|			switch (passInstructions[*searchIC]) {
  610|      0|			case pass_lookback:
  611|      0|				*searchPos -= passInstructions[*searchIC + 1];
  612|      0|				if (*searchPos < 0) {
  613|      0|					*searchPos = 0;
  614|      0|					itsTrue = 0;
  615|      0|				}
  616|      0|				*searchIC += 2;
  617|      0|				break;
  618|      0|			case pass_not:
  619|      0|				not = !not;
  620|      0|				(*searchIC)++;
  621|      0|				continue;
  622|      0|			case pass_string:
  623|      0|			case pass_dots:
  624|      0|				kk = *searchPos;
  625|      0|				for (k = *searchIC + 2;
  626|      0|						k < *searchIC + 2 + passInstructions[*searchIC + 1]; k++)
  627|      0|					if (input->chars[kk] == LOU_ENDSEGMENT ||
  628|      0|							passInstructions[k] != input->chars[kk++]) {
  629|      0|						itsTrue = 0;
  630|      0|						break;
  631|      0|					}
  632|      0|				*searchPos += passInstructions[*searchIC + 1];
  633|      0|				*searchIC += passInstructions[*searchIC + 1] + 2;
  634|      0|				break;
  635|      0|			case pass_startReplace:
  636|      0|				(*searchIC)++;
  637|      0|				break;
  638|      0|			case pass_endReplace:
  639|      0|				(*searchIC)++;
  640|      0|				break;
  641|      0|			case pass_attributes:
  642|      0|				attributes = passInstructions[*searchIC + 1];
  643|      0|				attributes <<= 16;
  644|      0|				attributes |= passInstructions[*searchIC + 2];
  645|      0|				attributes <<= 16;
  646|      0|				attributes |= passInstructions[*searchIC + 3];
  647|      0|				attributes <<= 16;
  648|      0|				attributes |= passInstructions[*searchIC + 4];
  649|      0|				for (k = 0; k < passInstructions[*searchIC + 5]; k++) {
  650|      0|					if (input->chars[*searchPos] == LOU_ENDSEGMENT)
  651|      0|						itsTrue = 0;
  652|      0|					else {
  653|      0|						itsTrue = (passCharDots ? getDots(input->chars[(*searchPos)++],
  654|      0|														  table)
  655|      0|												: getChar(input->chars[(*searchPos)++],
  656|      0|														  table))
  657|      0|										  ->attributes &
  658|      0|								attributes;
  659|      0|						if (not) itsTrue = !itsTrue;
  660|      0|					}
  661|      0|					if (!itsTrue) break;
  662|      0|				}
  663|      0|				if (itsTrue) {
  664|      0|					for (k = passInstructions[*searchIC + 5];
  665|      0|							k < passInstructions[*searchIC + 6]; k++) {
  666|      0|						if (input->chars[*searchPos] == LOU_ENDSEGMENT) {
  667|      0|							itsTrue = 0;
  668|      0|							break;
  669|      0|						}
  670|      0|						if (!((passCharDots ? getDots(input->chars[*searchPos], table)
  671|      0|											: getChar(input->chars[*searchPos], table))
  672|      0|											->attributes &
  673|      0|									attributes)) {
  674|      0|							if (!not) break;
  675|      0|						} else if (not)
  676|      0|							break;
  677|      0|						(*searchPos)++;
  678|      0|					}
  679|      0|				}
  680|      0|				not = 0;
  681|      0|				*searchIC += 7;
  682|      0|				break;
  683|      0|			case pass_groupstart:
  684|      0|			case pass_groupend:
  685|      0|				ruleOffset = (passInstructions[*searchIC + 1] << 16) |
  686|      0|						passInstructions[*searchIC + 2];
  687|      0|				rule = (TranslationTableRule *)&table->ruleArea[ruleOffset];
  688|      0|				if (passInstructions[*searchIC] == pass_groupstart)
  689|      0|					itsTrue = (input->chars[*searchPos] ==
  690|      0|									  rule->charsdots[2 * passCharDots])
  691|      0|							? 1
  692|      0|							: 0;
  693|      0|				else
  694|      0|					itsTrue = (input->chars[*searchPos] ==
  695|      0|									  rule->charsdots[2 * passCharDots + 1])
  696|      0|							? 1
  697|      0|							: 0;
  698|      0|				if (groupingRule != NULL && groupingOp == pass_groupstart &&
  699|      0|						rule == groupingRule) {
  700|      0|					if (input->chars[*searchPos] == rule->charsdots[2 * passCharDots])
  701|      0|						level--;
  702|      0|					else if (input->chars[*searchPos] ==
  703|      0|							rule->charsdots[2 * passCharDots + 1])
  704|      0|						level++;
  705|      0|				}
  706|      0|				(*searchPos)++;
  707|      0|				*searchIC += 3;
  708|      0|				break;
  709|      0|			case pass_swap:
  710|      0|				itsTrue = swapTest(*searchIC, searchPos, table, input, passInstructions);
  711|      0|				*searchIC += 5;
  712|      0|				break;
  713|      0|			case pass_endTest:
  714|      0|				if (itsTrue) {
  715|      0|					if ((groupingRule && level == 1) || !groupingRule) return 1;
  716|      0|				}
  717|      0|				*searchIC = transRule->dotslen;
  718|      0|				break;
  719|      0|			default:
  720|      0|				if (_lou_handlePassVariableTest(passInstructions, searchIC, &itsTrue))
  721|      0|					break;
  722|      0|				break;
  723|      0|			}
  724|      0|			if ((!not&&!itsTrue) || (not&&itsTrue)) break;
  725|      0|			not = 0;
  726|      0|		}
  727|      0|		pos++;
  728|      0|	}
  729|      0|	return 0;
  730|      0|}
  731|       |
  732|       |static int
  733|       |passDoTest(const TranslationTableHeader *table, int pos, const InString *input,
  734|       |		int transOpcode, const TranslationTableRule *transRule, int *passCharDots,
  735|       |		widechar const **passInstructions, int *passIC, PassRuleMatch *match,
  736|      0|		TranslationTableRule **groupingRule, widechar *groupingOp) {
  737|      0|	int searchIC, searchPos;
  738|      0|	int k;
  739|      0|	int not = 0;  // whether next operand should be reversed
  740|      0|	TranslationTableOffset ruleOffset = 0;
  741|      0|	TranslationTableRule *rule = NULL;
  742|      0|	TranslationTableCharacterAttributes attributes = 0;
  743|      0|	int startMatch = pos;
  744|      0|	int endMatch = pos;
  745|      0|	int startReplace = -1;
  746|      0|	int endReplace = -1;
  747|      0|	*groupingRule = NULL;
  748|      0|	*passInstructions = &transRule->charsdots[transRule->charslen];
  749|      0|	*passIC = 0;
  750|      0|	if (transOpcode == CTO_Context || transOpcode == CTO_Correct)
  751|      0|		*passCharDots = 0;
  752|      0|	else
  753|      0|		*passCharDots = 1;
  754|      0|	while (*passIC < transRule->dotslen) {
  755|      0|		int itsTrue = 1;  // whether we have a match or not
  756|      0|		if (pos > input->length) return 0;
  757|      0|		switch ((*passInstructions)[*passIC]) {
  758|      0|		case pass_first:
  759|      0|			if (pos != 0) itsTrue = 0;
  760|      0|			(*passIC)++;
  761|      0|			break;
  762|      0|		case pass_last:
  763|      0|			if (pos != input->length) itsTrue = 0;
  764|      0|			(*passIC)++;
  765|      0|			break;
  766|      0|		case pass_lookback:
  767|      0|			pos -= (*passInstructions)[*passIC + 1];
  768|      0|			if (pos < 0) {
  769|      0|				searchPos = 0;
  770|      0|				itsTrue = 0;
  771|      0|			}
  772|      0|			*passIC += 2;
  773|      0|			break;
  774|      0|		case pass_not:
  775|      0|			not = !not;
  776|      0|			(*passIC)++;
  777|      0|			continue;
  778|      0|		case pass_string:
  779|      0|		case pass_dots:
  780|      0|			itsTrue = matchCurrentInput(input, pos, *passInstructions, *passIC);
  781|      0|			pos += (*passInstructions)[*passIC + 1];
  782|      0|			*passIC += (*passInstructions)[*passIC + 1] + 2;
  783|      0|			break;
  784|      0|		case pass_startReplace:
  785|      0|			startReplace = pos;
  786|      0|			(*passIC)++;
  787|      0|			break;
  788|      0|		case pass_endReplace:
  789|      0|			endReplace = pos;
  790|      0|			(*passIC)++;
  791|      0|			break;
  792|      0|		case pass_attributes:
  793|      0|			attributes = (*passInstructions)[*passIC + 1];
  794|      0|			attributes <<= 16;
  795|      0|			attributes |= (*passInstructions)[*passIC + 2];
  796|      0|			attributes <<= 16;
  797|      0|			attributes |= (*passInstructions)[*passIC + 3];
  798|      0|			attributes <<= 16;
  799|      0|			attributes |= (*passInstructions)[*passIC + 4];
  800|      0|			for (k = 0; k < (*passInstructions)[*passIC + 5]; k++) {
  801|      0|				if (pos >= input->length) {
  802|      0|					itsTrue = 0;
  803|      0|					break;
  804|      0|				}
  805|      0|				if (input->chars[pos] == LOU_ENDSEGMENT) {
  806|      0|					itsTrue = 0;
  807|      0|					break;
  808|      0|				}
  809|      0|				if (!((*passCharDots ? getDots(input->chars[pos], table)
  810|      0|									 : getChar(input->chars[pos], table))
  811|      0|									->attributes &
  812|      0|							attributes)) {
  813|      0|					if (!not) {
  814|      0|						itsTrue = 0;
  815|      0|						break;
  816|      0|					}
  817|      0|				} else if (not) {
  818|      0|					itsTrue = 0;
  819|      0|					break;
  820|      0|				}
  821|      0|				pos++;
  822|      0|			}
  823|      0|			if (itsTrue) {
  824|      0|				for (k = (*passInstructions)[*passIC + 5];
  825|      0|						k < (*passInstructions)[*passIC + 6] && pos < input->length;
  826|      0|						k++) {
  827|      0|					if (input->chars[pos] == LOU_ENDSEGMENT) {
  828|      0|						itsTrue = 0;
  829|      0|						break;
  830|      0|					}
  831|      0|					if (!((*passCharDots ? getDots(input->chars[pos], table)
  832|      0|										 : getChar(input->chars[pos], table))
  833|      0|										->attributes &
  834|      0|								attributes)) {
  835|      0|						if (!not) break;
  836|      0|					} else if (not)
  837|      0|						break;
  838|      0|					pos++;
  839|      0|				}
  840|      0|			}
  841|      0|			not = 0;
  842|      0|			*passIC += 7;
  843|      0|			break;
  844|      0|		case pass_groupstart:
  845|      0|		case pass_groupend:
  846|      0|			ruleOffset = ((*passInstructions)[*passIC + 1] << 16) |
  847|      0|					(*passInstructions)[*passIC + 2];
  848|      0|			rule = (TranslationTableRule *)&table->ruleArea[ruleOffset];
  849|      0|			if (*passIC == 0 ||
  850|      0|					(*passIC > 0 &&
  851|      0|							(*passInstructions)[*passIC - 1] == pass_startReplace)) {
  852|      0|				*groupingRule = rule;
  853|      0|				*groupingOp = (*passInstructions)[*passIC];
  854|      0|			}
  855|      0|			if ((*passInstructions)[*passIC] == pass_groupstart)
  856|      0|				itsTrue =
  857|      0|						(input->chars[pos] == rule->charsdots[2 * *passCharDots]) ? 1 : 0;
  858|      0|			else
  859|      0|				itsTrue = (input->chars[pos] == rule->charsdots[2 * *passCharDots + 1])
  860|      0|						? 1
  861|      0|						: 0;
  862|      0|			pos++;
  863|      0|			*passIC += 3;
  864|      0|			break;
  865|      0|		case pass_swap:
  866|      0|			itsTrue = swapTest(*passIC, &pos, table, input, *passInstructions);
  867|      0|			*passIC += 5;
  868|      0|			break;
  869|      0|		case pass_search:
  870|      0|			itsTrue = doPassSearch(table, input, transRule, *passCharDots, pos,
  871|      0|					*passInstructions, *passIC, &searchIC, &searchPos, *groupingRule,
  872|      0|					*groupingOp);
  873|      0|			if ((!not&&!itsTrue) || (not&&itsTrue)) return 0;
  874|      0|			*passIC = searchIC;
  875|      0|			pos = searchPos;
  876|      0|		case pass_endTest:
  877|      0|			(*passIC)++;
  878|      0|			endMatch = pos;
  879|      0|			if (startReplace == -1) {
  880|      0|				startReplace = startMatch;
  881|      0|				endReplace = endMatch;
  882|      0|			}
  883|      0|			if (startReplace < startMatch)
  884|      0|				return 0;
  885|      0|			else {
  886|      0|				*match = (PassRuleMatch){ .startMatch = startMatch,
  887|      0|					.startReplace = startReplace,
  888|      0|					.endReplace = endReplace,
  889|      0|					.endMatch = endMatch };
  890|      0|				return 1;
  891|      0|			}
  892|      0|			break;
  893|      0|		default:
  894|      0|			if (_lou_handlePassVariableTest(*passInstructions, passIC, &itsTrue)) break;
  895|      0|			return 0;
  896|      0|		}
  897|      0|		if ((!not&&!itsTrue) || (not&&itsTrue)) return 0;
  898|      0|		not = 0;
  899|      0|	}
  900|      0|	return 0;
  901|      0|}
  902|       |
  903|       |static int
  904|       |copyCharacters(int from, int to, const TranslationTableHeader *table,
  905|       |		const InString *input, OutString *output, int *posMapping, int transOpcode,
  906|      0|		int *cursorPosition, int *cursorStatus, int mode) {
  907|      0|	if (transOpcode == CTO_Context) {
  908|      0|		while (from < to) {
  909|      0|			if (!putCharacter(input->chars[from], table, from, input, output, posMapping,
  910|      0|						cursorPosition, cursorStatus, mode))
  911|      0|				return 0;
  912|      0|			from++;
  913|      0|		}
  914|      0|	} else {
  915|      0|		if (to > from) {
  916|      0|			if ((output->length + to - from) > output->maxlength) return 0;
  917|      0|			while (to > from) {
  918|      0|				posMapping[output->length] = from;
  919|      0|				output->chars[output->length] = input->chars[from];
  920|      0|				output->length++;
  921|      0|				from++;
  922|      0|			}
  923|      0|		}
  924|      0|	}
  925|      0|
  926|      0|	return 1;
  927|      0|}
  928|       |
  929|       |static int
  930|       |passDoAction(const TranslationTableHeader *table, const InString **input,
  931|       |		OutString *output, int *posMapping, int transOpcode,
  932|       |		const TranslationTableRule **transRule, int passCharDots,
  933|       |		const widechar *passInstructions, int passIC, int *pos, PassRuleMatch match,
  934|       |		int *cursorPosition, int *cursorStatus, TranslationTableRule *groupingRule,
  935|      0|		widechar groupingOp, int mode) {
  936|      0|	int k;
  937|      0|	TranslationTableOffset ruleOffset = 0;
  938|      0|	TranslationTableRule *rule = NULL;
  939|      0|	int destStartMatch = output->length;
  940|      0|	int destStartReplace;
  941|      0|	int newPos = match.endReplace;
  942|      0|
  943|      0|	if (!copyCharacters(match.startMatch, match.startReplace, table, *input, output,
  944|      0|				posMapping, transOpcode, cursorPosition, cursorStatus, mode))
  945|      0|		return 0;
  946|      0|	destStartReplace = output->length;
  947|      0|
  948|      0|	while (passIC < (*transRule)->dotslen) switch (passInstructions[passIC]) {
  949|      0|		case pass_string:
  950|      0|		case pass_dots:
  951|      0|			if ((output->length + passInstructions[passIC + 1]) > output->maxlength)
  952|      0|				return 0;
  953|      0|			for (k = 0; k < passInstructions[passIC + 1]; ++k)
  954|      0|				posMapping[output->length + k] = match.startReplace;
  955|      0|			memcpy(&output->chars[output->length], &passInstructions[passIC + 2],
  956|      0|					passInstructions[passIC + 1] * CHARSIZE);
  957|      0|			output->length += passInstructions[passIC + 1];
  958|      0|			passIC += passInstructions[passIC + 1] + 2;
  959|      0|			break;
  960|      0|		case pass_groupstart:
  961|      0|			ruleOffset =
  962|      0|					(passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];
  963|      0|			rule = (TranslationTableRule *)&table->ruleArea[ruleOffset];
  964|      0|			posMapping[output->length] = match.startMatch;
  965|      0|			output->chars[output->length++] = rule->charsdots[2 * passCharDots];
  966|      0|			passIC += 3;
  967|      0|			break;
  968|      0|		case pass_groupend:
  969|      0|			ruleOffset =
  970|      0|					(passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];
  971|      0|			rule = (TranslationTableRule *)&table->ruleArea[ruleOffset];
  972|      0|			posMapping[output->length] = match.startMatch;
  973|      0|			output->chars[output->length++] = rule->charsdots[2 * passCharDots + 1];
  974|      0|			passIC += 3;
  975|      0|			break;
  976|      0|		case pass_swap:
  977|      0|			if (!swapReplace(match.startReplace, match.endReplace, table, *input, output,
  978|      0|						posMapping, passInstructions, passIC))
  979|      0|				return 0;
  980|      0|			passIC += 3;
  981|      0|			break;
  982|      0|		case pass_groupreplace:
  983|      0|			if (!groupingRule ||
  984|      0|					!replaceGrouping(table, input, output, transOpcode, passCharDots,
  985|      0|							passInstructions, passIC, match.startReplace, groupingRule,
  986|      0|							groupingOp))
  987|      0|				return 0;
  988|      0|			passIC += 3;
  989|      0|			break;
  990|      0|		case pass_omit:
  991|      0|			if (groupingRule)
  992|      0|				removeGrouping(input, output, passCharDots, match.startReplace,
  993|      0|						groupingRule, groupingOp);
  994|      0|			passIC++;
  995|      0|			break;
  996|      0|		case pass_copy: {
  997|      0|			int count = destStartReplace - destStartMatch;
  998|      0|			if (count > 0) {
  999|      0|				memmove(&output->chars[destStartMatch], &output->chars[destStartReplace],
 1000|      0|						count * sizeof(*output->chars));
 1001|      0|				output->length -= count;
 1002|      0|				destStartReplace = destStartMatch;
 1003|      0|			}
 1004|      0|		}
 1005|      0|
 1006|      0|			if (!copyCharacters(match.startReplace, match.endReplace, table, *input,
 1007|      0|						output, posMapping, transOpcode, cursorPosition, cursorStatus,
 1008|      0|						mode))
 1009|      0|				return 0;
 1010|      0|			newPos = match.endMatch;
 1011|      0|			passIC++;
 1012|      0|			break;
 1013|      0|		default:
 1014|      0|			if (_lou_handlePassVariableAction(passInstructions, &passIC)) break;
 1015|      0|			return 0;
 1016|      0|		}
 1017|      0|	*pos = newPos;
 1018|      0|	return 1;
 1019|      0|}
 1020|       |
 1021|       |static void
 1022|       |passSelectRule(const TranslationTableHeader *table, int pos, int currentPass,
 1023|       |		const InString *input, int *transOpcode, const TranslationTableRule **transRule,
 1024|       |		int *transCharslen, int *passCharDots, widechar const **passInstructions,
 1025|       |		int *passIC, PassRuleMatch *match, TranslationTableRule **groupingRule,
 1026|      0|		widechar *groupingOp) {
 1027|      0|	if (!findForPassRule(table, pos, currentPass, input, transOpcode, transRule,
 1028|      0|				transCharslen, passCharDots, passInstructions, passIC, match,
 1029|      0|				groupingRule, groupingOp)) {
 1030|      0|		*transOpcode = CTO_Always;
 1031|      0|	}
 1032|      0|}
 1033|       |
 1034|       |static int
 1035|       |translatePass(const TranslationTableHeader *table, int currentPass, const InString *input,
 1036|       |		OutString *output, int *posMapping, int *realInlen, int *cursorPosition,
 1037|      0|		int *cursorStatus, int mode) {
 1038|      0|	int pos;
 1039|      0|	int transOpcode;
 1040|      0|	const TranslationTableRule *transRule;
 1041|      0|	int transCharslen;
 1042|      0|	int passCharDots;
 1043|      0|	const widechar *passInstructions;
 1044|      0|	int passIC; /* Instruction counter */
 1045|      0|	PassRuleMatch patternMatch;
 1046|      0|	TranslationTableRule *groupingRule;
 1047|      0|	widechar groupingOp;
 1048|      0|	const InString *origInput = input;
 1049|      0|	pos = output->length = 0;
 1050|      0|	int posIncremented = 1;
 1051|      0|	_lou_resetPassVariables();
 1052|      0|	while (pos < input->length) { /* the main multipass translation loop */
 1053|      0|		// check posIncremented to avoid endless loop
 1054|      0|		if (!posIncremented)
 1055|      0|			transOpcode = CTO_Always;
 1056|      0|		else
 1057|      0|			passSelectRule(table, pos, currentPass, input, &transOpcode, &transRule,
 1058|      0|					&transCharslen, &passCharDots, &passInstructions, &passIC,
 1059|      0|					&patternMatch, &groupingRule, &groupingOp);
 1060|      0|		posIncremented = 1;
 1061|      0|		switch (transOpcode) {
 1062|      0|		case CTO_Context:
 1063|      0|		case CTO_Pass2:
 1064|      0|		case CTO_Pass3:
 1065|      0|		case CTO_Pass4: {
 1066|      0|			const InString *inputBefore = input;
 1067|      0|			int posBefore = pos;
 1068|      0|			if (appliedRules != NULL && appliedRulesCount < maxAppliedRules)
 1069|      0|				appliedRules[appliedRulesCount++] = transRule;
 1070|      0|			if (!passDoAction(table, &input, output, posMapping, transOpcode, &transRule,
 1071|      0|						passCharDots, passInstructions, passIC, &pos, patternMatch,
 1072|      0|						cursorPosition, cursorStatus, groupingRule, groupingOp, mode))
 1073|      0|				goto failure;
 1074|      0|			if (input->bufferIndex != inputBefore->bufferIndex &&
 1075|      0|					inputBefore->bufferIndex != origInput->bufferIndex)
 1076|      0|				releaseStringBuffer(inputBefore->bufferIndex);
 1077|      0|			if (pos == posBefore) posIncremented = 0;
 1078|      0|			break;
 1079|      0|		}
 1080|      0|		case CTO_Always:
 1081|      0|			if ((output->length + 1) > output->maxlength) goto failure;
 1082|      0|			posMapping[output->length] = pos;
 1083|      0|			output->chars[output->length++] = input->chars[pos++];
 1084|      0|			break;
 1085|      0|		default:
 1086|      0|			goto failure;
 1087|      0|		}
 1088|      0|	}
 1089|      0|failure:
 1090|      0|	if (pos < input->length) {
 1091|      0|		while (checkDotsAttr(input->chars[pos], CTC_Space, table))
 1092|      0|			if (++pos == input->length) break;
 1093|      0|	}
 1094|      0|	*realInlen = pos;
 1095|      0|	if (input->bufferIndex != origInput->bufferIndex)
 1096|      0|		releaseStringBuffer(input->bufferIndex);
 1097|      0|	return 1;
 1098|      0|}
 1099|       |
 1100|      0|#define MIN(a, b) (((a) < (b)) ? (a) : (b))
 1101|       |
 1102|       |static int
 1103|       |translateString(const TranslationTableHeader *table, int mode, int currentPass,
 1104|       |		const InString *input, OutString *output, int *posMapping, formtype *typebuf,
 1105|       |		unsigned char *srcSpacing, unsigned char *destSpacing, unsigned int *wordBuffer,
 1106|       |		EmphasisInfo *emphasisBuffer, int haveEmphasis, int *realInlen,
 1107|       |		int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd);
 1108|       |
 1109|       |int EXPORT_CALL
 1110|       |lou_translateString(const char *tableList, const widechar *inbufx, int *inlen,
 1111|      0|		widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int mode) {
 1112|      0|	return lou_translate(tableList, inbufx, inlen, outbuf, outlen, typeform, spacing,
 1113|      0|			NULL, NULL, NULL, mode);
 1114|      0|}
 1115|       |
 1116|       |int EXPORT_CALL
 1117|       |lou_translate(const char *tableList, const widechar *inbufx, int *inlen, widechar *outbuf,
 1118|       |		int *outlen, formtype *typeform, char *spacing, int *outputPos, int *inputPos,
 1119|      0|		int *cursorPos, int mode) {
 1120|      0|	return _lou_translate(tableList, tableList, inbufx, inlen, outbuf, outlen, typeform,
 1121|      0|			spacing, outputPos, inputPos, cursorPos, mode, NULL, NULL);
 1122|      0|}
 1123|       |
 1124|       |int EXPORT_CALL
 1125|       |_lou_translate(const char *tableList, const char *displayTableList,
 1126|       |		const widechar *inbufx, int *inlen, widechar *outbuf, int *outlen,
 1127|       |		formtype *typeform, char *spacing, int *outputPos, int *inputPos, int *cursorPos,
 1128|      0|		int mode, const TranslationTableRule **rules, int *rulesLen) {
 1129|      0|	// int i;
 1130|      0|	// for(i = 0; i < *inlen; i++)
 1131|      0|	// {
 1132|      0|	// 	outbuf[i] = inbufx[i];
 1133|      0|	// 	if(inputPos)
 1134|      0|	// 		inputPos[i] = i;
 1135|      0|	// 	if(outputPos)
 1136|      0|	// 		outputPos[i] = i;
 1137|      0|	// }
 1138|      0|	// *inlen = i;
 1139|      0|	// *outlen = i;
 1140|      0|	// return 1;
 1141|      0|	const TranslationTableHeader *table;
 1142|      0|	const DisplayTableHeader *displayTable;
 1143|      0|	InString input;
 1144|      0|	OutString output;
 1145|      0|	// posMapping contains position mapping info between the initial input and the output
 1146|      0|	// of the current pass. It is 1 longer than the output. The values are monotonically
 1147|      0|	// increasing and can range between -1 and the (consumed) input length. At the end the
 1148|      0|	// position info is passed to the user as an inputPos and outputPos array. inputPos
 1149|      0|	// has the length of the final output and has values ranging from 0 to inlen-1.
 1150|      0|	// outputPos has the length of the (consumed) initial input and has values ranging
 1151|      0|	// from 0 to outlen-1.
 1152|      0|	int *posMapping;
 1153|      0|	int *posMapping1;
 1154|      0|	int *posMapping2;
 1155|      0|	int *posMapping3;
 1156|      0|	formtype *typebuf;
 1157|      0|	unsigned char *srcSpacing;
 1158|      0|	unsigned char *destSpacing;
 1159|      0|	unsigned int *wordBuffer;
 1160|      0|	EmphasisInfo *emphasisBuffer;
 1161|      0|	int cursorPosition;
 1162|      0|	int cursorStatus;
 1163|      0|	int haveEmphasis;
 1164|      0|	int compbrlStart = -1;
 1165|      0|	int compbrlEnd = -1;
 1166|      0|	int k;
 1167|      0|	int goodTrans = 1;
 1168|      0|	if (tableList == NULL || inbufx == NULL || inlen == NULL || outbuf == NULL ||
 1169|      0|			outlen == NULL)
 1170|      0|		return 0;
 1171|      0|	_lou_logMessage(LOU_LOG_ALL, "Performing translation: tableList=%s, inlen=%d",
 1172|      0|			tableList, *inlen);
 1173|      0|	_lou_logWidecharBuf(LOU_LOG_ALL, "Inbuf=", inbufx, *inlen);
 1174|      0|
 1175|      0|	if (!_lou_isValidMode(mode))
 1176|      0|		_lou_logMessage(LOU_LOG_ERROR, "Invalid mode parameter: %d", mode);
 1177|      0|
 1178|      0|	if (displayTableList == NULL) displayTableList = tableList;
 1179|      0|	_lou_getTable(tableList, displayTableList, &table, &displayTable);
 1180|      0|	if (table == NULL || *inlen < 0 || *outlen < 0) return 0;
 1181|      0|	k = 0;
 1182|      0|	while (k < *inlen && inbufx[k]) k++;
 1183|      0|	input = (InString){ .chars = inbufx, .length = k, .bufferIndex = -1 };
 1184|      0|	haveEmphasis = 0;
 1185|      0|	if (!(typebuf = _lou_allocMem(alloc_typebuf, 0, input.length, *outlen))) return 0;
 1186|      0|	if (typeform != NULL) {
 1187|      0|		for (k = 0; k < input.length; k++) {
 1188|      0|			typebuf[k] = typeform[k];
 1189|      0|			if (typebuf[k] & EMPHASIS) haveEmphasis = 1;
 1190|      0|		}
 1191|      0|	} else
 1192|      0|		memset(typebuf, 0, input.length * sizeof(formtype));
 1193|      0|
 1194|      0|	if (!(wordBuffer = _lou_allocMem(alloc_wordBuffer, 0, input.length, *outlen)))
 1195|      0|		return 0;
 1196|      0|
 1197|      0|	if (!(emphasisBuffer = _lou_allocMem(alloc_emphasisBuffer, 0, input.length, *outlen)))
 1198|      0|		return 0;
 1199|      0|
 1200|      0|	if (!(spacing == NULL || *spacing == 'X'))
 1201|      0|		srcSpacing = (unsigned char *)spacing;
 1202|      0|	else
 1203|      0|		srcSpacing = NULL;
 1204|      0|	if (outputPos != NULL)
 1205|      0|		for (k = 0; k < input.length; k++) outputPos[k] = -1;
 1206|      0|	if (cursorPos != NULL && *cursorPos >= 0) {
 1207|      0|		cursorStatus = 0;
 1208|      0|		cursorPosition = *cursorPos;
 1209|      0|		if ((mode & (compbrlAtCursor | compbrlLeftCursor))) {
 1210|      0|			compbrlStart = cursorPosition;
 1211|      0|			if (checkCharAttr(input.chars[compbrlStart], CTC_Space, table))
 1212|      0|				/* It would have been simpler to just set compbrlStart and compbrlEnd to
 1213|      0|				 * -1 (i.e. disable compbrlAtCursor/compbrlLeftCursor mode) if the cursor
 1214|      0|				 * is set on a space. But maybe there are cases where a space in computer
 1215|      0|				 * braille does not map to a blank cell, and the user expects to see the
 1216|      0|				 * computer braille representation when the space is under the cursor, so
 1217|      0|				 * we better leave it as it is.
 1218|      0|				 */
 1219|      0|				compbrlEnd = compbrlStart + 1;
 1220|      0|			else {
 1221|      0|				while (compbrlStart >= 0 &&
 1222|      0|						!checkCharAttr(input.chars[compbrlStart], CTC_Space, table))
 1223|      0|					compbrlStart--;
 1224|      0|				compbrlStart++;
 1225|      0|				compbrlEnd = cursorPosition;
 1226|      0|				if (!(mode & compbrlLeftCursor))
 1227|      0|					while (compbrlEnd < input.length &&
 1228|      0|							!checkCharAttr(input.chars[compbrlEnd], CTC_Space, table))
 1229|      0|						compbrlEnd++;
 1230|      0|			}
 1231|      0|		}
 1232|      0|	} else {
 1233|      0|		cursorPosition = -1;
 1234|      0|		cursorStatus = 1; /* so it won't check cursor position */
 1235|      0|	}
 1236|      0|	if (!(posMapping1 = _lou_allocMem(alloc_posMapping1, 0, input.length, *outlen)))
 1237|      0|		return 0;
 1238|      0|	if (table->numPasses > 1 || table->corrections) {
 1239|      0|		if (!(posMapping2 = _lou_allocMem(alloc_posMapping2, 0, input.length, *outlen)))
 1240|      0|			return 0;
 1241|      0|		if (!(posMapping3 = _lou_allocMem(alloc_posMapping3, 0, input.length, *outlen)))
 1242|      0|			return 0;
 1243|      0|	}
 1244|      0|	if (srcSpacing != NULL) {
 1245|      0|		if (!(destSpacing = _lou_allocMem(alloc_destSpacing, 0, input.length, *outlen)))
 1246|      0|			goodTrans = 0;
 1247|      0|		else
 1248|      0|			memset(destSpacing, '*', *outlen);
 1249|      0|	} else
 1250|      0|		destSpacing = NULL;
 1251|      0|	appliedRulesCount = 0;
 1252|      0|	if (rules != NULL && rulesLen != NULL) {
 1253|      0|		appliedRules = rules;
 1254|      0|		maxAppliedRules = *rulesLen;
 1255|      0|	} else {
 1256|      0|		appliedRules = NULL;
 1257|      0|		maxAppliedRules = 0;
 1258|      0|	}
 1259|      0|	{
 1260|      0|		int idx;
 1261|      0|		if (!stringBufferPool) initStringBufferPool();
 1262|      0|		for (idx = 0; idx < stringBufferPool->size; idx++) releaseStringBuffer(idx);
 1263|      0|		idx = getStringBuffer(*outlen);
 1264|      0|		output = (OutString){ .chars = stringBufferPool->buffers[idx],
 1265|      0|			.maxlength = *outlen,
 1266|      0|			.length = 0,
 1267|      0|			.bufferIndex = idx };
 1268|      0|	}
 1269|      0|	posMapping = posMapping1;
 1270|      0|
 1271|      0|	int currentPass = table->corrections ? 0 : 1;
 1272|      0|	int *passPosMapping = posMapping;
 1273|      0|	while (1) {
 1274|      0|		int realInlen;
 1275|      0|		switch (currentPass) {
 1276|      0|		case 0:
 1277|      0|			goodTrans = makeCorrections(table, &input, &output, passPosMapping, typebuf,
 1278|      0|					&realInlen, &cursorPosition, &cursorStatus, mode);
 1279|      0|			break;
 1280|      0|		case 1: {
 1281|      0|			goodTrans = translateString(table, mode, currentPass, &input, &output,
 1282|      0|					passPosMapping, typebuf, srcSpacing, destSpacing, wordBuffer,
 1283|      0|					emphasisBuffer, haveEmphasis, &realInlen, &cursorPosition,
 1284|      0|					&cursorStatus, compbrlStart, compbrlEnd);
 1285|      0|			break;
 1286|      0|		}
 1287|      0|		default:
 1288|      0|			goodTrans = translatePass(table, currentPass, &input, &output, passPosMapping,
 1289|      0|					&realInlen, &cursorPosition, &cursorStatus, mode);
 1290|      0|			break;
 1291|      0|		}
 1292|      0|		passPosMapping[output.length] = realInlen;
 1293|      0|		if (passPosMapping == posMapping) {
 1294|      0|			passPosMapping = posMapping2;
 1295|      0|		} else {
 1296|      0|			int *prevPosMapping = posMapping3;
 1297|      0|			memcpy((int *)prevPosMapping, posMapping, (*outlen + 1) * sizeof(int));
 1298|      0|			for (k = 0; k <= output.length; k++)
 1299|      0|				if (passPosMapping[k] < 0)
 1300|      0|					posMapping[k] = prevPosMapping[0];
 1301|      0|				else
 1302|      0|					posMapping[k] = prevPosMapping[passPosMapping[k]];
 1303|      0|		}
 1304|      0|		currentPass++;
 1305|      0|		if (currentPass <= table->numPasses && goodTrans) {
 1306|      0|			int idx;
 1307|      0|			releaseStringBuffer(input.bufferIndex);
 1308|      0|			input = (InString){ .chars = output.chars,
 1309|      0|				.length = output.length,
 1310|      0|				.bufferIndex = output.bufferIndex };
 1311|      0|			idx = getStringBuffer(*outlen);
 1312|      0|			output = (OutString){ .chars = stringBufferPool->buffers[idx],
 1313|      0|				.maxlength = *outlen,
 1314|      0|				.length = 0,
 1315|      0|				.bufferIndex = idx };
 1316|      0|			continue;
 1317|      0|		}
 1318|      0|		break;
 1319|      0|	}
 1320|      0|	if (goodTrans) {
 1321|      0|		for (k = 0; k < output.length; k++) {
 1322|      0|			if (typeform != NULL) {
 1323|      0|				if ((output.chars[k] & (LOU_DOT_7 | LOU_DOT_8)))
 1324|      0|					typeform[k] = '8';
 1325|      0|				else
 1326|      0|					typeform[k] = '0';
 1327|      0|			}
 1328|      0|			if ((mode & dotsIO)) {
 1329|      0|				if ((mode & ucBrl))
 1330|      0|					outbuf[k] = ((output.chars[k] & 0xff) | LOU_ROW_BRAILLE);
 1331|      0|				else
 1332|      0|					outbuf[k] = output.chars[k];
 1333|      0|			} else {
 1334|      0|				outbuf[k] = _lou_getCharForDots(output.chars[k], displayTable);
 1335|      0|				if (!outbuf[k]) {
 1336|      0|					// assume that if NUL character is returned, it's because the display
 1337|      0|					// table has no mapping for the dot pattern (not because it maps to
 1338|      0|					// NUL)
 1339|      0|					_lou_logMessage(LOU_LOG_ERROR,
 1340|      0|							"%s: no mapping for dot pattern %s in display table",
 1341|      0|							displayTableList, _lou_showDots(&output.chars[k], 1));
 1342|      0|					return 0;
 1343|      0|				}
 1344|      0|			}
 1345|      0|		}
 1346|      0|		*inlen = posMapping[output.length];
 1347|      0|		*outlen = output.length;
 1348|      0|		// Compute inputPos and outputPos from posMapping. The value at the last index of
 1349|      0|		// posMapping is currectly not used.
 1350|      0|		if (inputPos != NULL) {
 1351|      0|			for (k = 0; k < *outlen; k++)
 1352|      0|				if (posMapping[k] < 0)
 1353|      0|					inputPos[k] = 0;
 1354|      0|				else if (posMapping[k] > *inlen - 1)
 1355|      0|					inputPos[k] = *inlen - 1;
 1356|      0|				else
 1357|      0|					inputPos[k] = posMapping[k];
 1358|      0|		}
 1359|      0|		if (outputPos != NULL) {
 1360|      0|			int inpos = -1;
 1361|      0|			int outpos = -1;
 1362|      0|			for (k = 0; k < *outlen; k++)
 1363|      0|				if (posMapping[k] > inpos) {
 1364|      0|					while (inpos < posMapping[k]) {
 1365|      0|						if (inpos >= 0 && inpos < *inlen)
 1366|      0|							outputPos[inpos] = outpos < 0 ? 0 : outpos;
 1367|      0|						inpos++;
 1368|      0|					}
 1369|      0|					outpos = k;
 1370|      0|				}
 1371|      0|			if (inpos < 0) inpos = 0;
 1372|      0|			while (inpos < *inlen) outputPos[inpos++] = outpos;
 1373|      0|		}
 1374|      0|	}
 1375|      0|	if (destSpacing != NULL) {
 1376|      0|		memcpy(srcSpacing, destSpacing, input.length);
 1377|      0|		srcSpacing[input.length] = 0;
 1378|      0|	}
 1379|      0|	if (cursorPos != NULL && *cursorPos != -1) {
 1380|      0|		if (outputPos != NULL)
 1381|      0|			*cursorPos = outputPos[*cursorPos];
 1382|      0|		else
 1383|      0|			*cursorPos = cursorPosition;
 1384|      0|	}
 1385|      0|	if (rulesLen != NULL) *rulesLen = appliedRulesCount;
 1386|      0|	_lou_logMessage(LOU_LOG_ALL, "Translation complete: outlen=%d", *outlen);
 1387|      0|	_lou_logWidecharBuf(LOU_LOG_ALL, "Outbuf=", (const widechar *)outbuf, *outlen);
 1388|      0|
 1389|      0|	return goodTrans;
 1390|      0|}
 1391|       |
 1392|       |int EXPORT_CALL
 1393|       |lou_translatePrehyphenated(const char *tableList, const widechar *inbufx, int *inlen,
 1394|       |		widechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,
 1395|       |		int *inputPos, int *cursorPos, char *inputHyphens, char *outputHyphens,
 1396|      0|		int mode) {
 1397|      0|	int rv = 1;
 1398|      0|	int *alloc_inputPos = NULL;
 1399|      0|	if (inputHyphens != NULL) {
 1400|      0|		if (outputHyphens == NULL) return 0;
 1401|      0|		if (inputPos == NULL) {
 1402|      0|			if ((alloc_inputPos = malloc(*outlen * sizeof(int))) == NULL)
 1403|      0|				_lou_outOfMemory();
 1404|      0|			inputPos = alloc_inputPos;
 1405|      0|		}
 1406|      0|	}
 1407|      0|	if (lou_translate(tableList, inbufx, inlen, outbuf, outlen, typeform, spacing,
 1408|      0|				outputPos, inputPos, cursorPos, mode)) {
 1409|      0|		if (inputHyphens != NULL) {
 1410|      0|			int inpos = 0;
 1411|      0|			int outpos;
 1412|      0|			for (outpos = 0; outpos < *outlen; outpos++) {
 1413|      0|				int new_inpos = inputPos[outpos];
 1414|      0|				if (new_inpos < inpos) {
 1415|      0|					rv = 0;
 1416|      0|					break;
 1417|      0|				}
 1418|      0|				if (new_inpos > inpos)
 1419|      0|					outputHyphens[outpos] = inputHyphens[new_inpos];
 1420|      0|				else
 1421|      0|					outputHyphens[outpos] = '0';
 1422|      0|				inpos = new_inpos;
 1423|      0|			}
 1424|      0|		}
 1425|      0|	}
 1426|      0|	if (alloc_inputPos != NULL) free(alloc_inputPos);
 1427|      0|	return rv;
 1428|      0|}
 1429|       |
 1430|       |static int
 1431|       |hyphenateWord(const widechar *word, int wordSize, char *hyphens,
 1432|      0|		const TranslationTableHeader *table) {
 1433|      0|	widechar *prepWord;
 1434|      0|	int i, k, limit;
 1435|      0|	int stateNum;
 1436|      0|	widechar ch;
 1437|      0|	HyphenationState *statesArray =
 1438|      0|			(HyphenationState *)&table->ruleArea[table->hyphenStatesArray];
 1439|      0|	HyphenationState *currentState;
 1440|      0|	HyphenationTrans *transitionsArray;
 1441|      0|	char *hyphenPattern;
 1442|      0|	int patternOffset;
 1443|      0|	if (!table->hyphenStatesArray || (wordSize + 3) > MAXSTRING) return 0;
 1444|      0|	prepWord = (widechar *)calloc(wordSize + 3, sizeof(widechar));
 1445|      0|	/* prepWord is of the format ".hello."
 1446|      0|	 * hyphens is the length of the word "hello" "00000" */
 1447|      0|	prepWord[0] = '.';
 1448|      0|	for (i = 0; i < wordSize; i++) {
 1449|      0|		prepWord[i + 1] = toLowercase(table, getChar(word[i], table));
 1450|      0|		hyphens[i] = '0';
 1451|      0|	}
 1452|      0|	prepWord[wordSize + 1] = '.';
 1453|      0|
 1454|      0|	/* now, run the finite state machine */
 1455|      0|	stateNum = 0;
 1456|      0|
 1457|      0|	// we need to walk all of ".hello."
 1458|      0|	for (i = 0; i < wordSize + 2; i++) {
 1459|      0|		ch = prepWord[i];
 1460|      0|		while (1) {
 1461|      0|			if (stateNum == 0xffff) {
 1462|      0|				stateNum = 0;
 1463|      0|				goto nextLetter;
 1464|      0|			}
 1465|      0|			currentState = &statesArray[stateNum];
 1466|      0|			if (currentState->trans.offset) {
 1467|      0|				transitionsArray =
 1468|      0|						(HyphenationTrans *)&table->ruleArea[currentState->trans.offset];
 1469|      0|				for (k = 0; k < currentState->numTrans; k++) {
 1470|      0|					if (transitionsArray[k].ch == ch) {
 1471|      0|						stateNum = transitionsArray[k].newState;
 1472|      0|						goto stateFound;
 1473|      0|					}
 1474|      0|				}
 1475|      0|			}
 1476|      0|			stateNum = currentState->fallbackState;
 1477|      0|		}
 1478|      0|	stateFound:
 1479|      0|		currentState = &statesArray[stateNum];
 1480|      0|		if (currentState->hyphenPattern) {
 1481|      0|			hyphenPattern = (char *)&table->ruleArea[currentState->hyphenPattern];
 1482|      0|			patternOffset = i + 1 - (int)strlen(hyphenPattern);
 1483|      0|
 1484|      0|			/* Need to ensure that we don't overrun hyphens,
 1485|      0|			 * in some cases hyphenPattern is longer than the remaining letters,
 1486|      0|			 * and if we write out all of it we would have overshot our buffer. */
 1487|      0|			limit = MIN((int)strlen(hyphenPattern), wordSize - patternOffset);
 1488|      0|			for (k = 0; k < limit; k++) {
 1489|      0|				if (hyphens[patternOffset + k] < hyphenPattern[k])
 1490|      0|					hyphens[patternOffset + k] = hyphenPattern[k];
 1491|      0|			}
 1492|      0|		}
 1493|      0|	nextLetter:;
 1494|      0|	}
 1495|      0|	hyphens[wordSize] = 0;
 1496|      0|	free(prepWord);
 1497|      0|	return 1;
 1498|      0|}
 1499|       |
 1500|       |static int
 1501|       |doCompTrans(int start, int end, const TranslationTableHeader *table, int *pos,
 1502|       |		const InString *input, OutString *output, int *posMapping,
 1503|       |		EmphasisInfo *emphasisBuffer, const TranslationTableRule **transRule,
 1504|       |		int *cursorPosition, int *cursorStatus, int mode);
 1505|       |
 1506|       |// The `shift' argument should be used with care because it can mess up the positions
 1507|       |// array which is supposed to be monotonically increasing. It is set to -1 in order to
 1508|       |//  append certain indicators (endemphword, endemph, endemphphrase after, endcapsword,
 1509|       |// endcaps, endcapsphrase after) to the preceding character.
 1510|       |static int
 1511|       |for_updatePositions(const widechar *outChars, int inLength, int outLength, int shift,
 1512|       |		int pos, const InString *input, OutString *output, int *posMapping,
 1513|      0|		int *cursorPosition, int *cursorStatus) {
 1514|      0|	int k;
 1515|      0|	if ((output->length + outLength) > output->maxlength ||
 1516|      0|			(pos + inLength) > input->length)
 1517|      0|		return 0;
 1518|      0|	memcpy(&output->chars[output->length], outChars, outLength * CHARSIZE);
 1519|      0|	if (!*cursorStatus) {
 1520|      0|		if (*cursorPosition >= pos && *cursorPosition < (pos + inLength)) {
 1521|      0|			*cursorPosition = output->length;
 1522|      0|			*cursorStatus = 1;
 1523|      0|		} else if (input->chars[*cursorPosition] == 0 &&
 1524|      0|				*cursorPosition == (pos + inLength)) {
 1525|      0|			*cursorPosition = output->length + outLength / 2 + 1;
 1526|      0|			*cursorStatus = 1;
 1527|      0|		}
 1528|      0|	} else if (*cursorStatus == 2 && *cursorPosition == pos)
 1529|      0|		*cursorPosition = output->length;
 1530|      0|	for (k = 0; k < outLength; k++) posMapping[output->length + k] = pos + shift;
 1531|      0|	output->length += outLength;
 1532|      0|	return 1;
 1533|      0|}
 1534|       |
 1535|       |static int
 1536|       |syllableBreak(const TranslationTableHeader *table, int pos, const InString *input,
 1537|      0|		int transCharslen) {
 1538|      0|	int wordStart = 0;
 1539|      0|	int wordEnd = 0;
 1540|      0|	int wordSize = 0;
 1541|      0|	int k = 0;
 1542|      0|	char *hyphens = NULL;
 1543|      0|	for (wordStart = pos; wordStart >= 0; wordStart--)
 1544|      0|		if (!((getChar(input->chars[wordStart], table))->attributes & CTC_Letter)) {
 1545|      0|			wordStart++;
 1546|      0|			break;
 1547|      0|		}
 1548|      0|	if (wordStart < 0) wordStart = 0;
 1549|      0|	for (wordEnd = pos; wordEnd < input->length; wordEnd++)
 1550|      0|		if (!((getChar(input->chars[wordEnd], table))->attributes & CTC_Letter)) {
 1551|      0|			wordEnd--;
 1552|      0|			break;
 1553|      0|		}
 1554|      0|	if (wordEnd == input->length) wordEnd--;
 1555|      0|	/* At this stage wordStart is the 0 based index of the first letter in the word,
 1556|      0|	 * wordEnd is the 0 based index of the last letter in the word.
 1557|      0|	 * example: "hello" wordstart=0, wordEnd=4. */
 1558|      0|	wordSize = wordEnd - wordStart + 1;
 1559|      0|	hyphens = (char *)calloc(wordSize + 1, sizeof(char));
 1560|      0|	if (!hyphenateWord(&input->chars[wordStart], wordSize, hyphens, table)) {
 1561|      0|		free(hyphens);
 1562|      0|		return 0;
 1563|      0|	}
 1564|      0|	for (k = pos - wordStart + 1; k < (pos - wordStart + transCharslen); k++)
 1565|      0|		if (hyphens[k] & 1) {
 1566|      0|			free(hyphens);
 1567|      0|			return 1;
 1568|      0|		}
 1569|      0|	free(hyphens);
 1570|      0|	return 0;
 1571|      0|}
 1572|       |
 1573|       |static void
 1574|       |setBefore(const TranslationTableHeader *table, int pos, const InString *input,
 1575|      0|		TranslationTableCharacterAttributes *beforeAttributes) {
 1576|      0|	widechar before;
 1577|      0|	if (pos >= 2 && input->chars[pos - 1] == LOU_ENDSEGMENT)
 1578|      0|		before = input->chars[pos - 2];
 1579|      0|	else
 1580|      0|		before = (pos == 0) ? ' ' : input->chars[pos - 1];
 1581|      0|	*beforeAttributes = (getChar(before, table))->attributes;
 1582|      0|}
 1583|       |
 1584|       |static void
 1585|       |setAfter(int length, const TranslationTableHeader *table, int pos, const InString *input,
 1586|      0|		TranslationTableCharacterAttributes *afterAttributes) {
 1587|      0|	widechar after;
 1588|      0|	if ((pos + length + 2) < input->length && input->chars[pos + 1] == LOU_ENDSEGMENT)
 1589|      0|		after = input->chars[pos + 2];
 1590|      0|	else
 1591|      0|		after = (pos + length < input->length) ? input->chars[pos + length] : ' ';
 1592|      0|	*afterAttributes = (getChar(after, table))->attributes;
 1593|      0|}
 1594|       |
 1595|       |static int
 1596|       |brailleIndicatorDefined(TranslationTableOffset offset,
 1597|      0|		const TranslationTableHeader *table, const TranslationTableRule **indicRule) {
 1598|      0|	if (!offset) return 0;
 1599|      0|	*indicRule = (TranslationTableRule *)&table->ruleArea[offset];
 1600|      0|	return 1;
 1601|      0|}
 1602|       |
 1603|       |static int
 1604|      0|capsletterDefined(const TranslationTableHeader *table) {
 1605|      0|	return table->emphRules[MAX_EMPH_CLASSES][letterOffset];
 1606|      0|}
 1607|       |
 1608|       |static int
 1609|       |validMatch(const TranslationTableHeader *table, int pos, const InString *input,
 1610|      0|		formtype *typebuf, const TranslationTableRule *transRule, int transCharslen) {
 1611|      0|	/* Analyze the typeform parameter and also check for capitalization */
 1612|      0|	TranslationTableCharacter *inputChar;
 1613|      0|	TranslationTableCharacter *ruleChar;
 1614|      0|	TranslationTableCharacterAttributes prevAttr = 0;
 1615|      0|	int k;
 1616|      0|	int kk = 0;
 1617|      0|	if (!transCharslen) return 0;
 1618|      0|	for (k = pos; k < pos + transCharslen; k++) {
 1619|      0|		if (input->chars[k] == LOU_ENDSEGMENT) {
 1620|      0|			if (k == pos && transCharslen == 1)
 1621|      0|				return 1;
 1622|      0|			else
 1623|      0|				return 0;
 1624|      0|		}
 1625|      0|		inputChar = getChar(input->chars[k], table);
 1626|      0|		if (k == pos) prevAttr = inputChar->attributes;
 1627|      0|		ruleChar = getChar(transRule->charsdots[kk++], table);
 1628|      0|		if (toLowercase(table, inputChar) != toLowercase(table, ruleChar)) return 0;
 1629|      0|		if (typebuf != NULL && (typebuf[pos] & CAPSEMPH) == 0 &&
 1630|      0|				(typebuf[k] | typebuf[pos]) != typebuf[pos])
 1631|      0|			return 0;
 1632|      0|		if (inputChar->attributes != CTC_Letter) {
 1633|      0|			if (k != (pos + 1) && (prevAttr & CTC_Letter) &&
 1634|      0|					(inputChar->attributes & CTC_Letter) &&
 1635|      0|					((inputChar->attributes &
 1636|      0|							 (CTC_LowerCase | CTC_UpperCase | CTC_Letter)) !=
 1637|      0|							(prevAttr & (CTC_LowerCase | CTC_UpperCase | CTC_Letter))))
 1638|      0|				return 0;
 1639|      0|		}
 1640|      0|		prevAttr = inputChar->attributes;
 1641|      0|	}
 1642|      0|	return 1;
 1643|      0|}
 1644|       |
 1645|       |static int
 1646|       |insertNumberSign(const TranslationTableHeader *table, int pos, const InString *input,
 1647|       |		OutString *output, int *posMapping, int prevTransOpcode, int *cursorPosition,
 1648|      0|		int *cursorStatus, TranslationTableCharacterAttributes beforeAttributes) {
 1649|      0|	const TranslationTableRule *numberSign;
 1650|      0|	if (brailleIndicatorDefined(table->numberSign, table, &numberSign) &&
 1651|      0|			checkCharAttr_safe(input, pos, CTC_Digit, table) &&
 1652|      0|			(prevTransOpcode == CTO_ExactDots ||
 1653|      0|					(!(beforeAttributes & CTC_Digit) && prevTransOpcode != CTO_MidNum))) {
 1654|      0|		if (!for_updatePositions(&numberSign->charsdots[0], 0, numberSign->dotslen, 0,
 1655|      0|					pos, input, output, posMapping, cursorPosition, cursorStatus))
 1656|      0|			return 0;
 1657|      0|	}
 1658|      0|	return 1;
 1659|      0|}
 1660|       |
 1661|       |static int
 1662|      0|isNoLetsign(widechar c, const TranslationTableHeader *table) {
 1663|      0|	for (int k = 0; k < table->noLetsignCount; k++)
 1664|      0|		if (c == table->noLetsign[k]) return 1;
 1665|      0|	return 0;
 1666|      0|}
 1667|       |
 1668|       |static int
 1669|      0|isNoLetsignBefore(widechar c, const TranslationTableHeader *table) {
 1670|      0|	for (int k = 0; k < table->noLetsignBeforeCount; k++)
 1671|      0|		if (c == table->noLetsignBefore[k]) return 1;
 1672|      0|	return 0;
 1673|      0|}
 1674|       |
 1675|       |static int
 1676|      0|isNoLetsignAfter(widechar c, const TranslationTableHeader *table) {
 1677|      0|	for (int k = 0; k < table->noLetsignAfterCount; k++)
 1678|      0|		if (c == table->noLetsignAfter[k]) return 1;
 1679|      0|	return 0;
 1680|      0|}
 1681|       |
 1682|       |static int
 1683|       |insertLetterSign(const TranslationTableHeader *table, int pos, const InString *input,
 1684|       |		OutString *output, int *posMapping, int transOpcode, int *cursorPosition,
 1685|      0|		int *cursorStatus, TranslationTableCharacterAttributes beforeAttributes) {
 1686|      0|	const TranslationTableRule *letterSign;
 1687|      0|	if (brailleIndicatorDefined(table->letterSign, table, &letterSign)) {
 1688|      0|		if (transOpcode == CTO_Contraction) {
 1689|      0|			if (!for_updatePositions(&letterSign->charsdots[0], 0, letterSign->dotslen, 0,
 1690|      0|						pos, input, output, posMapping, cursorPosition, cursorStatus))
 1691|      0|				return 0;
 1692|      0|		} else if ((checkCharAttr_safe(input, pos, CTC_Letter, table) &&
 1693|      0|						   !(beforeAttributes & CTC_Letter)) &&
 1694|      0|				(!checkCharAttr_safe(input, pos + 1, CTC_Letter, table) ||
 1695|      0|						(beforeAttributes & CTC_Digit))) {
 1696|      0|			if (pos > 0 && isNoLetsignBefore(input->chars[pos - 1], table)) return 1;
 1697|      0|			if (isNoLetsign(input->chars[pos], table)) return 1;
 1698|      0|			if (pos + 1 < input->length && isNoLetsignAfter(input->chars[pos + 1], table))
 1699|      0|				return 1;
 1700|      0|			if (!for_updatePositions(&letterSign->charsdots[0], 0, letterSign->dotslen, 0,
 1701|      0|						pos, input, output, posMapping, cursorPosition, cursorStatus))
 1702|      0|				return 0;
 1703|      0|		}
 1704|      0|	}
 1705|      0|	return 1;
 1706|      0|}
 1707|       |
 1708|       |static int
 1709|       |onlyLettersBehind(const TranslationTableHeader *table, int pos, const InString *input,
 1710|      0|		TranslationTableCharacterAttributes beforeAttributes) {
 1711|      0|	/* Actually, spaces, then letters */
 1712|      0|	int k;
 1713|      0|	if (!(beforeAttributes & CTC_Space)) return 0;
 1714|      0|	for (k = pos - 2; k >= 0; k--) {
 1715|      0|		TranslationTableCharacterAttributes attr =
 1716|      0|				(getChar(input->chars[k], table))->attributes;
 1717|      0|		if ((attr & CTC_Space)) continue;
 1718|      0|		if ((attr & CTC_Letter))
 1719|      0|			return 1;
 1720|      0|		else
 1721|      0|			return 0;
 1722|      0|	}
 1723|      0|	return 1;
 1724|      0|}
 1725|       |
 1726|       |static int
 1727|       |onlyLettersAhead(const TranslationTableHeader *table, int pos, const InString *input,
 1728|      0|		int transCharslen, TranslationTableCharacterAttributes afterAttributes) {
 1729|      0|	/* Actullly, spaces, then letters */
 1730|      0|	int k;
 1731|      0|	if (!(afterAttributes & CTC_Space)) return 0;
 1732|      0|	for (k = pos + transCharslen + 1; k < input->length; k++) {
 1733|      0|		TranslationTableCharacterAttributes attr =
 1734|      0|				(getChar(input->chars[k], table))->attributes;
 1735|      0|		if ((attr & CTC_Space)) continue;
 1736|      0|		if ((attr & (CTC_Letter | CTC_LitDigit)))
 1737|      0|			return 1;
 1738|      0|		else
 1739|      0|			return 0;
 1740|      0|	}
 1741|      0|	return 0;
 1742|      0|}
 1743|       |
 1744|       |static int
 1745|       |noCompbrlAhead(const TranslationTableHeader *table, int pos, int mode,
 1746|      0|		const InString *input, int transOpcode, int transCharslen, int cursorPosition) {
 1747|      0|	int start = pos + transCharslen;
 1748|      0|	int end;
 1749|      0|	int p;
 1750|      0|	if (start >= input->length) return 1;
 1751|      0|	while (start < input->length && checkCharAttr(input->chars[start], CTC_Space, table))
 1752|      0|		start++;
 1753|      0|	if (start == input->length ||
 1754|      0|			(transOpcode == CTO_JoinableWord &&
 1755|      0|					(!checkCharAttr(input->chars[start], CTC_Letter | CTC_Digit, table) ||
 1756|      0|							!checkCharAttr(input->chars[start - 1], CTC_Space, table))))
 1757|      0|		return 1;
 1758|      0|	end = start;
 1759|      0|	while (end < input->length && !checkCharAttr(input->chars[end], CTC_Space, table))
 1760|      0|		end++;
 1761|      0|	if ((mode & (compbrlAtCursor | compbrlLeftCursor)) && cursorPosition >= start &&
 1762|      0|			cursorPosition < end)
 1763|      0|		return 0;
 1764|      0|	/* Look ahead for rules with CTO_CompBrl */
 1765|      0|	for (p = start; p < end; p++) {
 1766|      0|		int length = input->length - p;
 1767|      0|		int tryThis;
 1768|      0|		int k;
 1769|      0|		for (tryThis = 0; tryThis < 2; tryThis++) {
 1770|      0|			TranslationTableOffset ruleOffset = 0;
 1771|      0|			TranslationTableRule *testRule;
 1772|      0|			switch (tryThis) {
 1773|      0|			case 0:
 1774|      0|				if (!(length >= 2)) break;
 1775|      0|				ruleOffset = table->forRules[_lou_stringHash(&input->chars[p], 1, table)];
 1776|      0|				break;
 1777|      0|			case 1:
 1778|      0|				if (!(length >= 1)) break;
 1779|      0|				length = 1;
 1780|      0|				ruleOffset = getChar(input->chars[p], table)->otherRules;
 1781|      0|				break;
 1782|      0|			}
 1783|      0|			while (ruleOffset) {
 1784|      0|				const TranslationTableCharacter *character1;
 1785|      0|				const TranslationTableCharacter *character2;
 1786|      0|				testRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];
 1787|      0|				for (k = 0; k < testRule->charslen; k++) {
 1788|      0|					character1 = getChar(testRule->charsdots[k], table);
 1789|      0|					character2 = getChar(input->chars[p + k], table);
 1790|      0|					if (toLowercase(table, character1) != toLowercase(table, character2))
 1791|      0|						break;
 1792|      0|				}
 1793|      0|				if (tryThis == 1 || k == testRule->charslen) {
 1794|      0|					if (testRule->opcode == CTO_CompBrl ||
 1795|      0|							testRule->opcode == CTO_Literal)
 1796|      0|						return 0;
 1797|      0|				}
 1798|      0|				ruleOffset = testRule->charsnext;
 1799|      0|			}
 1800|      0|		}
 1801|      0|	}
 1802|      0|	return 1;
 1803|      0|}
 1804|       |
 1805|       |static int
 1806|      0|checkEmphasisChange(int pos, int len, const EmphasisInfo *emphasisBuffer) {
 1807|      0|	int i;
 1808|      0|	for (i = pos + 1; i < pos + len; i++)
 1809|      0|		if (emphasisBuffer[i].begin || emphasisBuffer[i].end || emphasisBuffer[i].word ||
 1810|      0|				emphasisBuffer[i].symbol)
 1811|      0|			return 1;
 1812|      0|	return 0;
 1813|      0|}
 1814|       |
 1815|       |static int
 1816|       |isRepeatedWord(const TranslationTableHeader *table, int pos, const InString *input,
 1817|       |		const EmphasisInfo *emphasisBuffer, int outputLength, const int *posMapping,
 1818|      0|		int transCharslen, int *repwordLength) {
 1819|      0|	/* transCharslen is the length of the character sequence that separates the repeated
 1820|      0|	 * parts */
 1821|      0|	int len;
 1822|      0|	/* maximum length that the repeated part can have is determined by how many letters
 1823|      0|	 * there are before and after the separator */
 1824|      0|	for (len = 1; pos - len >= 0 && pos + transCharslen + len - 1 < input->length &&
 1825|      0|			checkCharAttr(input->chars[pos - len], CTC_Letter, table) &&
 1826|      0|			checkCharAttr(input->chars[pos + transCharslen + len - 1], CTC_Letter, table);
 1827|      0|			len++)
 1828|      0|		;
 1829|      0|	len--;
 1830|      0|	/* now actually compare the parts, starting with the maximal length and making them
 1831|      0|	 * shorter if they don't match */
 1832|      0|	while (len > 0) {
 1833|      0|		int start = pos - len;
 1834|      0|		if (compareChars(&input->chars[start], &input->chars[pos + transCharslen], len,
 1835|      0|					table)) {
 1836|      0|			/* part must not start within a contraction */
 1837|      0|			for (int k = outputLength - 1; k >= 0; k--)
 1838|      0|				if (posMapping[k] == start)
 1839|      0|					break;
 1840|      0|				else if (posMapping[k] < start)
 1841|      0|					return 0;
 1842|      0|			/* capitalisation and emphasis may not change except at the beginning of the
 1843|      0|			 * parts */
 1844|      0|			if (checkEmphasisChange(start, len + transCharslen, emphasisBuffer) ||
 1845|      0|					checkEmphasisChange(pos + transCharslen, len, emphasisBuffer))
 1846|      0|				return 0;
 1847|      0|			*repwordLength = len;
 1848|      0|			return 1;
 1849|      0|		}
 1850|      0|		len--;
 1851|      0|	}
 1852|      0|	return 0;
 1853|      0|}
 1854|       |
 1855|       |static int
 1856|       |inSequence(const TranslationTableHeader *table, int pos, const InString *input,
 1857|      0|		const TranslationTableRule *transRule) {
 1858|      0|	int i, j, s, match;
 1859|      0|	// TODO: all caps words
 1860|      0|	// const TranslationTableCharacter *c = NULL;
 1861|      0|
 1862|      0|	/* check before sequence */
 1863|      0|	for (i = pos - 1; i >= 0; i--) {
 1864|      0|		if (checkCharAttr(input->chars[i], CTC_SeqBefore, table)) continue;
 1865|      0|		if (!(checkCharAttr(input->chars[i], CTC_Space | CTC_SeqDelimiter, table)))
 1866|      0|			return 0;
 1867|      0|		break;
 1868|      0|	}
 1869|      0|
 1870|      0|	/* check after sequence */
 1871|      0|	for (i = pos + transRule->charslen; i < input->length; i++) {
 1872|      0|		/* check sequence after patterns */
 1873|      0|		if (table->seqPatternsCount) {
 1874|      0|			match = 0;
 1875|      0|			for (j = i, s = 0; j <= input->length && s < table->seqPatternsCount;
 1876|      0|					j++, s++) {
 1877|      0|				/* matching */
 1878|      0|				if (match == 1) {
 1879|      0|					if (table->seqPatterns[s]) {
 1880|      0|						if (input->chars[j] == table->seqPatterns[s])
 1881|      0|							match = 1;
 1882|      0|						else {
 1883|      0|							match = -1;
 1884|      0|							j = i - 1;
 1885|      0|						}
 1886|      0|					}
 1887|      0|
 1888|      0|					/* found match */
 1889|      0|					else {
 1890|      0|						/* pattern at end of input */
 1891|      0|						if (j >= input->length) return 1;
 1892|      0|
 1893|      0|						i = j;
 1894|      0|						break;
 1895|      0|					}
 1896|      0|				}
 1897|      0|
 1898|      0|				/* looking for match */
 1899|      0|				else if (match == 0) {
 1900|      0|					if (table->seqPatterns[s]) {
 1901|      0|						if (input->chars[j] == table->seqPatterns[s])
 1902|      0|							match = 1;
 1903|      0|						else {
 1904|      0|							match = -1;
 1905|      0|							j = i - 1;
 1906|      0|						}
 1907|      0|					}
 1908|      0|				}
 1909|      0|
 1910|      0|				/* next pattarn */
 1911|      0|				else if (match == -1) {
 1912|      0|					if (!table->seqPatterns[s]) {
 1913|      0|						match = 0;
 1914|      0|						j = i - 1;
 1915|      0|					}
 1916|      0|				}
 1917|      0|			}
 1918|      0|		}
 1919|      0|
 1920|      0|		if (checkCharAttr(input->chars[i], CTC_SeqAfter, table)) continue;
 1921|      0|		if (!(checkCharAttr(input->chars[i], CTC_Space | CTC_SeqDelimiter, table)))
 1922|      0|			return 0;
 1923|      0|		break;
 1924|      0|	}
 1925|      0|
 1926|      0|	return 1;
 1927|      0|}
 1928|       |
 1929|       |static void
 1930|       |for_selectRule(const TranslationTableHeader *table, int pos, OutString output,
 1931|       |		const int *posMapping, int mode, const InString *input, formtype *typebuf,
 1932|       |		EmphasisInfo *emphasisBuffer, int *transOpcode, int prevTransOpcode,
 1933|       |		const TranslationTableRule **transRule, int *transCharslen, int *passCharDots,
 1934|       |		widechar const **passInstructions, int *passIC, PassRuleMatch *patternMatch,
 1935|       |		int posIncremented, int cursorPosition, int *repwordLength, int dontContract,
 1936|       |		int compbrlStart, int compbrlEnd,
 1937|       |		TranslationTableCharacterAttributes beforeAttributes,
 1938|       |		TranslationTableCharacter **curCharDef, TranslationTableRule **groupingRule,
 1939|      0|		widechar *groupingOp) {
 1940|      0|	/* check for valid Translations. Return value is in transRule. */
 1941|      0|	static TranslationTableRule pseudoRule = { 0 };
 1942|      0|	int length = ((pos < compbrlStart) ? compbrlStart : input->length) - pos;
 1943|      0|	int tryThis;
 1944|      0|	int k;
 1945|      0|	TranslationTableOffset ruleOffset = 0;
 1946|      0|	*curCharDef = getChar(input->chars[pos], table);
 1947|      0|	for (tryThis = 0; tryThis < 3; tryThis++) {
 1948|      0|		switch (tryThis) {
 1949|      0|		case 0:
 1950|      0|			if (!(length >= 2)) break;
 1951|      0|			ruleOffset = table->forRules[_lou_stringHash(&input->chars[pos], 1, table)];
 1952|      0|			break;
 1953|      0|		case 1:
 1954|      0|			if (!(length >= 1)) break;
 1955|      0|			length = 1;
 1956|      0|			ruleOffset = (*curCharDef)->otherRules;
 1957|      0|			break;
 1958|      0|		case 2: /* No rule found */
 1959|      0|			*transRule = &pseudoRule;
 1960|      0|			*transOpcode = pseudoRule.opcode = CTO_None;
 1961|      0|			*transCharslen = pseudoRule.charslen = 1;
 1962|      0|			pseudoRule.charsdots[0] = input->chars[pos];
 1963|      0|			pseudoRule.dotslen = 0;
 1964|      0|			return;
 1965|      0|		}
 1966|      0|		while (ruleOffset) {
 1967|      0|			*transRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];
 1968|      0|			*transOpcode = (*transRule)->opcode;
 1969|      0|			*transCharslen = (*transRule)->charslen;
 1970|      0|			if (tryThis == 1 ||
 1971|      0|					((*transCharslen <= length) &&
 1972|      0|							validMatch(table, pos, input, typebuf, *transRule,
 1973|      0|									*transCharslen))) {
 1974|      0|				TranslationTableCharacterAttributes afterAttributes;
 1975|      0|				/* check before emphasis match */
 1976|      0|				if ((*transRule)->before & CTC_EmpMatch) {
 1977|      0|					if (emphasisBuffer[pos].begin || emphasisBuffer[pos].end ||
 1978|      0|							emphasisBuffer[pos].word || emphasisBuffer[pos].symbol)
 1979|      0|						break;
 1980|      0|				}
 1981|      0|
 1982|      0|				/* check after emphasis match */
 1983|      0|				if ((*transRule)->after & CTC_EmpMatch) {
 1984|      0|					if (emphasisBuffer[pos + *transCharslen].begin ||
 1985|      0|							emphasisBuffer[pos + *transCharslen].end ||
 1986|      0|							emphasisBuffer[pos + *transCharslen].word ||
 1987|      0|							emphasisBuffer[pos + *transCharslen].symbol)
 1988|      0|						break;
 1989|      0|				}
 1990|      0|
 1991|      0|				/* check this rule */
 1992|      0|				setAfter(*transCharslen, table, pos, input, &afterAttributes);
 1993|      0|				if ((!((*transRule)->after & ~CTC_EmpMatch) ||
 1994|      0|							(beforeAttributes & (*transRule)->after)) &&
 1995|      0|						(!((*transRule)->before & ~CTC_EmpMatch) ||
 1996|      0|								(afterAttributes & (*transRule)->before)))
 1997|      0|					/* check nocross */
 1998|      0|					if (!((*transRule)->nocross &&
 1999|      0|								syllableBreak(table, pos, input, *transCharslen))) {
 2000|      0|						switch (*transOpcode) { /* check validity of this Translation */
 2001|      0|						case CTO_Space:
 2002|      0|						case CTO_Letter:
 2003|      0|						case CTO_UpperCase:
 2004|      0|						case CTO_LowerCase:
 2005|      0|						case CTO_Digit:
 2006|      0|						case CTO_LitDigit:
 2007|      0|						case CTO_Punctuation:
 2008|      0|						case CTO_Math:
 2009|      0|						case CTO_Sign:
 2010|      0|						case CTO_Hyphen:
 2011|      0|						case CTO_Replace:
 2012|      0|						case CTO_CompBrl:
 2013|      0|						case CTO_Literal:
 2014|      0|							return;
 2015|      0|						case CTO_Repeated:
 2016|      0|							if (dontContract || (mode & noContractions)) break;
 2017|      0|							if ((mode & (compbrlAtCursor | compbrlLeftCursor)) &&
 2018|      0|									pos >= compbrlStart && pos <= compbrlEnd)
 2019|      0|								break;
 2020|      0|							return;
 2021|      0|						case CTO_RepWord:
 2022|      0|						case CTO_RepEndWord:
 2023|      0|							if (dontContract || (mode & noContractions)) break;
 2024|      0|							if (isRepeatedWord(table, pos, input, emphasisBuffer,
 2025|      0|										output.length, posMapping, *transCharslen,
 2026|      0|										repwordLength)) {
 2027|      0|								if ((pos > *repwordLength &&
 2028|      0|											checkCharAttr(input->chars[pos -
 2029|      0|																  *repwordLength - 1],
 2030|      0|													CTC_Letter, table)) ==
 2031|      0|										(*transOpcode == CTO_RepEndWord)) {
 2032|      0|									return;
 2033|      0|								}
 2034|      0|							}
 2035|      0|							break;
 2036|      0|						case CTO_NoCont:
 2037|      0|							if (dontContract || (mode & noContractions)) break;
 2038|      0|							return;
 2039|      0|						case CTO_Syllable:
 2040|      0|							*transOpcode = CTO_Always;
 2041|      0|						case CTO_Always:
 2042|      0|							if (checkEmphasisChange(pos, *transCharslen, emphasisBuffer))
 2043|      0|								break;
 2044|      0|							if (dontContract || (mode & noContractions)) break;
 2045|      0|							return;
 2046|      0|						case CTO_ExactDots:
 2047|      0|							return;
 2048|      0|						case CTO_Context:
 2049|      0|							// check posIncremented to avoid endless loop
 2050|      0|							if (!posIncremented ||
 2051|      0|									!passDoTest(table, pos, input, *transOpcode,
 2052|      0|											*transRule, passCharDots, passInstructions,
 2053|      0|											passIC, patternMatch, groupingRule,
 2054|      0|											groupingOp))
 2055|      0|								break;
 2056|      0|							return;
 2057|      0|						case CTO_LargeSign:
 2058|      0|							if (dontContract || (mode & noContractions)) break;
 2059|      0|							if (!((beforeAttributes & (CTC_Space | CTC_Punctuation)) ||
 2060|      0|										onlyLettersBehind(
 2061|      0|												table, pos, input, beforeAttributes)) ||
 2062|      0|									!((afterAttributes & CTC_Space) ||
 2063|      0|											prevTransOpcode == CTO_LargeSign) ||
 2064|      0|									(afterAttributes & CTC_Letter) ||
 2065|      0|									!noCompbrlAhead(table, pos, mode, input, *transOpcode,
 2066|      0|											*transCharslen, cursorPosition))
 2067|      0|								*transOpcode = CTO_Always;
 2068|      0|							return;
 2069|      0|						case CTO_WholeWord:
 2070|      0|							if (dontContract || (mode & noContractions)) break;
 2071|      0|							if (checkEmphasisChange(pos, *transCharslen, emphasisBuffer))
 2072|      0|								break;
 2073|      0|						case CTO_Contraction:
 2074|      0|							if (table->usesSequences) {
 2075|      0|								if (inSequence(table, pos, input, *transRule)) return;
 2076|      0|							} else {
 2077|      0|								if ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&
 2078|      0|										(afterAttributes & (CTC_Space | CTC_Punctuation)))
 2079|      0|									return;
 2080|      0|							}
 2081|      0|							break;
 2082|      0|						case CTO_PartWord:
 2083|      0|							if (dontContract || (mode & noContractions)) break;
 2084|      0|							if ((beforeAttributes & CTC_Letter) ||
 2085|      0|									(afterAttributes & CTC_Letter))
 2086|      0|								return;
 2087|      0|							break;
 2088|      0|						case CTO_JoinNum:
 2089|      0|							if (dontContract || (mode & noContractions)) break;
 2090|      0|							if ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&
 2091|      0|									(afterAttributes & CTC_Space) &&
 2092|      0|									(output.length + (*transRule)->dotslen <
 2093|      0|											output.maxlength)) {
 2094|      0|								int p = pos + *transCharslen + 1;
 2095|      0|								while (p < input->length) {
 2096|      0|									if (!checkCharAttr(
 2097|      0|												input->chars[p], CTC_Space, table)) {
 2098|      0|										if (checkCharAttr(
 2099|      0|													input->chars[p], CTC_Digit, table))
 2100|      0|											return;
 2101|      0|										break;
 2102|      0|									}
 2103|      0|									p++;
 2104|      0|								}
 2105|      0|							}
 2106|      0|							break;
 2107|      0|						case CTO_LowWord:
 2108|      0|							if (dontContract || (mode & noContractions)) break;
 2109|      0|							if ((beforeAttributes & CTC_Space) &&
 2110|      0|									(afterAttributes & CTC_Space) &&
 2111|      0|									(prevTransOpcode != CTO_JoinableWord))
 2112|      0|								return;
 2113|      0|							break;
 2114|      0|						case CTO_JoinableWord:
 2115|      0|							if (dontContract || (mode & noContractions)) break;
 2116|      0|							if (beforeAttributes & (CTC_Space | CTC_Punctuation) &&
 2117|      0|									onlyLettersAhead(table, pos, input, *transCharslen,
 2118|      0|											afterAttributes) &&
 2119|      0|									noCompbrlAhead(table, pos, mode, input, *transOpcode,
 2120|      0|											*transCharslen, cursorPosition))
 2121|      0|								return;
 2122|      0|							break;
 2123|      0|						case CTO_SuffixableWord:
 2124|      0|							if (dontContract || (mode & noContractions)) break;
 2125|      0|							if ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&
 2126|      0|									(afterAttributes &
 2127|      0|											(CTC_Space | CTC_Letter | CTC_Punctuation)))
 2128|      0|								return;
 2129|      0|							break;
 2130|      0|						case CTO_PrefixableWord:
 2131|      0|							if (dontContract || (mode & noContractions)) break;
 2132|      0|							if ((beforeAttributes &
 2133|      0|										(CTC_Space | CTC_Letter | CTC_Punctuation)) &&
 2134|      0|									(afterAttributes & (CTC_Space | CTC_Punctuation)))
 2135|      0|								return;
 2136|      0|							break;
 2137|      0|						case CTO_BegWord:
 2138|      0|							if (dontContract || (mode & noContractions)) break;
 2139|      0|							if ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&
 2140|      0|									(afterAttributes & CTC_Letter))
 2141|      0|								return;
 2142|      0|							break;
 2143|      0|						case CTO_BegMidWord:
 2144|      0|							if (dontContract || (mode & noContractions)) break;
 2145|      0|							if ((beforeAttributes &
 2146|      0|										(CTC_Letter | CTC_Space | CTC_Punctuation)) &&
 2147|      0|									(afterAttributes & CTC_Letter))
 2148|      0|								return;
 2149|      0|							break;
 2150|      0|						case CTO_MidWord:
 2151|      0|							if (dontContract || (mode & noContractions)) break;
 2152|      0|							if (beforeAttributes & CTC_Letter &&
 2153|      0|									afterAttributes & CTC_Letter)
 2154|      0|								return;
 2155|      0|							break;
 2156|      0|						case CTO_MidEndWord:
 2157|      0|							if (dontContract || (mode & noContractions)) break;
 2158|      0|							if (beforeAttributes & CTC_Letter &&
 2159|      0|									afterAttributes &
 2160|      0|											(CTC_Letter | CTC_Space | CTC_Punctuation))
 2161|      0|								return;
 2162|      0|							break;
 2163|      0|						case CTO_EndWord:
 2164|      0|							if (dontContract || (mode & noContractions)) break;
 2165|      0|							if (beforeAttributes & CTC_Letter &&
 2166|      0|									afterAttributes & (CTC_Space | CTC_Punctuation))
 2167|      0|								return;
 2168|      0|							break;
 2169|      0|						case CTO_BegNum:
 2170|      0|							if (beforeAttributes & (CTC_Space | CTC_Punctuation) &&
 2171|      0|									afterAttributes & CTC_Digit)
 2172|      0|								return;
 2173|      0|							break;
 2174|      0|						case CTO_MidNum:
 2175|      0|							if (prevTransOpcode != CTO_ExactDots &&
 2176|      0|									beforeAttributes & CTC_Digit &&
 2177|      0|									afterAttributes & CTC_Digit)
 2178|      0|								return;
 2179|      0|							break;
 2180|      0|						case CTO_EndNum:
 2181|      0|							if (beforeAttributes & CTC_Digit &&
 2182|      0|									prevTransOpcode != CTO_ExactDots)
 2183|      0|								return;
 2184|      0|							break;
 2185|      0|						case CTO_DecPoint:
 2186|      0|							if (!(afterAttributes & CTC_Digit)) break;
 2187|      0|							if (beforeAttributes & CTC_Digit) *transOpcode = CTO_MidNum;
 2188|      0|							return;
 2189|      0|						case CTO_PrePunc:
 2190|      0|							if (!checkCharAttr(
 2191|      0|										input->chars[pos], CTC_Punctuation, table) ||
 2192|      0|									(pos > 0 &&
 2193|      0|											checkCharAttr(input->chars[pos - 1],
 2194|      0|													CTC_Letter, table)))
 2195|      0|								break;
 2196|      0|							for (k = pos + *transCharslen; k < input->length; k++) {
 2197|      0|								if (checkCharAttr(input->chars[k],
 2198|      0|											(CTC_Letter | CTC_Digit), table))
 2199|      0|									return;
 2200|      0|								if (checkCharAttr(input->chars[k], CTC_Space, table))
 2201|      0|									break;
 2202|      0|							}
 2203|      0|							break;
 2204|      0|						case CTO_PostPunc:
 2205|      0|							if (!checkCharAttr(
 2206|      0|										input->chars[pos], CTC_Punctuation, table) ||
 2207|      0|									(pos < (input->length - 1) &&
 2208|      0|											checkCharAttr(input->chars[pos + 1],
 2209|      0|													CTC_Letter, table)))
 2210|      0|								break;
 2211|      0|							for (k = pos; k >= 0; k--) {
 2212|      0|								if (checkCharAttr(input->chars[k],
 2213|      0|											(CTC_Letter | CTC_Digit), table))
 2214|      0|									return;
 2215|      0|								if (checkCharAttr(input->chars[k], CTC_Space, table))
 2216|      0|									break;
 2217|      0|							}
 2218|      0|							break;
 2219|      0|
 2220|      0|						case CTO_Match: {
 2221|      0|							widechar *patterns, *pattern;
 2222|      0|
 2223|      0|							if (dontContract || (mode & noContractions)) break;
 2224|      0|							if (checkEmphasisChange(pos, *transCharslen, emphasisBuffer))
 2225|      0|								break;
 2226|      0|
 2227|      0|							patterns =
 2228|      0|									(widechar *)&table->ruleArea[(*transRule)->patterns];
 2229|      0|
 2230|      0|							/* check before pattern */
 2231|      0|							pattern = &patterns[1];
 2232|      0|							if (!_lou_pattern_check(
 2233|      0|										input->chars, pos - 1, -1, -1, pattern, table))
 2234|      0|								break;
 2235|      0|
 2236|      0|							/* check after pattern */
 2237|      0|							pattern = &patterns[patterns[0]];
 2238|      0|							if (!_lou_pattern_check(input->chars,
 2239|      0|										pos + (*transRule)->charslen, input->length, 1,
 2240|      0|										pattern, table))
 2241|      0|								break;
 2242|      0|
 2243|      0|							return;
 2244|      0|						}
 2245|      0|
 2246|      0|						default:
 2247|      0|							break;
 2248|      0|						}
 2249|      0|					}
 2250|      0|			}
 2251|      0|			/* Done with checking this rule */
 2252|      0|			ruleOffset = (*transRule)->charsnext;
 2253|      0|		}
 2254|      0|	}
 2255|      0|}
 2256|       |
 2257|       |static int
 2258|       |undefinedCharacter(widechar c, const TranslationTableHeader *table, int pos,
 2259|       |		const InString *input, OutString *output, int *posMapping, int *cursorPosition,
 2260|      0|		int *cursorStatus, int mode) {
 2261|      0|	/* Display an undefined character in the output buffer */
 2262|      0|	if (table->undefined) {
 2263|      0|		TranslationTableRule *rule =
 2264|      0|				(TranslationTableRule *)&table->ruleArea[table->undefined];
 2265|      0|
 2266|      0|		return for_updatePositions(&rule->charsdots[rule->charslen], rule->charslen,
 2267|      0|				rule->dotslen, 0, pos, input, output, posMapping, cursorPosition,
 2268|      0|				cursorStatus);
 2269|      0|	}
 2270|      0|
 2271|      0|	const char *text = (mode & noUndefined) ? "" : _lou_showString(&c, 1, 1);
 2272|      0|	size_t length = strlen(text);
 2273|      0|	widechar dots[length == 0 ? 1 : length];
 2274|      0|
 2275|      0|	for (unsigned int k = 0; k < length; k += 1) {
 2276|      0|		dots[k] = 0;
 2277|      0|		// looking in otherRules and not definitionRule because definitionRule gives us
 2278|      0|		// the last occurence of a character definition rule and we are interested in
 2279|      0|		// the first
 2280|      0|		TranslationTableOffset offset = getChar(text[k], table)->otherRules;
 2281|      0|		while (offset) {
 2282|      0|			const TranslationTableRule *r =
 2283|      0|					(TranslationTableRule *)&table->ruleArea[offset];
 2284|      0|			if (r->opcode >= CTO_Space && r->opcode < CTO_UpLow && r->dotslen == 1) {
 2285|      0|				dots[k] = r->charsdots[1];
 2286|      0|				break;
 2287|      0|			}
 2288|      0|			offset = r->charsnext;
 2289|      0|		}
 2290|      0|		if (!dots[k]) dots[k] = _lou_charToFallbackDots(text[k]);
 2291|      0|	}
 2292|      0|
 2293|      0|	return for_updatePositions(dots, 1, length, 0, pos, input, output, posMapping,
 2294|      0|			cursorPosition, cursorStatus);
 2295|      0|}
 2296|       |
 2297|       |static int
 2298|       |putCharacter(widechar character, const TranslationTableHeader *table, int pos,
 2299|       |		const InString *input, OutString *output, int *posMapping, int *cursorPosition,
 2300|      0|		int *cursorStatus, int mode) {
 2301|      0|	/* Insert the dots equivalent of a character into the output buffer */
 2302|      0|	TranslationTableOffset offset;
 2303|      0|	TranslationTableCharacter *chardef = getChar(character, table);
 2304|      0|	if (chardef->basechar)
 2305|      0|		chardef = (TranslationTableCharacter *)&table->ruleArea[chardef->basechar];
 2306|      0|	offset = chardef->definitionRule;
 2307|      0|	if (offset) {
 2308|      0|		const TranslationTableRule *rule =
 2309|      0|				(TranslationTableRule *)&table->ruleArea[offset];
 2310|      0|		return for_updatePositions(&rule->charsdots[1], 1, rule->dotslen, 0, pos, input,
 2311|      0|				output, posMapping, cursorPosition, cursorStatus);
 2312|      0|	}
 2313|      0|	return undefinedCharacter(character, table, pos, input, output, posMapping,
 2314|      0|			cursorPosition, cursorStatus, mode);
 2315|      0|}
 2316|       |
 2317|       |static int
 2318|       |putCharacters(const widechar *characters, int count, const TranslationTableHeader *table,
 2319|       |		int pos, const InString *input, OutString *output, int *posMapping,
 2320|      0|		int *cursorPosition, int *cursorStatus, int mode) {
 2321|      0|	/* Insert the dot equivalents of a series of characters in the output
 2322|      0|	 * buffer */
 2323|      0|	int k;
 2324|      0|	for (k = 0; k < count; k++)
 2325|      0|		if (!putCharacter(characters[k], table, pos, input, output, posMapping,
 2326|      0|					cursorPosition, cursorStatus, mode))
 2327|      0|			return 0;
 2328|      0|	return 1;
 2329|      0|}
 2330|       |
 2331|       |// state at the beginning of the current word, used for back-tracking and also for the
 2332|       |// nocont and compbrl rules
 2333|       |typedef struct {
 2334|       |	int inPos;			// begin position of the current word in the input
 2335|       |	int outPos;			// begin position of the current word in the output
 2336|       |	int emphasisInPos;	// position of the next character in the input for which to insert
 2337|       |						// emphasis marks
 2338|       |} LastWord;
 2339|       |
 2340|       |static int
 2341|       |doCompbrl(const TranslationTableHeader *table, int *pos, const InString *input,
 2342|       |		OutString *output, int *posMapping, EmphasisInfo *emphasisBuffer,
 2343|       |		const TranslationTableRule **transRule, int *cursorPosition, int *cursorStatus,
 2344|      0|		const LastWord *lastWord, int *insertEmphasesFrom, int mode) {
 2345|      0|	/* Handle strings containing substrings defined by the compbrl opcode */
 2346|      0|	int stringStart, stringEnd;
 2347|      0|	if (checkCharAttr(input->chars[*pos], CTC_Space, table)) return 1;
 2348|      0|	if (lastWord->outPos) {
 2349|      0|		*pos = lastWord->inPos;
 2350|      0|		output->length = lastWord->outPos;
 2351|      0|	} else {
 2352|      0|		*pos = 0;
 2353|      0|		output->length = 0;
 2354|      0|	}
 2355|      0|	*insertEmphasesFrom = lastWord->emphasisInPos;
 2356|      0|	for (stringStart = *pos; stringStart >= 0; stringStart--)
 2357|      0|		if (checkCharAttr(input->chars[stringStart], CTC_Space, table)) break;
 2358|      0|	stringStart++;
 2359|      0|	for (stringEnd = *pos; stringEnd < input->length; stringEnd++)
 2360|      0|		if (checkCharAttr(input->chars[stringEnd], CTC_Space, table)) break;
 2361|      0|	return doCompTrans(stringStart, stringEnd, table, pos, input, output, posMapping,
 2362|      0|			emphasisBuffer, transRule, cursorPosition, cursorStatus, mode);
 2363|      0|}
 2364|       |
 2365|       |static int
 2366|       |doCompTrans(int start, int end, const TranslationTableHeader *table, int *pos,
 2367|       |		const InString *input, OutString *output, int *posMapping,
 2368|       |		EmphasisInfo *emphasisBuffer, const TranslationTableRule **transRule,
 2369|      0|		int *cursorPosition, int *cursorStatus, int mode) {
 2370|      0|	const TranslationTableRule *indicRule;
 2371|      0|	int k;
 2372|      0|	int haveEndsegment = 0;
 2373|      0|	if (*cursorStatus != 2 && brailleIndicatorDefined(table->begComp, table, &indicRule))
 2374|      0|		if (!for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, *pos,
 2375|      0|					input, output, posMapping, cursorPosition, cursorStatus))
 2376|      0|			return 0;
 2377|      0|	for (k = start; k < end; k++) {
 2378|      0|		TranslationTableOffset compdots = 0;
 2379|      0|		/* HACK: computer braille is one-to-one so it
 2380|      0|		 * can't have any emphasis indicators.
 2381|      0|		 * A better solution is to treat computer braille as its own mode. */
 2382|      0|		emphasisBuffer[k] = (EmphasisInfo){ 0 };
 2383|      0|		if (input->chars[k] == LOU_ENDSEGMENT) {
 2384|      0|			haveEndsegment = 1;
 2385|      0|			continue;
 2386|      0|		}
 2387|      0|		*pos = k;
 2388|      0|		compdots = getChar(input->chars[k], table)->compRule;
 2389|      0|		if (compdots != 0) {
 2390|      0|			*transRule = (TranslationTableRule *)&table->ruleArea[compdots];
 2391|      0|			if (!for_updatePositions(&(*transRule)->charsdots[(*transRule)->charslen],
 2392|      0|						(*transRule)->charslen, (*transRule)->dotslen, 0, *pos, input,
 2393|      0|						output, posMapping, cursorPosition, cursorStatus))
 2394|      0|				return 0;
 2395|      0|		} else if (!putCharacter(input->chars[k], table, *pos, input, output, posMapping,
 2396|      0|						   cursorPosition, cursorStatus, mode))
 2397|      0|			return 0;
 2398|      0|	}
 2399|      0|	if (*cursorStatus != 2 && brailleIndicatorDefined(table->endComp, table, &indicRule))
 2400|      0|		if (!for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, *pos,
 2401|      0|					input, output, posMapping, cursorPosition, cursorStatus))
 2402|      0|			return 0;
 2403|      0|	*pos = end;
 2404|      0|	if (haveEndsegment) {
 2405|      0|		widechar endSegment = LOU_ENDSEGMENT;
 2406|      0|		if (!for_updatePositions(&endSegment, 0, 1, 0, *pos, input, output, posMapping,
 2407|      0|					cursorPosition, cursorStatus))
 2408|      0|			return 0;
 2409|      0|	}
 2410|      0|	return 1;
 2411|      0|}
 2412|       |
 2413|       |static int
 2414|       |doNocont(const TranslationTableHeader *table, int *pos, OutString *output, int mode,
 2415|       |		const InString *input, const LastWord *lastWord, int *dontContract,
 2416|      0|		int *insertEmphasesFrom) {
 2417|      0|	/* Handle strings containing substrings defined by the nocont opcode */
 2418|      0|	if (checkCharAttr(input->chars[*pos], CTC_Space, table) || *dontContract ||
 2419|      0|			(mode & noContractions))
 2420|      0|		return 1;
 2421|      0|	if (lastWord->outPos) {
 2422|      0|		*pos = lastWord->inPos;
 2423|      0|		output->length = lastWord->outPos;
 2424|      0|	} else {
 2425|      0|		*pos = 0;
 2426|      0|		output->length = 0;
 2427|      0|	}
 2428|      0|	*insertEmphasesFrom = lastWord->emphasisInPos;
 2429|      0|	*dontContract = 1;
 2430|      0|	return 1;
 2431|      0|}
 2432|       |
 2433|       |static int
 2434|       |markSyllables(
 2435|      0|		const TranslationTableHeader *table, const InString *input, formtype *typebuf) {
 2436|      0|	int pos;
 2437|      0|	int k;
 2438|      0|	int currentMark = 0;
 2439|      0|	int const syllable_marks[] = { SYLLABLE_MARKER_1, SYLLABLE_MARKER_2 };
 2440|      0|	int syllable_mark_selector = 0;
 2441|      0|	const TranslationTableRule *transRule;
 2442|      0|	int transOpcode;
 2443|      0|	int transCharslen;
 2444|      0|
 2445|      0|	if (typebuf == NULL || !table->syllables) return 1;
 2446|      0|	pos = 0;
 2447|      0|	while (pos < input->length) { /* the main multipass translation loop */
 2448|      0|		int length = input->length - pos;
 2449|      0|		int tryThis = 0;
 2450|      0|		while (tryThis < 3) {
 2451|      0|			TranslationTableOffset ruleOffset = 0;
 2452|      0|			switch (tryThis) {
 2453|      0|			case 0:
 2454|      0|				if (!(length >= 2)) break;
 2455|      0|				// memory overflow when pos == input->length - 1
 2456|      0|				ruleOffset =
 2457|      0|						table->forRules[_lou_stringHash(&input->chars[pos], 1, table)];
 2458|      0|				break;
 2459|      0|			case 1:
 2460|      0|				if (!(length >= 1)) break;
 2461|      0|				length = 1;
 2462|      0|				ruleOffset = getChar(input->chars[pos], table)->otherRules;
 2463|      0|				break;
 2464|      0|			case 2: /* No rule found */
 2465|      0|				transOpcode = CTO_Always;
 2466|      0|				ruleOffset = 0;
 2467|      0|				break;
 2468|      0|			}
 2469|      0|			while (ruleOffset) {
 2470|      0|				transRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];
 2471|      0|				transOpcode = transRule->opcode;
 2472|      0|				transCharslen = transRule->charslen;
 2473|      0|				if (tryThis == 1 ||
 2474|      0|						(transCharslen <= length &&
 2475|      0|								compareChars(&transRule->charsdots[0], &input->chars[pos],
 2476|      0|										transCharslen, table))) {
 2477|      0|					if (transOpcode == CTO_Syllable) {
 2478|      0|						tryThis = 4;
 2479|      0|						break;
 2480|      0|					}
 2481|      0|				}
 2482|      0|				ruleOffset = transRule->charsnext;
 2483|      0|			}
 2484|      0|			tryThis++;
 2485|      0|		}
 2486|      0|		switch (transOpcode) {
 2487|      0|		case CTO_Always:
 2488|      0|			if (pos >= input->length) return 0;
 2489|      0|			typebuf[pos++] |= currentMark;
 2490|      0|			break;
 2491|      0|		case CTO_Syllable:
 2492|      0|			/* cycle between SYLLABLE_MARKER_1 and SYLLABLE_MARKER_2 so
 2493|      0|			 * we can distinguinsh two consequtive syllables */
 2494|      0|			currentMark = syllable_marks[syllable_mark_selector];
 2495|      0|			syllable_mark_selector = (syllable_mark_selector + 1) % 2;
 2496|      0|
 2497|      0|			if ((pos + transCharslen) > input->length) return 0;
 2498|      0|			for (k = 0; k < transCharslen; k++) typebuf[pos++] |= currentMark;
 2499|      0|			break;
 2500|      0|		default:
 2501|      0|			break;
 2502|      0|		}
 2503|      0|	}
 2504|      0|	return 1;
 2505|      0|}
 2506|       |
 2507|       |static int
 2508|       |resetsEmphMode(
 2509|      0|		widechar c, const TranslationTableHeader *table, const EmphasisClass *emphClass) {
 2510|      0|	/* Whether a character cancels word emphasis mode or not. */
 2511|      0|	if (emphClass->mode) {
 2512|      0|		const TranslationTableCharacter *chardef = getChar(c, table);
 2513|      0|		/* the base character of a character belonging to a mode can never cancel the mode
 2514|      0|		 */
 2515|      0|		if (chardef->attributes & emphClass->mode)
 2516|      0|			return 0;
 2517|      0|		else {
 2518|      0|			const TranslationTableCharacter *ch = chardef;
 2519|      0|			if (ch->basechar)
 2520|      0|				ch = (TranslationTableCharacter *)&table->ruleArea[ch->basechar];
 2521|      0|			while (ch->linked) {
 2522|      0|				ch = (TranslationTableCharacter *)&table->ruleArea[ch->linked];
 2523|      0|				if ((ch->mode & chardef->mode) == chardef->mode &&
 2524|      0|						ch->attributes & emphClass->mode) {
 2525|      0|					return 0;
 2526|      0|				}
 2527|      0|			}
 2528|      0|		}
 2529|      0|		if (emphClass->mode == CTC_UpperCase) {
 2530|      0|			/* characters that are not letter and not capsmodechars cancel capsword mode
 2531|      0|			 */
 2532|      0|			return !checkCharAttr(c, CTC_Letter | CTC_CapsMode, table);
 2533|      0|		} else if (emphClass->mode == CTC_Digit) {
 2534|      0|			/* characters that are not digit or litdigit or numericmodechars cancel
 2535|      0|			 * numeric mode */
 2536|      0|			return !checkCharAttr(c,
 2537|      0|					CTC_Digit | CTC_LitDigit | CTC_NumericMode | CTC_MidEndNumericMode,
 2538|      0|					table);
 2539|      0|		} else {
 2540|      0|			/* characters that are not letter cancel other word modes */
 2541|      0|			return !checkCharAttr(c, CTC_Letter, table);
 2542|      0|		}
 2543|      0|	} else {
 2544|      0|		if (checkCharAttr(c, CTC_Letter, table)) /* a letter never cancels emphasis */
 2545|      0|			return 0;
 2546|      0|		const widechar *emphmodechars = table->emphModeChars[emphClass->rule];
 2547|      0|		/* by default (if emphmodechars is not declared) only space cancels emphasis */
 2548|      0|		if (!emphmodechars[0]) return checkCharAttr(c, CTC_Space, table);
 2549|      0|		for (int k = 0; emphmodechars[k]; k++)
 2550|      0|			if (c == emphmodechars[k]) return 0;
 2551|      0|		return 1;
 2552|      0|	}
 2553|      0|}
 2554|       |
 2555|       |static int
 2556|       |isEmphasizable(
 2557|      0|		widechar c, const TranslationTableHeader *table, const EmphasisClass *emphClass) {
 2558|      0|	/* Whether emphasis is indicated on a character or not. */
 2559|      0|	if (emphClass->mode) {
 2560|      0|		/* a character is emphasizable if it belongs to the mode or if it has the same
 2561|      0|		 * base as a character that belongs to the mode */
 2562|      0|		const TranslationTableCharacter *chardef = getChar(c, table);
 2563|      0|		if (chardef->basechar)
 2564|      0|			chardef = (TranslationTableCharacter *)&table->ruleArea[chardef->basechar];
 2565|      0|		if (chardef->attributes & emphClass->mode) return 1;
 2566|      0|		while (chardef->linked) {
 2567|      0|			chardef = (TranslationTableCharacter *)&table->ruleArea[chardef->linked];
 2568|      0|			if (chardef->attributes & emphClass->mode) return 1;
 2569|      0|		}
 2570|      0|		return 0;
 2571|      0|	} else {
 2572|      0|		const widechar *noemphchars = table->noEmphChars[emphClass->rule];
 2573|      0|		/* if noemphchars is not declared emphasis is indicated on all characters except
 2574|      0|		 * spaces */
 2575|      0|		if (!noemphchars[0]) return !checkCharAttr(c, CTC_Space, table);
 2576|      0|		for (int k = 0; noemphchars[k]; k++)
 2577|      0|			if (c == noemphchars[k]) return 0;
 2578|      0|		return 1;
 2579|      0|	}
 2580|      0|}
 2581|       |
 2582|       |static int
 2583|       |isEmphasized(widechar c, const TranslationTableHeader *table,
 2584|      0|		const EmphasisClass *emphClass, formtype typeform) {
 2585|      0|	/* Whether a character is emphasized or not. */
 2586|      0|	if (!isEmphasizable(c, table, emphClass)) return 0;
 2587|      0|	if (emphClass->mode)
 2588|      0|		return checkCharAttr(c, emphClass->mode, table);
 2589|      0|	else
 2590|      0|		return typeform & emphClass->typeform;
 2591|      0|}
 2592|       |
 2593|       |static int
 2594|       |isEmphSpace(
 2595|      0|		widechar c, const TranslationTableHeader *table, const EmphasisClass *emphClass) {
 2596|      0|	/* For determining word boundaries. */
 2597|      0|	/* Note that this is not the only function that is used for this purpose. In
 2598|      0|	 * resolveEmphasisWords the beginning and end of words are further refined based on
 2599|      0|	 * the isEmphasizable function. */
 2600|      0|	const int word_enabled = table->emphRules[emphClass->rule][begWordOffset];
 2601|      0|	if (emphClass->mode == CTC_UpperCase) {
 2602|      0|		/* The old behavior was that words are determined by spaces. However for some
 2603|      0|		 * tables it is a requirement that words are determined based on letters and
 2604|      0|		 * capsmodechars. While the latter probably makes most sense, we don't want to
 2605|      0|		 * break the old behavior because there is no easy way to achieve it using
 2606|      0|		 * table rules. A good middle ground is to let the behavior depend on the
 2607|      0|		 * presence of a capsmodechars rule. */
 2608|      0|		if (!(word_enabled && table->hasCapsModeChars))
 2609|      0|			return checkCharAttr(c, CTC_Space, table);
 2610|      0|	}
 2611|      0|	return !isEmphasizable(c, table, emphClass) &&
 2612|      0|			(!word_enabled || resetsEmphMode(c, table, emphClass));
 2613|      0|}
 2614|       |
 2615|       |static void
 2616|       |resolveEmphasisBeginEnd(EmphasisInfo *buffer, const EmphasisClass *class,
 2617|       |		const TranslationTableHeader *table, const InString *input,
 2618|      0|		const formtype *typebuf, const unsigned int *wordBuffer) {
 2619|      0|	/* mark emphasized (capitalized) sections, i.e. sections that */
 2620|      0|	/* - start with an emphasized (uppercase) character, */
 2621|      0|	/* - extend as long as no unemphasized (lowercase) character is encountered, and */
 2622|      0|	/* - do not end with a word that contains no emphasized (uppercase) characters */
 2623|      0|	/* in addition, if phrase rules are present, sections are split up as needed so that
 2624|      0|	 * they do not end in the middle of a word */
 2625|      0|
 2626|      0|	int last_space = -1;  // position of the last encountered space
 2627|      0|	int emph_start = -1;  // position of the first emphasized (uppercase) character after
 2628|      0|						  // which no unemphasized (lowercase) character was encountered
 2629|      0|	int last_word = -1;	  // position of the first space following the last encountered
 2630|      0|						  // character if that character was emphasized (uppercase)
 2631|      0|	int emph = 0;		  // whether or not the last encountered character was emphasized
 2632|      0|						  // (uppercase) and happened in the current word
 2633|      0|	int phrase_enabled = table->emphRules[class->rule][begPhraseOffset];
 2634|      0|
 2635|      0|	for (int i = 0; i < input->length; i++) {
 2636|      0|		int isSpace = !(wordBuffer[i] & WORD_CHAR);
 2637|      0|		if (isSpace) {
 2638|      0|			/* character is a space */
 2639|      0|			last_space = i;
 2640|      0|			if (emph) {
 2641|      0|				last_word = i;
 2642|      0|				emph = 0;
 2643|      0|			}
 2644|      0|		}
 2645|      0|		/* if character is an emphasized (uppercase) character, emphasis mode begins or
 2646|      0|		 * continues */
 2647|      0|		if (!isSpace && isEmphasized(input->chars[i], table, class, typebuf[i])) {
 2648|      0|			if (emph_start < 0) emph_start = i;
 2649|      0|			emph = 1;
 2650|      0|		} else {
 2651|      0|			/* else if emphasis mode has begun, it should continue if there are no
 2652|      0|			 * unemphasized (lowercase) characters before the next emphasized (uppercase)
 2653|      0|			 * character */
 2654|      0|			/* characters that cancel emphasis mode are handled later in
 2655|      0|			 * resolveEmphasisResets (note that letters that are neither uppercase nor
 2656|      0|			 * lowercase do not cancel caps mode) */
 2657|      0|			if (!isSpace && isEmphasizable(input->chars[i], table, class)) {
 2658|      0|				if (emph_start >= 0) {
 2659|      0|					buffer[emph_start].begin |= class->value;
 2660|      0|					if (emph) {
 2661|      0|						/* a passage can not end on a word without emphasized (uppercase)
 2662|      0|						 * characters, so if emphasis did not start inside the current
 2663|      0|						 * word, end it after the last word that contained an emphasized
 2664|      0|						 * (uppercase) character, and start over from the beginning of the
 2665|      0|						 * current word */
 2666|      0|						if (phrase_enabled && emph_start < last_space) {
 2667|      0|							buffer[last_word].end |= class->value;
 2668|      0|							emph_start = -1;
 2669|      0|							last_word = -1;
 2670|      0|							emph = 0;
 2671|      0|							i = last_space;
 2672|      0|							continue;
 2673|      0|						} else
 2674|      0|							/* don't split into two sections if no phrase rules are
 2675|      0|							 * present or emphasis started inside the current word */
 2676|      0|							buffer[i].end |= class->value;
 2677|      0|					} else
 2678|      0|						/* current word had no emphasis yet */
 2679|      0|						buffer[last_word].end |= class->value;
 2680|      0|					emph_start = -1;
 2681|      0|					last_word = -1;
 2682|      0|					emph = 0;
 2683|      0|				}
 2684|      0|			}
 2685|      0|		}
 2686|      0|	}
 2687|      0|
 2688|      0|	/* clean up input->length */
 2689|      0|	if (emph_start >= 0) {
 2690|      0|		buffer[emph_start].begin |= class->value;
 2691|      0|		if (emph)
 2692|      0|			buffer[input->length].end |= class->value;
 2693|      0|		else
 2694|      0|			buffer[last_word].end |= class->value;
 2695|      0|	}
 2696|      0|}
 2697|       |
 2698|       |static void
 2699|       |resolveEmphasisWords(EmphasisInfo *buffer, const EmphasisClass *class,
 2700|       |		const TranslationTableHeader *table, const InString *input,
 2701|      0|		unsigned int *wordBuffer) {
 2702|      0|	int in_word = 0, in_emp = 0;
 2703|      0|	int word_start = -1;  // start position of the current emphasized word section
 2704|      0|	int char_cnt = 0;  // number of emphasizable characters within the current emphasized
 2705|      0|					   // word section
 2706|      0|	int last_char = -1;	 // position of the last emphasizable character
 2707|      0|	const TranslationTableOffset *emphRule = table->emphRules[class->rule];
 2708|      0|	int letter_defined = emphRule[letterOffset];
 2709|      0|	int endphraseafter_defined = emphRule[begPhraseOffset] &&
 2710|      0|			(emphRule[endPhraseAfterOffset] || emphRule[endOffset]);
 2711|      0|
 2712|      0|	for (int i = 0; i < input->length; i++) {
 2713|      0|
 2714|      0|		/* check if at beginning of emphasis */
 2715|      0|		if (!in_emp)
 2716|      0|			if (buffer[i].begin & class->value) {
 2717|      0|				in_emp = 1;
 2718|      0|				buffer[i].begin &= ~class->value;
 2719|      0|
 2720|      0|				/* emphasis started inside word (and is therefore not a whole word) */
 2721|      0|				if (in_word) word_start = i;
 2722|      0|
 2723|      0|				/* emphasis started on space */
 2724|      0|				if (!(wordBuffer[i] & WORD_CHAR)) word_start = -1;
 2725|      0|			}
 2726|      0|
 2727|      0|		/* check if at end of emphasis */
 2728|      0|		if (in_emp)
 2729|      0|			if (buffer[i].end & class->value) {
 2730|      0|				in_emp = 0;
 2731|      0|				buffer[i].end &= ~class->value;
 2732|      0|				if (in_word && word_start >= 0) {
 2733|      0|					/* if word is one symbol, turn it into a symbol (unless emphletter is
 2734|      0|					 * not defined) */
 2735|      0|					if (letter_defined && char_cnt == 1)
 2736|      0|						buffer[word_start].symbol |= class->value;
 2737|      0|					else {
 2738|      0|						/* else mark the word start point and, if emphasis ended inside a
 2739|      0|						 * word, also mark the end point */
 2740|      0|						buffer[word_start].word |= class->value;
 2741|      0|						if (wordBuffer[i] & WORD_CHAR) {
 2742|      0|							buffer[i].end |= class->value;
 2743|      0|							buffer[i].word |= class->value;
 2744|      0|						}
 2745|      0|					}
 2746|      0|				}
 2747|      0|			}
 2748|      0|
 2749|      0|		/* check if at beginning of word (first character that is not a space) */
 2750|      0|		if (!in_word)
 2751|      0|			if (wordBuffer[i] & WORD_CHAR) {
 2752|      0|				/* check if word started on a character that is not emphasizable */
 2753|      0|				if (isEmphasizable(input->chars[i], table, class)) {
 2754|      0|					in_word = 1;
 2755|      0|					if (in_emp) word_start = i;
 2756|      0|					/* remove WORD_CHAR marks at the end of the previous word */
 2757|      0|					for (int j = last_char + 1; j < i; j++) wordBuffer[j] &= ~WORD_CHAR;
 2758|      0|					/* also delete possible word end point */
 2759|      0|					if (last_char >= 0 && !(buffer[last_char].symbol & class->value)) {
 2760|      0|						if ((buffer[last_char].word & class->value) &&
 2761|      0|								!(buffer[last_char].end & class->value))
 2762|      0|							buffer[last_char].symbol |= class->value;
 2763|      0|						for (int j = last_char; j < i - 1; j++)
 2764|      0|							if (buffer[j + 1].end & class->value) {
 2765|      0|								buffer[j + 1].end &= ~class->value;
 2766|      0|								buffer[j + 1].word &= ~class->value;
 2767|      0|								break;
 2768|      0|							}
 2769|      0|					}
 2770|      0|				}
 2771|      0|			}
 2772|      0|
 2773|      0|		/* check if at end of word (last character that is not a space) */
 2774|      0|		if (in_word)
 2775|      0|			if (!(wordBuffer[i] & WORD_CHAR)) {
 2776|      0|				/* made it through whole word */
 2777|      0|				if (in_emp && word_start >= 0) {
 2778|      0|					/* if word is one symbol, turn it into a symbol (unless emphletter is
 2779|      0|					 * not defined) */
 2780|      0|					if (letter_defined && char_cnt == 1)
 2781|      0|						buffer[word_start].symbol |= class->value;
 2782|      0|					else
 2783|      0|						/* else mark it as a word */
 2784|      0|						buffer[word_start].word |= class->value;
 2785|      0|				}
 2786|      0|				in_word = 0;
 2787|      0|				word_start = -1;
 2788|      0|			}
 2789|      0|
 2790|      0|		/* count characters within the current emphasized word (section) that are
 2791|      0|		 * emphasizable */
 2792|      0|		if (i == word_start) {
 2793|      0|			last_char = i;
 2794|      0|			char_cnt = 1;
 2795|      0|		} else if (in_word &&
 2796|      0|				(endphraseafter_defined /* hack to achieve old behavior of endemphphrase
 2797|      0|										 * after: if the last word of the passage ends
 2798|      0|										 * with unemphasizable characters, the indicator
 2799|      0|										 * is inserted after them  */
 2800|      0|						|| isEmphasizable(input->chars[i], table, class))) {
 2801|      0|			last_char = i;
 2802|      0|			if (in_emp) char_cnt++;
 2803|      0|		}
 2804|      0|	}
 2805|      0|
 2806|      0|	/* clean up end */
 2807|      0|	if (in_emp) {
 2808|      0|		buffer[input->length].end &= ~class->value;
 2809|      0|
 2810|      0|		if (in_word)
 2811|      0|			if (word_start >= 0) {
 2812|      0|				/* if word is one symbol, turn it into a symbol (unless emphletter is not
 2813|      0|				 * defined) */
 2814|      0|				if (letter_defined && char_cnt == 1)
 2815|      0|					buffer[word_start].symbol |= class->value;
 2816|      0|				else
 2817|      0|					/* else mark it as a word */
 2818|      0|					buffer[word_start].word |= class->value;
 2819|      0|			}
 2820|      0|	}
 2821|      0|
 2822|      0|	/* remove WORD_CHAR marks at the end of the previous word */
 2823|      0|	for (int j = last_char + 1; j < input->length; j++) wordBuffer[j] &= ~WORD_CHAR;
 2824|      0|	/* also delete possible word end point */
 2825|      0|	if (last_char >= 0 && !(buffer[last_char].symbol & class->value)) {
 2826|      0|		if ((buffer[last_char].word & class->value) &&
 2827|      0|				!(buffer[last_char].end & class->value))
 2828|      0|			buffer[last_char].symbol |= class->value;
 2829|      0|		for (int j = last_char; j < input->length - 1; j++)
 2830|      0|			if (buffer[j + 1].end & class->value) {
 2831|      0|				buffer[j + 1].end &= ~class->value;
 2832|      0|				buffer[j + 1].word &= ~class->value;
 2833|      0|				break;
 2834|      0|			}
 2835|      0|	}
 2836|      0|
 2837|      0|	/* mark whole words */
 2838|      0|	word_start = -1;
 2839|      0|	for (int i = 0; i < input->length; i++) {
 2840|      0|		if (buffer[i].symbol & class->value) {
 2841|      0|			if ((i == 0 || !(wordBuffer[i - 1] & WORD_CHAR)) &&
 2842|      0|					(i + 1 == input->length || !(wordBuffer[i + 1] & WORD_CHAR)))
 2843|      0|				wordBuffer[i] |= WORD_WHOLE;
 2844|      0|		} else if (buffer[i].word & class->value) {
 2845|      0|			if (buffer[i].end & class->value) {
 2846|      0|				if (word_start >= 0 && wordBuffer[i] & WORD_CHAR)
 2847|      0|					wordBuffer[word_start] &= ~WORD_WHOLE;
 2848|      0|				word_start = -1;
 2849|      0|			} else {
 2850|      0|				if (i == 0 || !(wordBuffer[i - 1] & WORD_CHAR))
 2851|      0|					wordBuffer[i] |= WORD_WHOLE;
 2852|      0|				word_start = i;
 2853|      0|			}
 2854|      0|		}
 2855|      0|	}
 2856|      0|}
 2857|       |
 2858|       |static void
 2859|       |convertToPassage(const int pass_start, const int pass_end, const int word_start,
 2860|       |		EmphasisInfo *buffer, const EmphasisClass *class,
 2861|      0|		const TranslationTableHeader *table, unsigned int *wordBuffer) {
 2862|      0|	int i;
 2863|      0|	const TranslationTableOffset *emphRule = table->emphRules[class->rule];
 2864|      0|	const TranslationTableRule *indicRule;
 2865|      0|
 2866|      0|	for (i = pass_start; i <= pass_end; i++)
 2867|      0|		if (wordBuffer[i] & WORD_WHOLE) {
 2868|      0|			buffer[i].symbol &= ~class->value;
 2869|      0|			buffer[i].word &= ~class->value;
 2870|      0|			wordBuffer[i] &= ~WORD_WHOLE;
 2871|      0|		}
 2872|      0|
 2873|      0|	buffer[pass_start].begin |= class->value;
 2874|      0|	if (brailleIndicatorDefined(emphRule[endOffset], table, &indicRule) ||
 2875|      0|			brailleIndicatorDefined(emphRule[endPhraseAfterOffset], table, &indicRule))
 2876|      0|		buffer[pass_end].end |= class->value;
 2877|      0|	else if (brailleIndicatorDefined(
 2878|      0|					 emphRule[endPhraseBeforeOffset], table, &indicRule)) {
 2879|      0|		/* if the phrase end indicator is the same as the word indicator, mark it as a
 2880|      0|		 * word so that the resolveEmphasisResets code applies */
 2881|      0|		const TranslationTableRule *begwordRule;
 2882|      0|		if (brailleIndicatorDefined(emphRule[begWordOffset], table, &begwordRule) &&
 2883|      0|				indicRule->dotslen == begwordRule->dotslen &&
 2884|      0|				!memcmp(&indicRule->charsdots[0], &begwordRule->charsdots[0],
 2885|      0|						begwordRule->dotslen * CHARSIZE)) {
 2886|      0|			buffer[word_start].word |= class->value;
 2887|      0|			/* a passage has only whole emphasized words */
 2888|      0|			wordBuffer[word_start] |= WORD_WHOLE;
 2889|      0|		} else {
 2890|      0|			buffer[word_start].end |= class->value;
 2891|      0|		}
 2892|      0|	}
 2893|      0|}
 2894|       |
 2895|       |static void
 2896|       |resolveEmphasisPassages(EmphasisInfo *buffer, const EmphasisClass *class,
 2897|       |		const TranslationTableHeader *table, const InString *input,
 2898|      0|		unsigned int *wordBuffer) {
 2899|      0|	const TranslationTableOffset *emphRule = table->emphRules[class->rule];
 2900|      0|	unsigned int word_cnt = 0;
 2901|      0|	int pass_start = -1, pass_end = -1, word_start = -1, in_word = 0, in_pass = 0;
 2902|      0|	int i;
 2903|      0|
 2904|      0|	for (i = 0; i < input->length; i++) {
 2905|      0|		/* check if at beginning of word (first character that is not a space) */
 2906|      0|		if (!in_word)
 2907|      0|			if (wordBuffer[i] & WORD_CHAR) {
 2908|      0|				in_word = 1;
 2909|      0|				/* only whole emphasized words can be part of a passage (in case of caps,
 2910|      0|				 * this also includes words without letters, but only if the next word
 2911|      0|				 * with letters is a whole word) */
 2912|      0|				if (wordBuffer[i] & WORD_WHOLE) {
 2913|      0|					if (!in_pass) {
 2914|      0|						in_pass = 1;
 2915|      0|						pass_start = i;
 2916|      0|						pass_end = -1;
 2917|      0|						word_cnt = 1;
 2918|      0|					} else
 2919|      0|						word_cnt++;
 2920|      0|					word_start = i;
 2921|      0|					continue;
 2922|      0|				} else if (in_pass) {
 2923|      0|					/* it is a passage only if the number of words is greater than or
 2924|      0|					 * equal to the minimum length (lencapsphrase / lenemphphrase) */
 2925|      0|					if (word_cnt >= emphRule[lenPhraseOffset])
 2926|      0|						if (pass_end >= 0) {
 2927|      0|							convertToPassage(pass_start, pass_end, word_start, buffer,
 2928|      0|									class, table, wordBuffer);
 2929|      0|						}
 2930|      0|					in_pass = 0;
 2931|      0|				}
 2932|      0|			}
 2933|      0|
 2934|      0|		/* check if at end of word */
 2935|      0|		if (in_word)
 2936|      0|			if (!(wordBuffer[i] & WORD_CHAR)) {
 2937|      0|				in_word = 0;
 2938|      0|				if (in_pass) pass_end = i;
 2939|      0|			}
 2940|      0|
 2941|      0|		if (in_pass)
 2942|      0|			if ((buffer[i].begin | buffer[i].end | buffer[i].word | buffer[i].symbol) &
 2943|      0|					class->value) {
 2944|      0|				if (word_cnt >= emphRule[lenPhraseOffset])
 2945|      0|					if (pass_end >= 0) {
 2946|      0|						convertToPassage(pass_start, pass_end, word_start, buffer, class,
 2947|      0|								table, wordBuffer);
 2948|      0|					}
 2949|      0|				in_pass = 0;
 2950|      0|			}
 2951|      0|	}
 2952|      0|
 2953|      0|	if (in_pass) {
 2954|      0|		if (word_cnt >= emphRule[lenPhraseOffset]) {
 2955|      0|			if (pass_end >= 0) {
 2956|      0|				if (in_word) {
 2957|      0|					convertToPassage(
 2958|      0|							pass_start, i, word_start, buffer, class, table, wordBuffer);
 2959|      0|				} else {
 2960|      0|					convertToPassage(pass_start, pass_end, word_start, buffer, class,
 2961|      0|							table, wordBuffer);
 2962|      0|				}
 2963|      0|			}
 2964|      0|		}
 2965|      0|	}
 2966|      0|}
 2967|       |
 2968|       |static void
 2969|       |resolveEmphasisSingleSymbols(
 2970|      0|		EmphasisInfo *buffer, const EmphasisClass *class, const InString *input) {
 2971|      0|	int i;
 2972|      0|
 2973|      0|	for (i = 0; i < input->length; i++) {
 2974|      0|		if (buffer[i].begin & class->value)
 2975|      0|			if (buffer[i + 1].end & class->value) {
 2976|      0|				buffer[i].begin &= ~class->value;
 2977|      0|				buffer[i + 1].end &= ~class->value;
 2978|      0|				buffer[i].symbol |= class->value;
 2979|      0|			}
 2980|      0|	}
 2981|      0|}
 2982|       |
 2983|       |static void
 2984|       |resolveEmphasisAllSymbols(EmphasisInfo *buffer, const EmphasisClass *class,
 2985|       |		const TranslationTableHeader *table, formtype *typebuf, const InString *input,
 2986|      0|		unsigned int *wordBuffer) {
 2987|      0|
 2988|      0|	/* Mark every emphasized character individually with symbol if begemphword is not
 2989|      0|	 * defined (assumes resolveEmphasisWords has not been run) */
 2990|      0|	/* Mark every emphasized character individually with symbol if endemphword is not
 2991|      0|	 * defined
 2992|      0|	 * and emphasis ends within a word (assumes resolveEmphasisWords has been run) */
 2993|      0|	/* Note that it is possible that emphletter is also not defined, in which case the
 2994|      0|	 * emphasis will not be marked at all. */
 2995|      0|
 2996|      0|	const TranslationTableOffset *emphRule = table->emphRules[class->rule];
 2997|      0|	const int begword_enabled = emphRule[begWordOffset];
 2998|      0|	const int endword_enabled = emphRule[endWordOffset];
 2999|      0|
 3000|      0|	if (!begword_enabled) {
 3001|      0|		int in_emph = 0;
 3002|      0|		for (int i = 0; i < input->length; i++) {
 3003|      0|			if (in_emph) {
 3004|      0|				if (buffer[i].end & class->value) {
 3005|      0|					in_emph = 0;
 3006|      0|					buffer[i].end &= ~class->value;
 3007|      0|				}
 3008|      0|			} else {
 3009|      0|				if (buffer[i].begin & class->value) {
 3010|      0|					in_emph = 1;
 3011|      0|					buffer[i].begin &= ~class->value;
 3012|      0|				}
 3013|      0|			}
 3014|      0|			if (in_emph) {
 3015|      0|				buffer[i].symbol |= class->value;
 3016|      0|			}
 3017|      0|		}
 3018|      0|	} else if (!endword_enabled) {
 3019|      0|		int in_pass = 0, in_word = 0, word_start = -1;
 3020|      0|		for (int i = 0; i < input->length; i++) {
 3021|      0|			if (in_pass)
 3022|      0|				if (buffer[i].end & class->value || buffer[i].word & class->value)
 3023|      0|					in_pass = 0;
 3024|      0|			if (!in_pass) {
 3025|      0|				if (buffer[i].begin & class->value)
 3026|      0|					in_pass = 1;
 3027|      0|				else {
 3028|      0|					if (!in_word)
 3029|      0|						if (buffer[i].word & class->value) {
 3030|      0|							in_word = 1;
 3031|      0|							word_start = i;
 3032|      0|						}
 3033|      0|					if (in_word) {
 3034|      0|						if (buffer[i].word & class->value &&
 3035|      0|								buffer[i].end & class->value) {
 3036|      0|							in_word = 0;
 3037|      0|							if (begword_enabled && !endword_enabled) {
 3038|      0|								buffer[i].end &= ~class->value;
 3039|      0|								buffer[i].word &= ~class->value;
 3040|      0|								buffer[word_start].word &= ~class->value;
 3041|      0|								for (int j = word_start; j < i; j++)
 3042|      0|									buffer[j].symbol |= class->value;
 3043|      0|							}
 3044|      0|						} else if (!(wordBuffer[i] & WORD_CHAR)) {
 3045|      0|							in_word = 0;
 3046|      0|						}
 3047|      0|					}
 3048|      0|				}
 3049|      0|			}
 3050|      0|		}
 3051|      0|	}
 3052|      0|}
 3053|       |
 3054|       |static void
 3055|       |resolveEmphasisResets(EmphasisInfo *buffer, const EmphasisClass *class,
 3056|       |		const TranslationTableHeader *table, const InString *input,
 3057|      0|		unsigned int *wordBuffer) {
 3058|      0|	int in_word = 0, in_pass = 0, word_start = -1, word_reset = 0, letter_cnt = 0,
 3059|      0|		pass_end = -1;
 3060|      0|	int i;
 3061|      0|	int letter_defined = table->emphRules[class->rule][letterOffset];
 3062|      0|
 3063|      0|	for (i = 0; i < input->length; i++) {
 3064|      0|		if (in_pass) {
 3065|      0|			if (buffer[i].end & class->value)
 3066|      0|				in_pass = 0;
 3067|      0|			else if (buffer[i].word & class->value) {
 3068|      0|				/* the passage is ended with a "endphrase before" indicator and this
 3069|      0|				 * indicator is the same as the "begword" indicator (see convertToPassage)
 3070|      0|				 */
 3071|      0|				in_pass = 0;
 3072|      0|				/* remember this position so that if there is a reset later in this word,
 3073|      0|				 * we can remove this indicator */
 3074|      0|				pass_end = i;
 3075|      0|			}
 3076|      0|		}
 3077|      0|		if (!in_pass) {
 3078|      0|			if (buffer[i].begin & class->value) {
 3079|      0|				in_pass = 1;
 3080|      0|			} else {
 3081|      0|				if (!in_word) {
 3082|      0|					if (buffer[i].word & class->value) {
 3083|      0|						/* deal with case when reset was at beginning of word */
 3084|      0|						if (wordBuffer[i] & WORD_RESET ||
 3085|      0|								resetsEmphMode(input->chars[i], table, class)) {
 3086|      0|							if (!letter_defined)
 3087|      0|								/* if emphletter is not defined, use the word indicator */
 3088|      0|								;
 3089|      0|							else if (pass_end == i)
 3090|      0|								/* also use the word indicator if the reset marks the end
 3091|      0|								 * of a passage */
 3092|      0|								;
 3093|      0|							else {
 3094|      0|								/* use the symbol indicator symbol for the current
 3095|      0|								 * character */
 3096|      0|								buffer[i].symbol |= class->value;
 3097|      0|								/* move the word indicator to the next character or remove
 3098|      0|								 * it altogether if the next character is a space */
 3099|      0|								if (wordBuffer[i + 1] & WORD_CHAR) {
 3100|      0|									buffer[i + 1].word |= class->value;
 3101|      0|									if (wordBuffer[i] & WORD_WHOLE)
 3102|      0|										wordBuffer[i + 1] |= WORD_WHOLE;
 3103|      0|									if (pass_end == i) pass_end++;
 3104|      0|								}
 3105|      0|								buffer[i].word &= ~class->value;
 3106|      0|								wordBuffer[i] &= ~WORD_WHOLE;
 3107|      0|								continue;
 3108|      0|							}
 3109|      0|						}
 3110|      0|
 3111|      0|						in_word = 1;
 3112|      0|						word_start = i;
 3113|      0|						letter_cnt = 0;
 3114|      0|						word_reset = 0;
 3115|      0|					}
 3116|      0|
 3117|      0|					/* it is possible for a character to have been marked as a symbol when
 3118|      0|					 * it should not be one */
 3119|      0|					else if (buffer[i].symbol & class->value) {
 3120|      0|						if (wordBuffer[i] & WORD_RESET ||
 3121|      0|								resetsEmphMode(input->chars[i], table, class))
 3122|      0|							buffer[i].symbol &= ~class->value;
 3123|      0|					}
 3124|      0|				}
 3125|      0|
 3126|      0|				if (in_word) {
 3127|      0|
 3128|      0|					/* at end of word */
 3129|      0|					if (!(wordBuffer[i] & WORD_CHAR) ||
 3130|      0|							(buffer[i].word & class->value &&
 3131|      0|									buffer[i].end & class->value)) {
 3132|      0|						in_word = 0;
 3133|      0|
 3134|      0|						/* check if symbol */
 3135|      0|						if (letter_defined && letter_cnt == 1 && word_start != pass_end) {
 3136|      0|							buffer[word_start].symbol |= class->value;
 3137|      0|							buffer[word_start].word &= ~class->value;
 3138|      0|							wordBuffer[word_start] &= ~WORD_WHOLE;
 3139|      0|							buffer[i].end &= ~class->value;
 3140|      0|							buffer[i].word &= ~class->value;
 3141|      0|						}
 3142|      0|
 3143|      0|						/* if word ended on a reset or last char was a reset, get rid of
 3144|      0|						 * end bits */
 3145|      0|						if (word_reset || wordBuffer[i] & WORD_RESET ||
 3146|      0|								resetsEmphMode(input->chars[i], table, class)) {
 3147|      0|							buffer[i].end &= ~class->value;
 3148|      0|							buffer[i].word &= ~class->value;
 3149|      0|						}
 3150|      0|
 3151|      0|						/* if word ended when it began, get rid of all bits */
 3152|      0|						if (i == word_start) {
 3153|      0|							wordBuffer[word_start] &= ~WORD_WHOLE;
 3154|      0|							buffer[i].end &= ~class->value;
 3155|      0|							buffer[i].word &= ~class->value;
 3156|      0|						}
 3157|      0|					} else {
 3158|      0|						/* hit reset */
 3159|      0|						if (wordBuffer[i] & WORD_RESET ||
 3160|      0|								resetsEmphMode(input->chars[i], table, class)) {
 3161|      0|
 3162|      0|							/* check if symbol is not already resetting */
 3163|      0|							if (letter_defined && letter_cnt == 1 &&
 3164|      0|									word_start != pass_end) {
 3165|      0|								buffer[word_start].symbol |= class->value;
 3166|      0|								buffer[word_start].word &= ~class->value;
 3167|      0|								wordBuffer[word_start] &= ~WORD_WHOLE;
 3168|      0|							}
 3169|      0|
 3170|      0|							/* if reset is a letter or emphmodechar, make it the new
 3171|      0|							 * word_start */
 3172|      0|							if (!resetsEmphMode(input->chars[i], table, class)) {
 3173|      0|								if (word_start == pass_end)
 3174|      0|									/* move the word marker that ends the passage to the
 3175|      0|									 * current position */
 3176|      0|									buffer[pass_end].word &= ~class->value;
 3177|      0|								pass_end = -1;
 3178|      0|								word_reset = 0;
 3179|      0|								word_start = i;
 3180|      0|								letter_cnt = 1;
 3181|      0|								buffer[i].word |= class->value;
 3182|      0|							} else
 3183|      0|								word_reset = 1;
 3184|      0|
 3185|      0|							continue;
 3186|      0|						}
 3187|      0|
 3188|      0|						if (word_reset) {
 3189|      0|							if (word_start == pass_end)
 3190|      0|								/* move the word marker that ends the passage to the
 3191|      0|								 * current position */
 3192|      0|								buffer[pass_end].word &= ~class->value;
 3193|      0|							pass_end = -1;
 3194|      0|							word_reset = 0;
 3195|      0|							word_start = i;
 3196|      0|							letter_cnt = 0;
 3197|      0|							buffer[i].word |= class->value;
 3198|      0|						}
 3199|      0|
 3200|      0|						letter_cnt++;
 3201|      0|					}
 3202|      0|				}
 3203|      0|			}
 3204|      0|		}
 3205|      0|	}
 3206|      0|
 3207|      0|	/* clean up end */
 3208|      0|	if (in_word) {
 3209|      0|		/* check if symbol */
 3210|      0|		if (letter_defined && letter_cnt == 1 && word_start != pass_end) {
 3211|      0|			buffer[word_start].symbol |= class->value;
 3212|      0|			buffer[word_start].word &= ~class->value;
 3213|      0|			wordBuffer[word_start] &= ~WORD_WHOLE;
 3214|      0|			buffer[i].end &= ~class->value;
 3215|      0|			buffer[i].word &= ~class->value;
 3216|      0|		}
 3217|      0|
 3218|      0|		if (word_reset) {
 3219|      0|			buffer[i].end &= ~class->value;
 3220|      0|			buffer[i].word &= ~class->value;
 3221|      0|		}
 3222|      0|	}
 3223|      0|}
 3224|       |
 3225|       |static void
 3226|       |markEmphases(const TranslationTableHeader *table, const InString *input,
 3227|      0|		formtype *typebuf, unsigned int *wordBuffer, EmphasisInfo *emphasisBuffer) {
 3228|      0|
 3229|      0|	/* handle capsnocont */
 3230|      0|	if (table->capsNoCont) {
 3231|      0|		int caps_cnt = 0;  // number of consecutive characters ending with the current
 3232|      0|						   // that are uppercase letters
 3233|      0|		for (int i = 0; i < input->length; i++) {
 3234|      0|			if (checkCharAttr(input->chars[i], CTC_UpperCase, table)) {
 3235|      0|				/* mark two or more consecutive caps with nocont */
 3236|      0|				caps_cnt++;
 3237|      0|				if (caps_cnt >= 2) {
 3238|      0|					typebuf[i] |= no_contract;
 3239|      0|					/* also mark the previous one */
 3240|      0|					if (caps_cnt == 2) typebuf[i - 1] |= no_contract;
 3241|      0|				}
 3242|      0|			} else {
 3243|      0|				caps_cnt = 0;
 3244|      0|			}
 3245|      0|		}
 3246|      0|	}
 3247|      0|
 3248|      0|	for (int j = 0; j < MAX_EMPH_CLASSES + MAX_MODES; j++) {
 3249|      0|		const EmphasisClass *emphClass = j < MAX_EMPH_CLASSES
 3250|      0|				? &table->emphClasses[j]
 3251|      0|				: &table->modes[j - MAX_EMPH_CLASSES];
 3252|      0|		if (!emphClass->value) continue;
 3253|      0|		const TranslationTableOffset *emphRule = table->emphRules[emphClass->rule];
 3254|      0|
 3255|      0|		/* clear out previous word markings and mark non-space characters in word buffer
 3256|      0|		 */
 3257|      0|		for (int i = 0; i < input->length; i++) {
 3258|      0|			if (isEmphSpace(input->chars[i], table, emphClass))
 3259|      0|				wordBuffer[i] &= ~WORD_CHAR;
 3260|      0|			else
 3261|      0|				wordBuffer[i] |= WORD_CHAR;
 3262|      0|			wordBuffer[i] &= ~WORD_WHOLE;
 3263|      0|		}
 3264|      0|
 3265|      0|		/* mark beginning and end points */
 3266|      0|		resolveEmphasisBeginEnd(
 3267|      0|				emphasisBuffer, emphClass, table, input, typebuf, wordBuffer);
 3268|      0|
 3269|      0|		if (emphRule[begWordOffset]) {
 3270|      0|			/* mark word beginning and end points, whole words, and symbols (single
 3271|      0|			 * characters) */
 3272|      0|			resolveEmphasisWords(emphasisBuffer, emphClass, table, input, wordBuffer);
 3273|      0|			if (emphRule[lenPhraseOffset])
 3274|      0|				/* remove markings of words that form a passage, and mark the begin and
 3275|      0|				 * end of these passages instead */
 3276|      0|				resolveEmphasisPassages(
 3277|      0|						emphasisBuffer, emphClass, table, input, wordBuffer);
 3278|      0|			/* mark where emphasis in a word needs to be retriggered after it was reset */
 3279|      0|			resolveEmphasisResets(emphasisBuffer, emphClass, table, input, wordBuffer);
 3280|      0|			if (!emphRule[endWordOffset])
 3281|      0|				/* if endword is not defined and emphasis ends within a word, mark every
 3282|      0|				 * emphasised character individually as symbol */
 3283|      0|				resolveEmphasisAllSymbols(
 3284|      0|						emphasisBuffer, emphClass, table, typebuf, input, wordBuffer);
 3285|      0|		} else if (emphRule[letterOffset]) {
 3286|      0|			if (emphRule[begOffset])
 3287|      0|				resolveEmphasisSingleSymbols(emphasisBuffer, emphClass, input);
 3288|      0|			else
 3289|      0|				resolveEmphasisAllSymbols(
 3290|      0|						emphasisBuffer, emphClass, table, typebuf, input, wordBuffer);
 3291|      0|		}
 3292|      0|		if (emphClass->mode) {
 3293|      0|			/* only mark if actually a capital letter (don't mark spaces or punctuation).
 3294|      0|			 */
 3295|      0|			for (int i = 0; i < input->length; i++) {
 3296|      0|				if (emphasisBuffer[i].symbol & emphClass->value) {
 3297|      0|					if (emphClass->mode == CTC_UpperCase) {
 3298|      0|						if (!(typebuf[i] & CAPSEMPH))
 3299|      0|							emphasisBuffer[i].symbol &= ~emphClass->value;
 3300|      0|					} else {
 3301|      0|						if (!checkCharAttr(input->chars[i], emphClass->mode, table))
 3302|      0|							emphasisBuffer[i].symbol &= ~emphClass->value;
 3303|      0|					}
 3304|      0|				}
 3305|      0|			}
 3306|      0|		}
 3307|      0|	}
 3308|      0|}
 3309|       |
 3310|       |static void
 3311|       |insertEmphasisSymbol(const EmphasisInfo *buffer, formtype *typebuf, const int at,
 3312|       |		const EmphasisClass *class, const TranslationTableHeader *table, int pos,
 3313|       |		const InString *input, OutString *output, int *posMapping, int *cursorPosition,
 3314|      0|		int *cursorStatus) {
 3315|      0|	if (buffer[at].symbol & class->value) {
 3316|      0|		const TranslationTableRule *indicRule;
 3317|      0|		if (brailleIndicatorDefined(
 3318|      0|					table->emphRules[class->rule][letterOffset], table, &indicRule))
 3319|      0|			for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,
 3320|      0|					input, output, posMapping, cursorPosition, cursorStatus);
 3321|      0|	}
 3322|      0|}
 3323|       |
 3324|       |static void
 3325|       |insertEmphasisBegin(const EmphasisInfo *buffer, const int at, const EmphasisClass *class,
 3326|       |		const TranslationTableHeader *table, int pos, const InString *input,
 3327|      0|		OutString *output, int *posMapping, int *cursorPosition, int *cursorStatus) {
 3328|      0|	const TranslationTableOffset *emphRule = table->emphRules[class->rule];
 3329|      0|	const TranslationTableRule *indicRule;
 3330|      0|	if (buffer[at].begin & class->value) {
 3331|      0|		if (brailleIndicatorDefined(emphRule[begPhraseOffset], table, &indicRule))
 3332|      0|			for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,
 3333|      0|					input, output, posMapping, cursorPosition, cursorStatus);
 3334|      0|		else if (brailleIndicatorDefined(emphRule[begOffset], table, &indicRule))
 3335|      0|			for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,
 3336|      0|					input, output, posMapping, cursorPosition, cursorStatus);
 3337|      0|	}
 3338|      0|
 3339|      0|	if (buffer[at].word & class->value
 3340|      0|			// && !(buffer[at].begin & class->value)
 3341|      0|			&& !(buffer[at].end & class->value)) {
 3342|      0|		if (brailleIndicatorDefined(emphRule[begWordOffset], table, &indicRule))
 3343|      0|			for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,
 3344|      0|					input, output, posMapping, cursorPosition, cursorStatus);
 3345|      0|	}
 3346|      0|}
 3347|       |
 3348|       |static void
 3349|       |insertEmphasisEnd(const EmphasisInfo *buffer, const int at, const EmphasisClass *class,
 3350|       |		const TranslationTableHeader *table, int pos, const InString *input,
 3351|      0|		OutString *output, int *posMapping, int *cursorPosition, int *cursorStatus) {
 3352|      0|	const TranslationTableOffset *emphRule = table->emphRules[class->rule];
 3353|      0|	if (buffer[at].end & class->value) {
 3354|      0|		const TranslationTableRule *indicRule;
 3355|      0|		if (buffer[at].word & class->value) {
 3356|      0|			if (brailleIndicatorDefined(emphRule[endWordOffset], table, &indicRule))
 3357|      0|				for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, -1,
 3358|      0|						pos, input, output, posMapping, cursorPosition, cursorStatus);
 3359|      0|		} else {
 3360|      0|			if (brailleIndicatorDefined(emphRule[endOffset], table, &indicRule))
 3361|      0|				for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, -1,
 3362|      0|						pos, input, output, posMapping, cursorPosition, cursorStatus);
 3363|      0|			else if (brailleIndicatorDefined(
 3364|      0|							 emphRule[endPhraseAfterOffset], table, &indicRule))
 3365|      0|				for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, -1,
 3366|      0|						pos, input, output, posMapping, cursorPosition, cursorStatus);
 3367|      0|			else if (brailleIndicatorDefined(
 3368|      0|							 emphRule[endPhraseBeforeOffset], table, &indicRule))
 3369|      0|				for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0,
 3370|      0|						pos, input, output, posMapping, cursorPosition, cursorStatus);
 3371|      0|		}
 3372|      0|	}
 3373|      0|}
 3374|       |
 3375|       |static int
 3376|      0|endCount(const EmphasisInfo *buffer, const int at, const EmphasisClass *class) {
 3377|      0|	int i, cnt = 1;
 3378|      0|	if (!(buffer[at].end & class->value)) return 0;
 3379|      0|	for (i = at - 1; i >= 0; i--)
 3380|      0|		if (buffer[i].begin & class->value || buffer[i].word & class->value)
 3381|      0|			break;
 3382|      0|		else
 3383|      0|			cnt++;
 3384|      0|	return cnt;
 3385|      0|}
 3386|       |
 3387|       |static int
 3388|       |beginCount(const EmphasisInfo *buffer, const int at, const EmphasisClass *class,
 3389|      0|		const TranslationTableHeader *table, const InString *input) {
 3390|      0|	if (buffer[at].begin & class->value) {
 3391|      0|		int i, cnt = 1;
 3392|      0|		for (i = at + 1; i < input->length; i++)
 3393|      0|			if (buffer[i].end & class->value)
 3394|      0|				break;
 3395|      0|			else
 3396|      0|				cnt++;
 3397|      0|		return cnt;
 3398|      0|	} else if (buffer[at].word & class->value) {
 3399|      0|		int i, cnt = 1;
 3400|      0|		for (i = at + 1; i < input->length; i++)
 3401|      0|			if (buffer[i].end & class->value)
 3402|      0|				break;
 3403|      0|			else if (checkCharAttr(input->chars[i], CTC_SeqDelimiter, table))
 3404|      0|				break;
 3405|      0|			else if (isEmphSpace(input->chars[i], table, class))
 3406|      0|				break;
 3407|      0|			else
 3408|      0|				cnt++;
 3409|      0|		return cnt;
 3410|      0|	}
 3411|      0|	return 0;
 3412|      0|}
 3413|       |
 3414|       |static void
 3415|       |insertEmphasesAt(int begin, int end, int caps, int other, const int at,
 3416|       |		const TranslationTableHeader *table, int pos, const InString *input,
 3417|       |		OutString *output, int *posMapping, const EmphasisInfo *emphasisBuffer,
 3418|      0|		formtype *typebuf, int *cursorPosition, int *cursorStatus) {
 3419|      0|
 3420|      0|	/* The order of inserting the end symbols must be the reverse
 3421|      0|	 * of the insertions of the begin symbols so that they will
 3422|      0|	 * nest properly when multiple emphases start and end at
 3423|      0|	 * the same place */
 3424|      0|	// TODO: ordering with partial word
 3425|      0|
 3426|      0|	if (end && caps)
 3427|      0|		for (int i = 0; i < MAX_MODES; i++) {
 3428|      0|			const EmphasisClass *emphClass = &table->modes[i];
 3429|      0|			if (!emphClass->value) continue;
 3430|      0|			if ((emphasisBuffer[at].begin | emphasisBuffer[at].end |
 3431|      0|						emphasisBuffer[at].word | emphasisBuffer[at].symbol) &
 3432|      0|					emphClass->value)
 3433|      0|				insertEmphasisEnd(emphasisBuffer, at, emphClass, table, pos, input,
 3434|      0|						output, posMapping, cursorPosition, cursorStatus);
 3435|      0|		}
 3436|      0|
 3437|      0|	if (end && other) {
 3438|      0|		int type_counts[MAX_EMPH_CLASSES];
 3439|      0|
 3440|      0|		/* end bits */
 3441|      0|		for (int i = 0; i < MAX_EMPH_CLASSES; i++) {
 3442|      0|			const EmphasisClass *emphClass = &table->emphClasses[i];
 3443|      0|			if (!emphClass->value)
 3444|      0|				type_counts[i] = 0;
 3445|      0|			else
 3446|      0|				type_counts[i] = endCount(emphasisBuffer, at, emphClass);
 3447|      0|		}
 3448|      0|
 3449|      0|		while (1) {
 3450|      0|			int min = -1;
 3451|      0|			for (int i = 0; i < MAX_EMPH_CLASSES; i++)
 3452|      0|				if (type_counts[i] > 0)
 3453|      0|					if (min < 0 || type_counts[i] < type_counts[min]) min = i;
 3454|      0|			if (min < 0) break;
 3455|      0|			type_counts[min] = 0;
 3456|      0|			insertEmphasisEnd(emphasisBuffer, at, &table->emphClasses[min], table, pos,
 3457|      0|					input, output, posMapping, cursorPosition, cursorStatus);
 3458|      0|		}
 3459|      0|	}
 3460|      0|
 3461|      0|	if (begin && other) {
 3462|      0|		int type_counts[MAX_EMPH_CLASSES];
 3463|      0|
 3464|      0|		/* begin and word bits */
 3465|      0|		for (int i = 0; i < MAX_EMPH_CLASSES; i++) {
 3466|      0|			const EmphasisClass *emphClass = &table->emphClasses[i];
 3467|      0|			if (!emphClass->value)
 3468|      0|				type_counts[i] = 0;
 3469|      0|			else
 3470|      0|				type_counts[i] = beginCount(emphasisBuffer, at, emphClass, table, input);
 3471|      0|		}
 3472|      0|
 3473|      0|		while (1) {
 3474|      0|			int max = MAX_EMPH_CLASSES - 1;
 3475|      0|			for (int i = MAX_EMPH_CLASSES - 1; i >= 0; i--)
 3476|      0|				if (type_counts[max] < type_counts[i]) max = i;
 3477|      0|			if (!type_counts[max]) break;
 3478|      0|			type_counts[max] = 0;
 3479|      0|			insertEmphasisBegin(emphasisBuffer, at, &table->emphClasses[max], table, pos,
 3480|      0|					input, output, posMapping, cursorPosition, cursorStatus);
 3481|      0|		}
 3482|      0|
 3483|      0|		/* symbol bits */
 3484|      0|		for (int i = MAX_EMPH_CLASSES - 1; i >= 0; i--)
 3485|      0|			if ((emphasisBuffer[at].begin | emphasisBuffer[at].end |
 3486|      0|						emphasisBuffer[at].word | emphasisBuffer[at].symbol) &
 3487|      0|					table->emphClasses[i].value)
 3488|      0|				insertEmphasisSymbol(emphasisBuffer, typebuf, at, &table->emphClasses[i],
 3489|      0|						table, pos, input, output, posMapping, cursorPosition,
 3490|      0|						cursorStatus);
 3491|      0|	}
 3492|      0|
 3493|      0|	if (begin && caps) {
 3494|      0|
 3495|      0|		/* insert capitalization last so it will be closest to word */
 3496|      0|		/* other mode indicators are inserted so that those who are defined first are
 3497|      0|		 * closest to word */
 3498|      0|		for (int i = MAX_MODES - 1; i >= 0; i--) {
 3499|      0|			const EmphasisClass *emphClass = &table->modes[i];
 3500|      0|			if (!emphClass->value) continue;
 3501|      0|			if ((emphasisBuffer[at].begin | emphasisBuffer[at].end |
 3502|      0|						emphasisBuffer[at].word | emphasisBuffer[at].symbol) &
 3503|      0|					emphClass->value) {
 3504|      0|				insertEmphasisBegin(emphasisBuffer, at, emphClass, table, pos, input,
 3505|      0|						output, posMapping, cursorPosition, cursorStatus);
 3506|      0|				insertEmphasisSymbol(emphasisBuffer, typebuf, at, emphClass, table, pos,
 3507|      0|						input, output, posMapping, cursorPosition, cursorStatus);
 3508|      0|			}
 3509|      0|		}
 3510|      0|	}
 3511|      0|}
 3512|       |
 3513|       |static void
 3514|       |checkNumericMode(const TranslationTableHeader *table, int pos, const InString *input,
 3515|       |		OutString *output, int *posMapping, int *cursorPosition, int *cursorStatus,
 3516|      0|		int *dontContract, int *numericMode) {
 3517|      0|	/* check if numeric mode is active and insert number sign and nocontract sign when
 3518|      0|	 * needed */
 3519|      0|
 3520|      0|	int i;
 3521|      0|	const TranslationTableRule *indicRule;
 3522|      0|	if (!brailleIndicatorDefined(table->numberSign, table, &indicRule)) return;
 3523|      0|
 3524|      0|	/* not in numeric mode */
 3525|      0|	if (!*numericMode) {
 3526|      0|		if (checkCharAttr(input->chars[pos], CTC_Digit | CTC_LitDigit, table)) {
 3527|      0|			*numericMode = 1;
 3528|      0|			/* if the noContractSign is defined disable contraction */
 3529|      0|			if (table->noContractSign) *dontContract = 1;
 3530|      0|			for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,
 3531|      0|					input, output, posMapping, cursorPosition, cursorStatus);
 3532|      0|		} else if (checkCharAttr(input->chars[pos], CTC_NumericMode, table)) {
 3533|      0|			for (i = pos + 1; i < input->length; i++) {
 3534|      0|				if (checkCharAttr(input->chars[i], CTC_Digit | CTC_LitDigit, table)) {
 3535|      0|					*numericMode = 1;
 3536|      0|					for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen,
 3537|      0|							0, pos, input, output, posMapping, cursorPosition,
 3538|      0|							cursorStatus);
 3539|      0|					break;
 3540|      0|				} else if (!checkCharAttr(input->chars[i], CTC_NumericMode, table))
 3541|      0|					break;
 3542|      0|			}
 3543|      0|		}
 3544|      0|	}
 3545|      0|
 3546|      0|	/* in numeric mode */
 3547|      0|	else {
 3548|      0|		if (!checkCharAttr(input->chars[pos],
 3549|      0|					CTC_Digit | CTC_LitDigit | CTC_NumericMode | CTC_MidEndNumericMode,
 3550|      0|					table)) {
 3551|      0|			*numericMode = 0;
 3552|      0|			if (!brailleIndicatorDefined(table->noContractSign, table, &indicRule))
 3553|      0|				*dontContract = 0;
 3554|      0|			if (brailleIndicatorDefined(table->noContractSign, table, &indicRule))
 3555|      0|				if (checkCharAttr(input->chars[pos], CTC_NumericNoContract, table))
 3556|      0|					for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen,
 3557|      0|							0, pos, input, output, posMapping, cursorPosition,
 3558|      0|							cursorStatus);
 3559|      0|		}
 3560|      0|	}
 3561|      0|}
 3562|       |
 3563|       |static int
 3564|       |translateString(const TranslationTableHeader *table, int mode, int currentPass,
 3565|       |		const InString *input, OutString *output, int *posMapping, formtype *typebuf,
 3566|       |		unsigned char *srcSpacing, unsigned char *destSpacing, unsigned int *wordBuffer,
 3567|       |		EmphasisInfo *emphasisBuffer, int haveEmphasis, int *realInlen,
 3568|      0|		int *cursorPosition, int *cursorStatus, int compbrlStart, int compbrlEnd) {
 3569|      0|	int pos;
 3570|      0|	int transOpcode;
 3571|      0|	int prevTransOpcode;
 3572|      0|	const TranslationTableRule *transRule;
 3573|      0|	int transCharslen;
 3574|      0|	int passCharDots;
 3575|      0|	const widechar *passInstructions;
 3576|      0|	int passIC; /* Instruction counter */
 3577|      0|	PassRuleMatch patternMatch;
 3578|      0|	TranslationTableRule *groupingRule;
 3579|      0|	widechar groupingOp;
 3580|      0|	int numericMode;
 3581|      0|	int dontContract;
 3582|      0|	LastWord lastWord;
 3583|      0|	int insertEmphasesFrom;
 3584|      0|	TranslationTableCharacter *curCharDef;
 3585|      0|	int repwordStart;
 3586|      0|	int repwordLength;
 3587|      0|	const InString *origInput = input;
 3588|      0|	/* Main translation routine */
 3589|      0|	int k;
 3590|      0|	translation_direction = 1;
 3591|      0|	markSyllables(table, input, typebuf);
 3592|      0|	numericMode = 0;
 3593|      0|	lastWord = (LastWord){ 0, 0, 0 };
 3594|      0|	dontContract = 0;
 3595|      0|	prevTransOpcode = CTO_None;
 3596|      0|	pos = output->length = 0;
 3597|      0|	int posIncremented = 1;
 3598|      0|	insertEmphasesFrom = 0;
 3599|      0|	_lou_resetPassVariables();
 3600|      0|	if (typebuf && capsletterDefined(table))
 3601|      0|		for (k = 0; k < input->length; k++)
 3602|      0|			if (checkCharAttr(input->chars[k], CTC_UpperCase, table))
 3603|      0|				typebuf[k] |= CAPSEMPH;
 3604|      0|
 3605|      0|	markEmphases(table, input, typebuf, wordBuffer, emphasisBuffer);
 3606|      0|
 3607|      0|	while (pos < input->length) { /* the main translation loop */
 3608|      0|		if (pos >= compbrlStart && pos < compbrlEnd) {
 3609|      0|			int cs = 2;	 // cursor status for this call
 3610|      0|			if (!doCompTrans(pos, compbrlEnd, table, &pos, input, output, posMapping,
 3611|      0|						emphasisBuffer, &transRule, cursorPosition, &cs, mode))
 3612|      0|				goto failure;
 3613|      0|			if (pos > 0 && checkCharAttr(input->chars[pos - 1], CTC_Space, table))
 3614|      0|				lastWord = (LastWord){ pos, output->length, insertEmphasesFrom };
 3615|      0|			continue;
 3616|      0|		}
 3617|      0|		TranslationTableCharacterAttributes beforeAttributes;
 3618|      0|		setBefore(table, pos, input, &beforeAttributes);
 3619|      0|		if (pos >= input->length) break;
 3620|      0|
 3621|      0|		if (!dontContract) dontContract = typebuf[pos] & no_contract;
 3622|      0|		if (typebuf[pos] & no_translate) {
 3623|      0|			if (input->chars[pos] < 32 || input->chars[pos] > 126) goto failure;
 3624|      0|			widechar d = LOU_DOTS;
 3625|      0|			TranslationTableOffset offset = getChar(input->chars[pos], table)->otherRules;
 3626|      0|			while (offset) {
 3627|      0|				const TranslationTableRule *r =
 3628|      0|						(TranslationTableRule *)&table->ruleArea[offset];
 3629|      0|				if (r->opcode >= CTO_Space && r->opcode < CTO_UpLow && r->dotslen == 1) {
 3630|      0|					d = r->charsdots[1];
 3631|      0|					break;
 3632|      0|				}
 3633|      0|				offset = r->charsnext;
 3634|      0|			}
 3635|      0|			if (!for_updatePositions(&d, 1, 1, 0, pos, input, output, posMapping,
 3636|      0|						cursorPosition, cursorStatus))
 3637|      0|				goto failure;
 3638|      0|			pos++;
 3639|      0|			posIncremented = 1;
 3640|      0|			insertEmphasesFrom = pos;
 3641|      0|			continue;
 3642|      0|		}
 3643|      0|		repwordLength = 0;
 3644|      0|		for_selectRule(table, pos, *output, posMapping, mode, input, typebuf,
 3645|      0|				emphasisBuffer, &transOpcode, prevTransOpcode, &transRule, &transCharslen,
 3646|      0|				&passCharDots, &passInstructions, &passIC, &patternMatch, posIncremented,
 3647|      0|				*cursorPosition, &repwordLength, dontContract, compbrlStart, compbrlEnd,
 3648|      0|				beforeAttributes, &curCharDef, &groupingRule, &groupingOp);
 3649|      0|
 3650|      0|		switch (transOpcode) /* Rules that pre-empt context and swap */
 3651|      0|		{
 3652|      0|		case CTO_CompBrl:
 3653|      0|		case CTO_Literal:
 3654|      0|			if (!doCompbrl(table, &pos, input, output, posMapping, emphasisBuffer,
 3655|      0|						&transRule, cursorPosition, cursorStatus, &lastWord,
 3656|      0|						&insertEmphasesFrom, mode))
 3657|      0|				goto failure;
 3658|      0|			continue;
 3659|      0|		default:
 3660|      0|			break;
 3661|      0|		}
 3662|      0|
 3663|      0|		/* Skip repword separator to make caps/emph indicators appear before repword
 3664|      0|		 * indicator */
 3665|      0|		if (repwordLength) pos += transCharslen;
 3666|      0|
 3667|      0|		for (int at = insertEmphasesFrom; at <= pos; at++) {
 3668|      0|			/* insert caps end indicator */
 3669|      0|			insertEmphasesAt(0, 1, 1, 0, at, table, pos, input, output, posMapping,
 3670|      0|					emphasisBuffer, typebuf, cursorPosition, cursorStatus);
 3671|      0|			if (haveEmphasis) {
 3672|      0|				/* insert emphasis end indicator */
 3673|      0|				insertEmphasesAt(0, 1, 0, 1, at, table, pos, input, output, posMapping,
 3674|      0|						emphasisBuffer, typebuf, cursorPosition, cursorStatus);
 3675|      0|				/* insert emphasis start indicator */
 3676|      0|				insertEmphasesAt(1, 0, 0, 1, at, table, pos, input, output, posMapping,
 3677|      0|						emphasisBuffer, typebuf, cursorPosition, cursorStatus);
 3678|      0|			}
 3679|      0|			if (at < pos)
 3680|      0|				insertEmphasesAt(1, 0, 1, 0, at, table, pos, input, output, posMapping,
 3681|      0|						emphasisBuffer, typebuf, cursorPosition, cursorStatus);
 3682|      0|		}
 3683|      0|		insertEmphasesFrom = pos + 1;
 3684|      0|		/* insert grade 1 mode indicator (nocontractsign) before contraction */
 3685|      0|		if (transOpcode == CTO_Contraction) {
 3686|      0|			const TranslationTableRule *indicRule;
 3687|      0|			if (brailleIndicatorDefined(table->noContractSign, table, &indicRule))
 3688|      0|				for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0,
 3689|      0|						pos, input, output, posMapping, cursorPosition, cursorStatus);
 3690|      0|		}
 3691|      0|		/* insert letter sign */
 3692|      0|		if (!insertLetterSign(table, pos, input, output, posMapping, transOpcode,
 3693|      0|					cursorPosition, cursorStatus, beforeAttributes))
 3694|      0|			goto failure;
 3695|      0|		/* insert caps start indicator */
 3696|      0|		insertEmphasesAt(1, 0, 1, 0, pos, table, pos, input, output, posMapping,
 3697|      0|				emphasisBuffer, typebuf, cursorPosition, cursorStatus);
 3698|      0|		/* insert number sign (not if numericmodechars, midnumericmodechars or
 3699|      0|		 * numericnocontchars has been defined) */
 3700|      0|		if (!table->usesNumericMode)
 3701|      0|			if (!insertNumberSign(table, pos, input, output, posMapping, prevTransOpcode,
 3702|      0|						cursorPosition, cursorStatus, beforeAttributes))
 3703|      0|				goto failure;
 3704|      0|		/* insert number sign and number cancel sign (nocontractsign) (only if
 3705|      0|		 * numericmodechars, midnumericmodechars or numericnocontchars has been defined)
 3706|      0|		 */
 3707|      0|		if (table->usesNumericMode)
 3708|      0|			checkNumericMode(table, pos, input, output, posMapping, cursorPosition,
 3709|      0|					cursorStatus, &dontContract, &numericMode);
 3710|      0|
 3711|      0|		if (transOpcode == CTO_Context ||
 3712|      0|				(posIncremented &&
 3713|      0|						findForPassRule(table, pos, currentPass, input, &transOpcode,
 3714|      0|								&transRule, &transCharslen, &passCharDots,
 3715|      0|								&passInstructions, &passIC, &patternMatch, &groupingRule,
 3716|      0|								&groupingOp))) {
 3717|      0|			posIncremented = 1;
 3718|      0|			switch (transOpcode) {
 3719|      0|			case CTO_Context: {
 3720|      0|				const InString *inputBefore = input;
 3721|      0|				int posBefore = pos;
 3722|      0|				if (appliedRules != NULL && appliedRulesCount < maxAppliedRules)
 3723|      0|					appliedRules[appliedRulesCount++] = transRule;
 3724|      0|				if (!passDoAction(table, &input, output, posMapping, transOpcode,
 3725|      0|							&transRule, passCharDots, passInstructions, passIC, &pos,
 3726|      0|							patternMatch, cursorPosition, cursorStatus, groupingRule,
 3727|      0|							groupingOp, mode))
 3728|      0|					goto failure;
 3729|      0|				if (input->bufferIndex != inputBefore->bufferIndex &&
 3730|      0|						inputBefore->bufferIndex != origInput->bufferIndex)
 3731|      0|					releaseStringBuffer(inputBefore->bufferIndex);
 3732|      0|				if (pos == posBefore) posIncremented = 0;
 3733|      0|				continue;
 3734|      0|			}
 3735|      0|			default:
 3736|      0|				break;
 3737|      0|			}
 3738|      0|		} else {
 3739|      0|			if (appliedRules != NULL && appliedRulesCount < maxAppliedRules)
 3740|      0|				appliedRules[appliedRulesCount++] = transRule;
 3741|      0|			posIncremented = 1;
 3742|      0|		}
 3743|      0|
 3744|      0|		/* Processing before replacement */
 3745|      0|
 3746|      0|		/* check if leaving no contraction (grade 1) mode */
 3747|      0|		if (checkCharAttr(input->chars[pos], CTC_SeqDelimiter | CTC_Space, table))
 3748|      0|			dontContract = 0;
 3749|      0|
 3750|      0|		switch (transOpcode) {
 3751|      0|		case CTO_EndNum:
 3752|      0|			if (table->letterSign && checkCharAttr(input->chars[pos], CTC_Letter, table))
 3753|      0|				output->length--;
 3754|      0|			break;
 3755|      0|		case CTO_Repeated:
 3756|      0|		case CTO_Space:
 3757|      0|			dontContract = 0;
 3758|      0|			break;
 3759|      0|		case CTO_LargeSign:
 3760|      0|			if (prevTransOpcode == CTO_LargeSign) {
 3761|      0|				int hasEndSegment = 0;
 3762|      0|				while (output->length > 0 &&
 3763|      0|						checkDotsAttr(
 3764|      0|								output->chars[output->length - 1], CTC_Space, table)) {
 3765|      0|					if (output->chars[output->length - 1] == LOU_ENDSEGMENT) {
 3766|      0|						hasEndSegment = 1;
 3767|      0|					}
 3768|      0|					output->length--;
 3769|      0|				}
 3770|      0|				if (hasEndSegment != 0) {
 3771|      0|					output->chars[output->length] = 0xffff;
 3772|      0|					output->length++;
 3773|      0|				}
 3774|      0|			}
 3775|      0|			break;
 3776|      0|		case CTO_DecPoint:
 3777|      0|			if (!table->usesNumericMode && table->numberSign) {
 3778|      0|				TranslationTableRule *numRule =
 3779|      0|						(TranslationTableRule *)&table->ruleArea[table->numberSign];
 3780|      0|				if (!for_updatePositions(&numRule->charsdots[numRule->charslen],
 3781|      0|							numRule->charslen, numRule->dotslen, 0, pos, input, output,
 3782|      0|							posMapping, cursorPosition, cursorStatus))
 3783|      0|					goto failure;
 3784|      0|			}
 3785|      0|			transOpcode = CTO_MidNum;
 3786|      0|			break;
 3787|      0|		case CTO_NoCont:
 3788|      0|			if (!dontContract)
 3789|      0|				doNocont(table, &pos, output, mode, input, &lastWord, &dontContract,
 3790|      0|						&insertEmphasesFrom);
 3791|      0|			continue;
 3792|      0|		case CTO_RepWord:
 3793|      0|		case CTO_RepEndWord:
 3794|      0|			repwordStart = pos - transCharslen - repwordLength;
 3795|      0|			break;
 3796|      0|		default:
 3797|      0|			break;
 3798|      0|		} /* end of action */
 3799|      0|
 3800|      0|		/* replacement processing */
 3801|      0|		switch (transOpcode) {
 3802|      0|		case CTO_Replace:
 3803|      0|			pos += transCharslen;
 3804|      0|			if (!putCharacters(&transRule->charsdots[transCharslen], transRule->dotslen,
 3805|      0|						table, pos, input, output, posMapping, cursorPosition,
 3806|      0|						cursorStatus, mode))
 3807|      0|				goto failure;
 3808|      0|			break;
 3809|      0|		case CTO_None:
 3810|      0|			/* no definition or translation rules found for this character, but it may be
 3811|      0|			 * based on another character */
 3812|      0|			if (!putCharacter(input->chars[pos], table, pos, input, output, posMapping,
 3813|      0|						cursorPosition, cursorStatus, mode))
 3814|      0|				goto failure;
 3815|      0|			pos++;
 3816|      0|			break;
 3817|      0|		default: {
 3818|      0|			const widechar *dots = &transRule->charsdots[transCharslen];
 3819|      0|			int dotslen = transRule->dotslen;
 3820|      0|			if (transOpcode == CTO_RepEndWord) {
 3821|      0|				int k;
 3822|      0|				for (k = 1; dots[k] != ','; k++)
 3823|      0|					;
 3824|      0|				k++;
 3825|      0|				dots = &dots[k];
 3826|      0|				dotslen -= k;
 3827|      0|			}
 3828|      0|			if (dotslen) {
 3829|      0|				if (repwordLength) {
 3830|      0|					/* repword sepatator is already skipped */
 3831|      0|					if (!for_updatePositions(dots, 0, dotslen, 0, pos, input, output,
 3832|      0|								posMapping, cursorPosition, cursorStatus))
 3833|      0|						goto failure;
 3834|      0|				} else {
 3835|      0|					if (!for_updatePositions(dots, transCharslen, dotslen, 0, pos, input,
 3836|      0|								output, posMapping, cursorPosition, cursorStatus))
 3837|      0|						goto failure;
 3838|      0|					pos += transCharslen;
 3839|      0|				}
 3840|      0|			} else {
 3841|      0|				for (k = 0; k < transCharslen; k++) {
 3842|      0|					if (!putCharacter(input->chars[pos], table, pos, input, output,
 3843|      0|								posMapping, cursorPosition, cursorStatus, mode))
 3844|      0|						goto failure;
 3845|      0|					pos++;
 3846|      0|				}
 3847|      0|			}
 3848|      0|			break;
 3849|      0|		}
 3850|      0|		}
 3851|      0|
 3852|      0|		/* processing after replacement */
 3853|      0|		switch (transOpcode) {
 3854|      0|		case CTO_Repeated: {
 3855|      0|			/* Skip repeated characters. */
 3856|      0|			int srclim = input->length - transCharslen;
 3857|      0|			if (mode & (compbrlAtCursor | compbrlLeftCursor) && compbrlStart < srclim)
 3858|      0|				/* Don't skip characters from compbrlStart onwards. */
 3859|      0|				srclim = compbrlStart - 1;
 3860|      0|			while ((pos <= srclim) &&
 3861|      0|					compareChars(&transRule->charsdots[0], &input->chars[pos],
 3862|      0|							transCharslen, table)) {
 3863|      0|				if (!*cursorStatus && pos <= *cursorPosition &&
 3864|      0|						*cursorPosition < pos + transCharslen) {
 3865|      0|					*cursorStatus = 1;
 3866|      0|					*cursorPosition = output->length - 1;
 3867|      0|				}
 3868|      0|				pos += transCharslen;
 3869|      0|			}
 3870|      0|			break;
 3871|      0|		}
 3872|      0|		case CTO_RepEndWord: {
 3873|      0|			/* Go back and insert dots at repwordStart and update posMapping accordingly
 3874|      0|			 */
 3875|      0|			const widechar *dots = &transRule->charsdots[transCharslen];
 3876|      0|			int dotslen;
 3877|      0|			for (dotslen = 1; dots[dotslen] != ','; dotslen++)
 3878|      0|				;
 3879|      0|			if ((output->length + dotslen) > output->maxlength) goto failure;
 3880|      0|			int k;
 3881|      0|			for (k = output->length - 1; k >= 0; k--)
 3882|      0|				if (posMapping[k] >= repwordStart) {
 3883|      0|					output->chars[k + dotslen] = output->chars[k];
 3884|      0|					posMapping[k + dotslen] = posMapping[k];
 3885|      0|				} else
 3886|      0|					break;
 3887|      0|			k++;
 3888|      0|			memcpy(&output->chars[k], dots, dotslen * sizeof(*output->chars));
 3889|      0|			for (int l = 0; l < dotslen; l++) posMapping[k + l] = posMapping[k];
 3890|      0|			output->length += dotslen;
 3891|      0|			if (*cursorStatus && *cursorPosition >= k) *cursorPosition += dotslen;
 3892|      0|		}
 3893|      0|		case CTO_RepWord: {
 3894|      0|			/* Skip repeated characters. */
 3895|      0|			int srclim = input->length;
 3896|      0|			if (mode & (compbrlAtCursor | compbrlLeftCursor) && compbrlStart < srclim)
 3897|      0|				/* Don't skip characters from compbrlStart onwards. */
 3898|      0|				srclim = compbrlStart;
 3899|      0|			/* Skip first and subsequent repetitions */
 3900|      0|			/* Loop body is be executed at least once. */
 3901|      0|			int firstRep = 1;
 3902|      0|			while (pos + repwordLength <= srclim &&
 3903|      0|					compareChars(&input->chars[repwordStart], &input->chars[pos],
 3904|      0|							repwordLength, table)) {
 3905|      0|				/* Check that capitalisation and emphasis do not change within or in
 3906|      0|				 * between subsequent repetitions. It is allowed to change right before
 3907|      0|				 * the first repetition because that can be indicated. That it does not
 3908|      0|				 * change within the first repetition is already checked in
 3909|      0|				 * isRepeatedWord. */
 3910|      0|				if (!firstRep &&
 3911|      0|						checkEmphasisChange(pos - 1, repwordLength, emphasisBuffer))
 3912|      0|					break;
 3913|      0|				if (!*cursorStatus && *cursorPosition >= pos - transCharslen &&
 3914|      0|						*cursorPosition < pos + repwordLength) {
 3915|      0|					*cursorStatus = 1;
 3916|      0|					*cursorPosition = output->length - 1;
 3917|      0|				}
 3918|      0|				pos += repwordLength;
 3919|      0|				if (pos + transCharslen <= srclim &&
 3920|      0|						!memcmp(transRule->charsdots, &input->chars[pos],
 3921|      0|								transCharslen * sizeof(*transRule->charsdots)))
 3922|      0|					pos += transCharslen;
 3923|      0|				else {
 3924|      0|					pos += transCharslen;
 3925|      0|					break;
 3926|      0|				}
 3927|      0|				firstRep = 0;
 3928|      0|			}
 3929|      0|			pos -= transCharslen;
 3930|      0|			break;
 3931|      0|		}
 3932|      0|		case CTO_JoinNum:
 3933|      0|		case CTO_JoinableWord:
 3934|      0|			while (pos < input->length &&
 3935|      0|					checkCharAttr(input->chars[pos], CTC_Space, table) &&
 3936|      0|					input->chars[pos] != LOU_ENDSEGMENT)
 3937|      0|				pos++;
 3938|      0|			break;
 3939|      0|		default:
 3940|      0|			break;
 3941|      0|		}
 3942|      0|		if (((pos > 0) && checkCharAttr(input->chars[pos - 1], CTC_Space, table) &&
 3943|      0|					(transOpcode != CTO_JoinableWord))) {
 3944|      0|			lastWord = (LastWord){ pos, output->length, insertEmphasesFrom };
 3945|      0|		}
 3946|      0|		if (srcSpacing != NULL && srcSpacing[pos] >= '0' && srcSpacing[pos] <= '9')
 3947|      0|			destSpacing[output->length] = srcSpacing[pos];
 3948|      0|		if ((transOpcode >= CTO_Always && transOpcode <= CTO_None) ||
 3949|      0|				(transOpcode >= CTO_Digit && transOpcode <= CTO_LitDigit))
 3950|      0|			prevTransOpcode = transOpcode;
 3951|      0|	}
 3952|      0|
 3953|      0|	for (int at = insertEmphasesFrom; at <= pos; at++) {
 3954|      0|		/* insert caps end indicator */
 3955|      0|		insertEmphasesAt(0, 1, 1, 0, at, table, pos, input, output, posMapping,
 3956|      0|				emphasisBuffer, typebuf, cursorPosition, cursorStatus);
 3957|      0|		if (haveEmphasis) {
 3958|      0|			/* insert emphasis end indicator */
 3959|      0|			insertEmphasesAt(0, 1, 0, 1, at, table, pos, input, output, posMapping,
 3960|      0|					emphasisBuffer, typebuf, cursorPosition, cursorStatus);
 3961|      0|			/* insert emphasis start indicator */
 3962|      0|			insertEmphasesAt(1, 0, 0, 1, at, table, pos, input, output, posMapping,
 3963|      0|					emphasisBuffer, typebuf, cursorPosition, cursorStatus);
 3964|      0|		}
 3965|      0|		/* insert caps start indicator */
 3966|      0|		insertEmphasesAt(1, 0, 1, 0, at, table, pos, input, output, posMapping,
 3967|      0|				emphasisBuffer, typebuf, cursorPosition, cursorStatus);
 3968|      0|	}
 3969|      0|
 3970|      0|failure:
 3971|      0|	if (lastWord.outPos != 0 && pos < input->length &&
 3972|      0|			!checkCharAttr(input->chars[pos], CTC_Space, table)) {
 3973|      0|		pos = lastWord.inPos;
 3974|      0|		output->length = lastWord.outPos;
 3975|      0|	}
 3976|      0|	if (pos < input->length) {
 3977|      0|		while (checkCharAttr(input->chars[pos], CTC_Space, table))
 3978|      0|			if (++pos == input->length) break;
 3979|      0|	}
 3980|      0|	*realInlen = pos;
 3981|      0|	if (input->bufferIndex != origInput->bufferIndex)
 3982|      0|		releaseStringBuffer(input->bufferIndex);
 3983|      0|	return 1;
 3984|      0|} /* first pass translation completed */
 3985|       |
 3986|       |static int
 3987|      0|isHyphen(const TranslationTableHeader *table, widechar c) {
 3988|      0|	TranslationTableRule *rule;
 3989|      0|	TranslationTableOffset offset = getChar(c, table)->otherRules;
 3990|      0|	while (offset) {
 3991|      0|		rule = (TranslationTableRule *)&table->ruleArea[offset];
 3992|      0|		if (rule->opcode == CTO_Hyphen) return 1;
 3993|      0|		offset = rule->dotsnext;
 3994|      0|	}
 3995|      0|	return 0;
 3996|      0|}
 3997|       |
 3998|       |/**
 3999|       | * Hyphenate an input string which can either be text (mode = 0) or braille (mode = 1). If
 4000|       | * the input is braille, back-translation will be performed with `tableList'. The input
 4001|       | * string can contain any character (even space), but only break points within words
 4002|       | * (between letters) are considered. If the string can not be broken before the character
 4003|       | * at index k, the value of `hyphens[k]' is '0'. If it can be broken by inserting a hyphen
 4004|       | * at the break point, the value is '1'. If it can be broken without adding a hyphen, the
 4005|       | * value is '2'.
 4006|       | */
 4007|       |int EXPORT_CALL
 4008|       |lou_hyphenate(const char *tableList, const widechar *inbuf, int inlen, char *hyphens,
 4009|      0|		int mode) {
 4010|      0|#define HYPHSTRING 100
 4011|      0|	const TranslationTableHeader *table;
 4012|      0|	widechar textBuffer[HYPHSTRING];
 4013|      0|	char *textHyphens;
 4014|      0|	int *inputPos;
 4015|      0|	int k;
 4016|      0|	int textLen;
 4017|      0|	int wordStart;
 4018|      0|	table = lou_getTable(tableList);
 4019|      0|	if (table == NULL || inbuf == NULL || hyphens == NULL ||
 4020|      0|			table->hyphenStatesArray == 0 || inlen >= HYPHSTRING)
 4021|      0|		return 0;
 4022|      0|	if (mode != 0) {
 4023|      0|		int brailleLen = inlen;
 4024|      0|		textLen = HYPHSTRING;
 4025|      0|		inputPos = malloc(textLen * sizeof(int));
 4026|      0|		if (!lou_backTranslate(tableList, inbuf, &brailleLen, textBuffer, &textLen, NULL,
 4027|      0|					NULL, NULL, inputPos, NULL, 0)) {
 4028|      0|			free(inputPos);
 4029|      0|			return 0;
 4030|      0|		}
 4031|      0|		textHyphens = malloc((textLen + 1) * sizeof(char));
 4032|      0|	} else {
 4033|      0|		memcpy(textBuffer, inbuf, CHARSIZE * inlen);
 4034|      0|		textLen = inlen;
 4035|      0|		textHyphens = hyphens;
 4036|      0|	}
 4037|      0|
 4038|      0|	// initialize hyphens array
 4039|      0|	for (k = 0; k < textLen; k++) textHyphens[k] = '0';
 4040|      0|	textHyphens[k] = 0;
 4041|      0|
 4042|      0|	// for every word part
 4043|      0|	for (wordStart = 0;;) {
 4044|      0|		int wordEnd;
 4045|      0|		// find start of word
 4046|      0|		for (; wordStart < textLen; wordStart++)
 4047|      0|			if ((getChar(textBuffer[wordStart], table))->attributes & CTC_Letter) break;
 4048|      0|		if (wordStart == textLen) break;
 4049|      0|		// find end of word
 4050|      0|		for (wordEnd = wordStart + 1; wordEnd < textLen; wordEnd++)
 4051|      0|			if (!((getChar(textBuffer[wordEnd], table))->attributes & CTC_Letter)) break;
 4052|      0|		// hyphenate
 4053|      0|		if (!hyphenateWord(&textBuffer[wordStart], wordEnd - wordStart,
 4054|      0|					&textHyphens[wordStart], table))
 4055|      0|			return 0;
 4056|      0|		// normalize to '0', '1' or '2'
 4057|      0|		if (wordStart >= 2 && isHyphen(table, textBuffer[wordStart - 1]) &&
 4058|      0|				((getChar(textBuffer[wordStart - 2], table))->attributes & CTC_Letter))
 4059|      0|			textHyphens[wordStart] = '2';
 4060|      0|		else
 4061|      0|			textHyphens[wordStart] = '0';
 4062|      0|		for (k = wordStart + 1; k < wordEnd; k++)
 4063|      0|			if (textHyphens[k] & 1)
 4064|      0|				textHyphens[k] = '1';
 4065|      0|			else
 4066|      0|				textHyphens[k] = '0';
 4067|      0|		if (wordEnd == textLen) break;
 4068|      0|		textHyphens[wordEnd] = '0';	 // because hyphenateWord sets it to 0
 4069|      0|		wordStart = wordEnd + 1;
 4070|      0|	}
 4071|      0|
 4072|      0|	// map hyphen positions if the input was braille
 4073|      0|	if (mode != 0) {
 4074|      0|		for (k = 0; k < inlen; k++) hyphens[k] = '0';
 4075|      0|		hyphens[k] = 0;
 4076|      0|		int prevPos = -1;
 4077|      0|		for (k = 0; k < textLen; k++) {
 4078|      0|			int braillePos = inputPos[k];
 4079|      0|			if (braillePos > inlen || braillePos < 0) break;
 4080|      0|			if (braillePos > prevPos) {
 4081|      0|				hyphens[braillePos] = textHyphens[k];
 4082|      0|				prevPos = braillePos;
 4083|      0|			}
 4084|      0|		}
 4085|      0|		free(textHyphens);
 4086|      0|		free(inputPos);
 4087|      0|	}
 4088|      0|	return 1;
 4089|      0|}
 4090|       |
 4091|       |int EXPORT_CALL
 4092|       |lou_dotsToChar(
 4093|      0|		const char *tableList, widechar *inbuf, widechar *outbuf, int length, int mode) {
 4094|      0|	const DisplayTableHeader *table;
 4095|      0|	int k;
 4096|      0|	widechar dots;
 4097|      0|	if (tableList == NULL || inbuf == NULL || outbuf == NULL) return 0;
 4098|      0|
 4099|      0|	table = _lou_getDisplayTable(tableList);
 4100|      0|	if (table == NULL || length <= 0) return 0;
 4101|      0|	for (k = 0; k < length; k++) {
 4102|      0|		dots = inbuf[k];
 4103|      0|		if (!(dots & LOU_DOTS) &&
 4104|      0|				(dots & 0xff00) == LOU_ROW_BRAILLE) /* Unicode braille */
 4105|      0|			dots = (dots & 0x00ff) | LOU_DOTS;
 4106|      0|		outbuf[k] = _lou_getCharForDots(dots, table);
 4107|      0|		// assume that if NUL character is returned, it's because the display table has no
 4108|      0|		// mapping for the dot pattern (not because it maps to NUL)
 4109|      0|		if (outbuf[k] == '\0') outbuf[k] = ' ';
 4110|      0|	}
 4111|      0|	return 1;
 4112|      0|}
 4113|       |
 4114|       |int EXPORT_CALL
 4115|       |lou_charToDots(const char *tableList, const widechar *inbuf, widechar *outbuf, int length,
 4116|      0|		int mode) {
 4117|      0|	const DisplayTableHeader *table;
 4118|      0|	int k;
 4119|      0|	if (tableList == NULL || inbuf == NULL || outbuf == NULL) return 0;
 4120|      0|
 4121|      0|	table = _lou_getDisplayTable(tableList);
 4122|      0|	if (table == NULL || length <= 0) return 0;
 4123|      0|	for (k = 0; k < length; k++)
 4124|      0|		if ((mode & ucBrl))
 4125|      0|			outbuf[k] = ((_lou_getDotsForChar(inbuf[k], table) & 0xff) | LOU_ROW_BRAILLE);
 4126|      0|		else
 4127|      0|			outbuf[k] = _lou_getDotsForChar(inbuf[k], table);
 4128|      0|	return 1;
 4129|      0|}

/home/vito/MASTER_CSI/S2/TER/fuzzing/liblouis/liblouis/pattern.c:
    1|       |/* liblouis Braille Translation and Back-Translation Library
    2|       |
    3|       |   Copyright (C) 2016 Mike Gray, American Printing House for the Blind
    4|       |
    5|       |   This file is part of liblouis.
    6|       |
    7|       |   liblouis is free software: you can redistribute it and/or modify it
    8|       |   under the terms of the GNU Lesser General Public License as published
    9|       |   by the Free Software Foundation, either version 2.1 of the License, or
   10|       |   (at your option) any later version.
   11|       |
   12|       |   liblouis is distributed in the hope that it will be useful, but
   13|       |   WITHOUT ANY WARRANTY; without even the implied warranty of
   14|       |   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
   15|       |   Lesser General Public License for more details.
   16|       |
   17|       |   You should have received a copy of the GNU Lesser General Public
   18|       |   License along with liblouis. If not, see <http://www.gnu.org/licenses/>.
   19|       |*/
   20|       |
   21|       |#include <stdlib.h>
   22|       |#include <stdio.h>
   23|       |#include <string.h>
   24|       |#include <ctype.h>
   25|       |
   26|       |#include "internal.h"
   27|       |
   28|       |//#define CHECK_OUTPUT_DEFINED
   29|       |
   30|       |/////
   31|       |
   32|       |// TODO: these functions are static and copied serveral times
   33|       |
   34|       |int translation_direction = 1;
   35|       |
   36|       |static TranslationTableCharacter *
   37|      0|findCharOrDots(widechar c, int m, const TranslationTableHeader *table) {
   38|      0|	/* Look up character or dot pattern in the appropriate
   39|      0|	 * table. */
   40|      0|	static TranslationTableCharacter noChar = { NULL, -1, 0, 0, 0, CTC_Space, 0, 0, 32, 0,
   41|      0|		0 };
   42|      0|	static TranslationTableCharacter noDots = { NULL, -1, 0, 0, 0, CTC_Space, 0, 0,
   43|      0|		LOU_DOTS, 0, 0 };
   44|      0|	TranslationTableCharacter *notFound;
   45|      0|	TranslationTableCharacter *character;
   46|      0|	TranslationTableOffset bucket;
   47|      0|	unsigned long int makeHash = _lou_charHash(c);
   48|      0|	if (m == 0) {
   49|      0|		bucket = table->characters[makeHash];
   50|      0|		notFound = &noChar;
   51|      0|	} else {
   52|      0|		bucket = table->dots[makeHash];
   53|      0|		notFound = &noDots;
   54|      0|	}
   55|      0|	while (bucket) {
   56|      0|		character = (TranslationTableCharacter *)&table->ruleArea[bucket];
   57|      0|		if (character->value == c) return character;
   58|      0|		bucket = character->next;
   59|      0|	}
   60|      0|	notFound->value = c;
   61|      0|	return notFound;
   62|      0|}
   63|       |
   64|       |static int
   65|       |checkAttr(const widechar c, const TranslationTableCharacterAttributes a,
   66|      0|		const TranslationTableHeader *table) {
   67|      0|	return (((findCharOrDots(c, translation_direction ? 0 : 1, table))->attributes & a)
   68|      0|					? 1
   69|      0|					: 0);
   70|      0|}
   71|       |
   72|       |/////
   73|       |
   74|       |enum pattern_type {
   75|       |	PTN_ERROR,
   76|       |
   77|       |	PTN_START,
   78|       |	PTN_GROUP,
   79|       |	PTN_NOT,
   80|       |
   81|       |	PTN_ONE_MORE,
   82|       |	PTN_ZERO_MORE,
   83|       |	PTN_OPTIONAL,
   84|       |
   85|       |	PTN_ALTERNATE,
   86|       |
   87|       |	PTN_ANY,
   88|       |	PTN_ATTRIBUTES,
   89|       |	PTN_CHARS,
   90|       |	PTN_HOOK,
   91|       |	PTN_END_OF_INPUT,
   92|       |
   93|       |	PTN_END = 0xffff,
   94|       |};
   95|       |
   96|      0|#define EXPR_TYPE_IN(at, buffer) (buffer[(at) + 0])
   97|      0|#define EXPR_PRV_IN(at, buffer) (buffer[(at) + 1])
   98|      0|#define EXPR_NXT_IN(at, buffer) (buffer[(at) + 2])
   99|      0|#define EXPR_DATA_0_IN(at, buffer) (buffer[(at) + 3])
  100|      0|#define EXPR_DATA_1_IN(at, buffer) (buffer[(at) + 4])
  101|       |#define EXPR_DATA_2_IN(at, buffer) (buffer[(at) + 5])
  102|      0|#define EXPR_DATA_IN(at, buffer) ((widechar *)&buffer[(at) + 3])
  103|      0|#define EXPR_CONST_DATA_IN(at, buffer) ((const widechar *)&buffer[(at) + 3])
  104|       |
  105|      0|#define EXPR_TYPE(at) EXPR_TYPE_IN((at), expr_data)
  106|      0|#define EXPR_PRV(at) EXPR_PRV_IN((at), expr_data)
  107|      0|#define EXPR_NXT(at) EXPR_NXT_IN((at), expr_data)
  108|      0|#define EXPR_DATA_0(at) EXPR_DATA_0_IN((at), expr_data)
  109|      0|#define EXPR_DATA_1(at) EXPR_DATA_1_IN((at), expr_data)
  110|       |#define EXPR_DATA_2(at) EXPR_DATA_2_IN((at), expr_data)
  111|      0|#define EXPR_DATA(at) EXPR_DATA_IN((at), expr_data)
  112|      0|#define EXPR_CONST_DATA(at) EXPR_CONST_DATA_IN((at), expr_data)
  113|       |
  114|       |#ifdef CHECK_OUTPUT_DEFINED
  115|       |
  116|       |#ifndef DEBUG
  117|       |#define DEBUG
  118|       |
  119|       |#endif
  120|       |
  121|       |#define START 0
  122|       |#define CALL 1
  123|       |#define RETURN 2
  124|       |#define SHOW 3
  125|       |
  126|       |#define CHECK_OUTPUT(type, ret, line, msg)                                      \
  127|       |	{                                                                           \
  128|       |		do_output(type, ret, line, input[*input_crs], input_minmax, *input_crs, \
  129|       |				input_dir, expr_data, expr_crs, not, loop_crs, loop_cnts, msg); \
  130|       |	}
  131|       |
  132|       |#else
  133|       |
  134|       |#define CHECK_OUTPUT(type, ret, line, msg) \
  135|      0|	{ ; }
  136|       |
  137|       |#endif
  138|       |
  139|       |struct expression {
  140|       |	widechar type;
  141|       |	widechar prv;
  142|       |	widechar nxt;
  143|       |	widechar data[1];
  144|       |};
  145|       |
  146|       |/* gdb won't know what this is unless it is actually used */
  147|       |#ifdef DEBUG
  148|       |static struct expression *expr_debug;
  149|       |#endif
  150|       |
  151|       |////////////////////////////////////////////////////////////////////////////////
  152|       |
  153|       |static char spaces[] = "..............................";
  154|       |static int space = 30;
  155|       |
  156|       |static void
  157|       |pattern_output_expression(
  158|      0|		const widechar *expr_data, int expr_crs, const TranslationTableHeader *table) {
  159|      0|	int i;
  160|      0|
  161|      0|	if (expr_crs == PTN_END) return;
  162|      0|
  163|      0|	while (EXPR_TYPE(expr_crs) != PTN_END) {
  164|      0|		printf("%s%d", &spaces[space], expr_crs);
  165|      0|		if (expr_crs < 100) printf(" ");
  166|      0|		if (expr_crs < 10) printf(" ");
  167|      0|		for (i = 0; i < 13 - (30 - space); i++) printf(" ");
  168|      0|
  169|      0|		switch (EXPR_TYPE(expr_crs)) {
  170|      0|		case PTN_START:
  171|      0|
  172|      0|			printf("START\t%d\t%d\n", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs));
  173|      0|			break;
  174|      0|
  175|      0|		case PTN_GROUP:
  176|      0|
  177|      0|			printf("(    \t%d\t%d\t-> %d\n", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs),
  178|      0|					EXPR_DATA_0(expr_crs));
  179|      0|			space--;
  180|      0|			if (space < 0) space = 0;
  181|      0|			pattern_output_expression(expr_data, EXPR_DATA_0(expr_crs), table);
  182|      0|			space++;
  183|      0|			if (space > 30) space = 30;
  184|      0|			break;
  185|      0|
  186|      0|		case PTN_NOT:
  187|      0|
  188|      0|			printf("!    \t%d\t%d\t-> %d\n", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs),
  189|      0|					EXPR_DATA_0(expr_crs));
  190|      0|			space--;
  191|      0|			if (space < 0) space = 0;
  192|      0|			pattern_output_expression(expr_data, EXPR_DATA_0(expr_crs), table);
  193|      0|			space++;
  194|      0|			if (space > 30) space = 30;
  195|      0|			break;
  196|      0|
  197|      0|		case PTN_ONE_MORE:
  198|      0|
  199|      0|			printf("+    \t%d\t%d\t-> %d\t#%d\n", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs),
  200|      0|					EXPR_DATA_0(expr_crs), EXPR_DATA_1(expr_crs));
  201|      0|			space--;
  202|      0|			if (space < 0) space = 0;
  203|      0|			pattern_output_expression(expr_data, EXPR_DATA_0(expr_crs), table);
  204|      0|			space++;
  205|      0|			if (space > 30) space = 30;
  206|      0|			break;
  207|      0|
  208|      0|		case PTN_ZERO_MORE:
  209|      0|
  210|      0|			printf("*    \t%d\t%d\t-> %d\t#%d\n", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs),
  211|      0|					EXPR_DATA_0(expr_crs), EXPR_DATA_1(expr_crs));
  212|      0|			space--;
  213|      0|			if (space < 0) space = 0;
  214|      0|			pattern_output_expression(expr_data, EXPR_DATA_0(expr_crs), table);
  215|      0|			space++;
  216|      0|			if (space > 30) space = 30;
  217|      0|			break;
  218|      0|
  219|      0|		case PTN_OPTIONAL:
  220|      0|
  221|      0|			printf("?    \t%d\t%d\t-> %d\n", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs),
  222|      0|					EXPR_DATA_0(expr_crs));
  223|      0|			space--;
  224|      0|			if (space < 0) space = 0;
  225|      0|			pattern_output_expression(expr_data, EXPR_DATA_0(expr_crs), table);
  226|      0|			space++;
  227|      0|			if (space > 30) space = 30;
  228|      0|			break;
  229|      0|
  230|      0|		case PTN_ALTERNATE:
  231|      0|
  232|      0|			printf("|    \t%d\t%d\t-> %d\t-> %d\n", EXPR_PRV(expr_crs),
  233|      0|					EXPR_NXT(expr_crs), EXPR_DATA_0(expr_crs), EXPR_DATA_1(expr_crs));
  234|      0|			space--;
  235|      0|			if (space < 0) space = 0;
  236|      0|			pattern_output_expression(expr_data, EXPR_DATA_0(expr_crs), table);
  237|      0|			pattern_output_expression(expr_data, EXPR_DATA_1(expr_crs), table);
  238|      0|			space++;
  239|      0|			if (space > 30) space = 30;
  240|      0|			break;
  241|      0|
  242|      0|		case PTN_ANY:
  243|      0|
  244|      0|			printf(".    \t%d\t%d\n", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs));
  245|      0|			break;
  246|      0|
  247|      0|		case PTN_ATTRIBUTES:
  248|      0|
  249|      0|			printf("%%    \t%d\t%d\t", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs));
  250|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[0] >> 16)) printf("0");
  251|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[1] >> 16)) printf("1");
  252|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[2] >> 16)) printf("2");
  253|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[3] >> 16)) printf("3");
  254|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[4] >> 16)) printf("4");
  255|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[5] >> 16)) printf("5");
  256|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[6] >> 16)) printf("6");
  257|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[7] >> 16)) printf("7");
  258|      0|			if (EXPR_DATA_0(expr_crs) & (CTC_EndOfInput >> 16)) printf("^");
  259|      0|			if (EXPR_DATA_1(expr_crs) & CTC_Space) printf("_");
  260|      0|			if (EXPR_DATA_1(expr_crs) & CTC_Digit) printf("#");
  261|      0|			if (EXPR_DATA_1(expr_crs) & CTC_Letter) printf("a");
  262|      0|			if (EXPR_DATA_1(expr_crs) & CTC_UpperCase) printf("u");
  263|      0|			if (EXPR_DATA_1(expr_crs) & CTC_LowerCase) printf("l");
  264|      0|			if (EXPR_DATA_1(expr_crs) & CTC_Punctuation) printf(".");
  265|      0|			if (EXPR_DATA_1(expr_crs) & CTC_Sign) printf("$");
  266|      0|			if (EXPR_DATA_1(expr_crs) & CTC_SeqDelimiter) printf("~");
  267|      0|			if (EXPR_DATA_1(expr_crs) & CTC_SeqBefore) printf("<");
  268|      0|			if (EXPR_DATA_1(expr_crs) & CTC_SeqAfter) printf(">");
  269|      0|			puts("");
  270|      0|			break;
  271|      0|
  272|      0|		case PTN_CHARS:
  273|      0|
  274|      0|			printf("[]   \t%d\t%d\t", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs));
  275|      0|			for (i = 0; i < EXPR_DATA_0(expr_crs); i++)
  276|      0|				printf("%c", EXPR_CONST_DATA(expr_crs)[i + 1]);
  277|      0|			puts("");
  278|      0|			break;
  279|      0|
  280|      0|		case PTN_HOOK:
  281|      0|
  282|      0|			printf("@    \t%d\t%d\t", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs));
  283|      0|			for (i = 0; i < EXPR_DATA_0(expr_crs); i++)
  284|      0|				printf("%c", EXPR_CONST_DATA(expr_crs)[i + 1]);
  285|      0|			puts("");
  286|      0|			break;
  287|      0|
  288|      0|		case PTN_END_OF_INPUT:
  289|      0|
  290|      0|			printf("^    \t%d\t%d\n", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs));
  291|      0|			break;
  292|      0|
  293|      0|		default:
  294|      0|
  295|      0|			printf("%d?    \t%d\t%d\n", EXPR_TYPE(expr_crs), EXPR_PRV(expr_crs),
  296|      0|					EXPR_NXT(expr_crs));
  297|      0|			break;
  298|      0|		}
  299|      0|
  300|      0|		expr_crs = EXPR_NXT(expr_crs);
  301|      0|	}
  302|      0|
  303|      0|	printf("%s%d", &spaces[space], expr_crs);
  304|      0|	if (expr_crs < 100) printf(" ");
  305|      0|	if (expr_crs < 10) printf(" ");
  306|      0|	for (i = 0; i < 13 - (30 - space); i++) printf(" ");
  307|      0|	printf("END\t%d\t%d\n", EXPR_PRV(expr_crs), EXPR_NXT(expr_crs));
  308|      0|	fflush(stdout);
  309|      0|	return;
  310|      0|}
  311|       |
  312|       |static void
  313|      0|pattern_output(const widechar *expr_data, const TranslationTableHeader *table) {
  314|      0|	printf("%d    \tlength\n", expr_data[0]);
  315|      0|	printf("%d    \tloops\n", expr_data[1]);
  316|      0|	if (expr_data[0] > 0 && expr_data[0] != PTN_END)
  317|      0|		pattern_output_expression(expr_data, 2, table);
  318|      0|}
  319|       |
  320|       |static void
  321|       |pattern_print_expression(
  322|      0|		const widechar *expr_data, int expr_crs, const TranslationTableHeader *table) {
  323|      0|	int i;
  324|      0|
  325|      0|	if (expr_crs == PTN_END) return;
  326|      0|
  327|      0|	while (EXPR_TYPE(expr_crs) != PTN_END) {
  328|      0|		switch (EXPR_TYPE(expr_crs)) {
  329|      0|		case PTN_START:
  330|      0|			break;
  331|      0|
  332|      0|		case PTN_GROUP:
  333|      0|
  334|      0|			printf(" (");
  335|      0|			pattern_print_expression(expr_data, EXPR_DATA_0(expr_crs), table);
  336|      0|			printf(") ");
  337|      0|			break;
  338|      0|
  339|      0|		case PTN_NOT:
  340|      0|
  341|      0|			printf("!");
  342|      0|			pattern_print_expression(expr_data, EXPR_DATA_0(expr_crs), table);
  343|      0|			break;
  344|      0|
  345|      0|		case PTN_ONE_MORE:
  346|      0|
  347|      0|			pattern_print_expression(expr_data, EXPR_DATA_0(expr_crs), table);
  348|      0|			printf("+");
  349|      0|			break;
  350|      0|
  351|      0|		case PTN_ZERO_MORE:
  352|      0|
  353|      0|			pattern_print_expression(expr_data, EXPR_DATA_0(expr_crs), table);
  354|      0|			printf("*");
  355|      0|			break;
  356|      0|
  357|      0|		case PTN_OPTIONAL:
  358|      0|
  359|      0|			pattern_print_expression(expr_data, EXPR_DATA_0(expr_crs), table);
  360|      0|			printf("?");
  361|      0|			break;
  362|      0|
  363|      0|		case PTN_ALTERNATE:
  364|      0|
  365|      0|			pattern_print_expression(expr_data, EXPR_DATA_0(expr_crs), table);
  366|      0|			printf(" | ");
  367|      0|			pattern_print_expression(expr_data, EXPR_DATA_1(expr_crs), table);
  368|      0|			break;
  369|      0|
  370|      0|		case PTN_ANY:
  371|      0|
  372|      0|			printf(".");
  373|      0|			break;
  374|      0|
  375|      0|		case PTN_ATTRIBUTES:
  376|      0|
  377|      0|			printf("%%[");
  378|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[0] >> 16)) printf("0");
  379|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[1] >> 16)) printf("1");
  380|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[2] >> 16)) printf("2");
  381|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[3] >> 16)) printf("3");
  382|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[4] >> 16)) printf("4");
  383|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[5] >> 16)) printf("5");
  384|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[6] >> 16)) printf("6");
  385|      0|			if (EXPR_DATA_0(expr_crs) & (table->numberedAttributes[7] >> 16)) printf("7");
  386|      0|			if (EXPR_DATA_0(expr_crs) & (CTC_EndOfInput >> 16)) printf("^");
  387|      0|			if (EXPR_DATA_1(expr_crs) & CTC_Space) printf("_");
  388|      0|			if (EXPR_DATA_1(expr_crs) & CTC_Digit) printf("#");
  389|      0|			if (EXPR_DATA_1(expr_crs) & CTC_Letter) printf("a");
  390|      0|			if (EXPR_DATA_1(expr_crs) & CTC_UpperCase) printf("u");
  391|      0|			if (EXPR_DATA_1(expr_crs) & CTC_LowerCase) printf("l");
  392|      0|			if (EXPR_DATA_1(expr_crs) & CTC_Punctuation) printf(".");
  393|      0|			if (EXPR_DATA_1(expr_crs) & CTC_Sign) printf("$");
  394|      0|			if (EXPR_DATA_1(expr_crs) & CTC_SeqDelimiter) printf("~");
  395|      0|			if (EXPR_DATA_1(expr_crs) & CTC_SeqBefore) printf("<");
  396|      0|			if (EXPR_DATA_1(expr_crs) & CTC_SeqAfter) printf(">");
  397|      0|			printf("]");
  398|      0|			break;
  399|      0|
  400|      0|		case PTN_CHARS:
  401|      0|
  402|      0|			if (EXPR_DATA_0(expr_crs) == 1)
  403|      0|				printf("%c", EXPR_DATA_1(expr_crs));
  404|      0|			else {
  405|      0|				printf("[");
  406|      0|				for (i = 0; i < EXPR_DATA_0(expr_crs); i++)
  407|      0|					printf("%c", EXPR_CONST_DATA(expr_crs)[i + 1]);
  408|      0|				printf("]");
  409|      0|			}
  410|      0|			break;
  411|      0|
  412|      0|		case PTN_HOOK:
  413|      0|
  414|      0|			printf("@[");
  415|      0|			for (i = 0; i < EXPR_DATA_0(expr_crs); i++)
  416|      0|				printf("%c", EXPR_CONST_DATA(expr_crs)[i + 1]);
  417|      0|			printf("]");
  418|      0|			break;
  419|      0|
  420|      0|		case PTN_END_OF_INPUT:
  421|      0|
  422|      0|			printf("^");
  423|      0|			break;
  424|      0|
  425|      0|			// default:  printf("%d?\n", EXPR_TYPE(expr_crs));  break;
  426|      0|		}
  427|      0|
  428|      0|		expr_crs = EXPR_NXT(expr_crs);
  429|      0|	}
  430|      0|
  431|      0|	return;
  432|      0|}
  433|       |
  434|       |static void
  435|      0|pattern_print(const widechar *expr_data, const TranslationTableHeader *table) {
  436|      0|	if (expr_data[0] > 0 && expr_data[0] != PTN_END)
  437|      0|		pattern_print_expression(expr_data, 2, table);
  438|      0|	puts("");
  439|      0|}
  440|       |
  441|       |#ifdef CHECK_OUTPUT_DEFINED
  442|       |
  443|       |static void
  444|       |do_padd(const int value) {
  445|       |	if (value < 100000) printf(" ");
  446|       |	if (value < 10000) printf(" ");
  447|       |	if (value < 1000) printf(" ");
  448|       |	if (value < 100) printf(" ");
  449|       |	if (value < 10) printf(" ");
  450|       |}
  451|       |
  452|       |static void
  453|       |do_pad(const int value) {
  454|       |	if (value < 100) printf(" ");
  455|       |	if (value < 10) printf(" ");
  456|       |}
  457|       |
  458|       |static void
  459|       |do_output(const int type, const int ret, const int line,
  460|       |
  461|       |		const int input, const int input_minmax, const int input_crs, const int input_dir,
  462|       |		const widechar *expr_data, const int expr_crs, const int not, const int loop_crs,
  463|       |		const int *loop_cnts,
  464|       |
  465|       |		const char *msg) {
  466|       |	switch (type) {
  467|       |	case START:
  468|       |
  469|       |		space--;
  470|       |		if (space < 0) space = 0;
  471|       |		printf("|%s()  ", &spaces[space]);
  472|       |		break;
  473|       |
  474|       |	case CALL:
  475|       |
  476|       |		printf("|%s>   ", &spaces[space]);
  477|       |		break;
  478|       |
  479|       |	case RETURN:
  480|       |
  481|       |		printf("|%s<%d  ", &spaces[space], ret);
  482|       |		space++;
  483|       |		if (space > 31) space = 31;
  484|       |		break;
  485|       |
  486|       |	case SHOW:
  487|       |
  488|       |		printf("|%s    ", &spaces[space]);
  489|       |		break;
  490|       |	}
  491|       |
  492|       |	printf("%d ", line);
  493|       |	do_padd(line);
  494|       |
  495|       |	switch (expr_data[expr_crs]) {
  496|       |	case PTN_ERROR:
  497|       |		printf("# ");
  498|       |		break;
  499|       |	case PTN_START:
  500|       |		printf("> ");
  501|       |		break;
  502|       |	case PTN_END_OF_INPUT:
  503|       |		printf("^ ");
  504|       |		break;
  505|       |	case PTN_ALTERNATE:
  506|       |		printf("| ");
  507|       |		break;
  508|       |	case PTN_OPTIONAL:
  509|       |		printf("? ");
  510|       |		break;
  511|       |	case PTN_ONE_MORE:
  512|       |		printf("+ ");
  513|       |		break;
  514|       |	case PTN_ZERO_MORE:
  515|       |		printf("* ");
  516|       |		break;
  517|       |	case PTN_NOT:
  518|       |		printf("! ");
  519|       |		break;
  520|       |	case PTN_GROUP:
  521|       |		printf("( ");
  522|       |		break;
  523|       |	case PTN_ANY:
  524|       |		printf(". ");
  525|       |		break;
  526|       |	case PTN_ATTRIBUTES:
  527|       |		printf("%% ");
  528|       |		break;
  529|       |	case PTN_CHARS:
  530|       |		printf("[ ");
  531|       |		break;
  532|       |	case PTN_HOOK:
  533|       |		printf("@ ");
  534|       |		break;
  535|       |	case PTN_END:
  536|       |		printf("< ");
  537|       |		break;
  538|       |	default:
  539|       |		printf("  ");
  540|       |		break;
  541|       |	}
  542|       |	printf("%d ", expr_crs);
  543|       |	do_padd(expr_crs);
  544|       |
  545|       |	if (input > 31 && input < 127)
  546|       |		printf("%c ", input);
  547|       |	else
  548|       |		printf("_ ");
  549|       |
  550|       |	if (input_crs * input_dir >= input_minmax * input_dir)
  551|       |		printf("#   ");
  552|       |	else {
  553|       |		printf("%d ", input_crs);
  554|       |		do_pad(input_crs);
  555|       |	}
  556|       |
  557|       |	if (input_dir > 0)
  558|       |		printf("<");
  559|       |	else
  560|       |		printf(">");
  561|       |	printf("%d ", input_minmax);
  562|       |	do_pad(input_minmax);
  563|       |
  564|       |	if (not)
  565|       |		printf("!   ");
  566|       |	else
  567|       |		printf("    ");
  568|       |
  569|       |	if (loop_crs) {
  570|       |		printf("%d ", loop_crs);
  571|       |		do_pad(loop_crs);
  572|       |		printf("%d ", loop_cnts[EXPR_DATA_1(loop_crs)]);
  573|       |		do_pad(loop_cnts[EXPR_DATA_1(loop_crs)]);
  574|       |	} else
  575|       |		printf("-   -   ");
  576|       |	if (EXPR_TYPE(expr_crs) == PTN_ONE_MORE || EXPR_TYPE(expr_crs) == PTN_ZERO_MORE) {
  577|       |		printf("%d ", loop_cnts[EXPR_DATA_1(expr_crs)]);
  578|       |		do_pad(loop_cnts[EXPR_DATA_1(expr_crs)]);
  579|       |	} else
  580|       |		printf("-   ");
  581|       |
  582|       |	if (msg) printf("%s", msg);
  583|       |	puts("");
  584|       |}
  585|       |
  586|       |#endif
  587|       |
  588|       |////////////////////////////////////////////////////////////////////////////////
  589|       |
  590|       |static int
  591|       |pattern_compile_1(const widechar *input, const int input_max, int *input_crs,
  592|       |		widechar *expr_data, const int expr_max, widechar *expr_crs, widechar *loop_cnts,
  593|       |		TranslationTableHeader *table, const FileInfo *nested);
  594|       |
  595|       |static int
  596|       |pattern_compile_expression(const widechar *input, const int input_max, int *input_crs,
  597|       |		widechar *expr_data, const int expr_max, widechar *expr_crs, widechar *loop_cnts,
  598|      0|		TranslationTableHeader *table, const FileInfo *nested) {
  599|      0|	widechar *data;
  600|      0|	int expr_start, expr_end, expr_sub, expr_crs_prv;
  601|      0|	int input_end;
  602|      0|	int attrs0, attrs1;
  603|      0|	int set, esc, nest, i;
  604|      0|
  605|      0|	switch (input[*input_crs]) {
  606|      0|	case '(':
  607|      0|
  608|      0|		if (*expr_crs + 10 >= expr_max) return 0;
  609|      0|
  610|      0|		(*input_crs)++;
  611|      0|		if (*input_crs >= input_max) return 0;
  612|      0|
  613|      0|		/* find closing parenthesis */
  614|      0|		nest = esc = 0;
  615|      0|		for (input_end = *input_crs; input_end < input_max; input_end++) {
  616|      0|			if (input[input_end] == '\\' && !esc) {
  617|      0|				esc = 1;
  618|      0|				continue;
  619|      0|			}
  620|      0|
  621|      0|			if (input[input_end] == '(' && !esc)
  622|      0|				nest++;
  623|      0|			else if (input[input_end] == ')' && !esc) {
  624|      0|				if (nest)
  625|      0|					nest--;
  626|      0|				else
  627|      0|					break;
  628|      0|			}
  629|      0|
  630|      0|			esc = 0;
  631|      0|		}
  632|      0|		if (input_end >= input_max) return 0;
  633|      0|
  634|      0|		EXPR_TYPE(*expr_crs) = PTN_GROUP;
  635|      0|
  636|      0|		/* compile sub expressions */
  637|      0|		expr_crs_prv = *expr_crs;
  638|      0|		*expr_crs += 4;
  639|      0|		EXPR_DATA_0(expr_crs_prv) = *expr_crs;
  640|      0|		expr_sub = *expr_crs;
  641|      0|		EXPR_TYPE(expr_sub) = PTN_ERROR;
  642|      0|		EXPR_PRV(expr_sub) = PTN_END;
  643|      0|		EXPR_NXT(expr_sub) = PTN_END;
  644|      0|		if (!pattern_compile_1(input, input_end, input_crs, expr_data, expr_max, expr_crs,
  645|      0|					loop_cnts, table, nested))
  646|      0|			return 0;
  647|      0|		(*input_crs)++;
  648|      0|
  649|      0|		/* reset end expression */
  650|      0|		expr_end = *expr_crs;
  651|      0|		EXPR_NXT(expr_end) = expr_crs_prv;
  652|      0|
  653|      0|		return *expr_crs += 3;
  654|      0|
  655|      0|	case '!':
  656|      0|
  657|      0|		if (*expr_crs + 10 >= expr_max) return 0;
  658|      0|
  659|      0|		(*input_crs)++;
  660|      0|		EXPR_TYPE(*expr_crs) = PTN_NOT;
  661|      0|		expr_crs_prv = *expr_crs;
  662|      0|		*expr_crs += 4;
  663|      0|		EXPR_DATA_0(expr_crs_prv) = *expr_crs;
  664|      0|
  665|      0|		/* create start expression */
  666|      0|		expr_start = *expr_crs;
  667|      0|		EXPR_TYPE(expr_start) = PTN_START;
  668|      0|		EXPR_PRV(expr_start) = PTN_END;
  669|      0|		*expr_crs += 3;
  670|      0|		EXPR_NXT(expr_start) = *expr_crs;
  671|      0|
  672|      0|		/* compile sub expression */
  673|      0|		expr_sub = *expr_crs;
  674|      0|		EXPR_TYPE(expr_sub) = PTN_ERROR;
  675|      0|		EXPR_PRV(expr_sub) = expr_start;
  676|      0|		EXPR_NXT(expr_sub) = PTN_END;
  677|      0|
  678|      0|		if (!pattern_compile_expression(input, input_max, input_crs, expr_data, expr_max,
  679|      0|					expr_crs, loop_cnts, table, nested))
  680|      0|			return 0;
  681|      0|
  682|      0|		if (*expr_crs + 3 >= expr_max) return 0;
  683|      0|
  684|      0|		EXPR_NXT(expr_sub) = *expr_crs;
  685|      0|
  686|      0|		/* create end expression */
  687|      0|		expr_end = *expr_crs;
  688|      0|		EXPR_TYPE(expr_end) = PTN_END;
  689|      0|		EXPR_PRV(expr_end) = expr_sub;
  690|      0|		EXPR_NXT(expr_end) = expr_crs_prv;
  691|      0|
  692|      0|		return *expr_crs += 3;
  693|      0|
  694|      0|	case '+':
  695|      0|
  696|      0|		if (*expr_crs + 5 >= expr_max) return 0;
  697|      0|		EXPR_TYPE(*expr_crs) = PTN_ONE_MORE;
  698|      0|		EXPR_DATA_1(*expr_crs) = (*loop_cnts)++;
  699|      0|		(*input_crs)++;
  700|      0|		return *expr_crs += 5;
  701|      0|
  702|      0|	case '*':
  703|      0|
  704|      0|		if (*expr_crs + 5 >= expr_max) return 0;
  705|      0|		EXPR_TYPE(*expr_crs) = PTN_ZERO_MORE;
  706|      0|		EXPR_DATA_1(*expr_crs) = (*loop_cnts)++;
  707|      0|		(*input_crs)++;
  708|      0|		return *expr_crs += 5;
  709|      0|
  710|      0|	case '?':
  711|      0|
  712|      0|		if (*expr_crs + 4 >= expr_max) return 0;
  713|      0|		EXPR_TYPE(*expr_crs) = PTN_OPTIONAL;
  714|      0|		(*input_crs)++;
  715|      0|		return *expr_crs += 4;
  716|      0|
  717|      0|	case '|':
  718|      0|
  719|      0|		if (*expr_crs + 5 >= expr_max) return 0;
  720|      0|		EXPR_TYPE(*expr_crs) = PTN_ALTERNATE;
  721|      0|		(*input_crs)++;
  722|      0|		return *expr_crs += 5;
  723|      0|
  724|      0|	case '.':
  725|      0|
  726|      0|		if (*expr_crs + 3 >= expr_max) return 0;
  727|      0|		EXPR_TYPE(*expr_crs) = PTN_ANY;
  728|      0|		(*input_crs)++;
  729|      0|		return *expr_crs += 3;
  730|      0|
  731|      0|	case '%':
  732|      0|
  733|      0|		if (*expr_crs + 5 >= expr_max) return 0;
  734|      0|
  735|      0|		(*input_crs)++;
  736|      0|		if (*input_crs >= input_max) return 0;
  737|      0|
  738|      0|		/* find closing bracket */
  739|      0|		if (input[*input_crs] == '[') {
  740|      0|			set = 1;
  741|      0|			(*input_crs)++;
  742|      0|			for (input_end = *input_crs; input_end < input_max; input_end++)
  743|      0|				if (input[input_end] == ']') break;
  744|      0|			if (input_end >= input_max) return 0;
  745|      0|		} else {
  746|      0|			set = 0;
  747|      0|			input_end = *input_crs + 1;
  748|      0|		}
  749|      0|
  750|      0|		EXPR_TYPE(*expr_crs) = PTN_ATTRIBUTES;
  751|      0|
  752|      0|		attrs0 = attrs1 = 0;
  753|      0|		for (; (*input_crs) < input_end; (*input_crs)++) {
  754|      0|			switch (input[*input_crs]) {
  755|      0|			case '_':
  756|      0|				attrs0 |= CTC_Space;
  757|      0|				break;
  758|      0|			case '#':
  759|      0|				attrs0 |= CTC_Digit;
  760|      0|				break;
  761|      0|			case 'a':
  762|      0|				attrs0 |= CTC_Letter;
  763|      0|				break;
  764|      0|			case 'u':
  765|      0|				attrs0 |= CTC_UpperCase;
  766|      0|				break;
  767|      0|			case 'l':
  768|      0|				attrs0 |= CTC_LowerCase;
  769|      0|				break;
  770|      0|			case '.':
  771|      0|				attrs0 |= CTC_Punctuation;
  772|      0|				break;
  773|      0|			case '$':
  774|      0|				attrs0 |= CTC_Sign;
  775|      0|				break;
  776|      0|			case '~':
  777|      0|				attrs0 |= CTC_SeqDelimiter;
  778|      0|				break;
  779|      0|			case '<':
  780|      0|				attrs0 |= CTC_SeqBefore;
  781|      0|				break;
  782|      0|			case '>':
  783|      0|				attrs0 |= CTC_SeqAfter;
  784|      0|				break;
  785|      0|
  786|      0|			case '0':
  787|      0|			case '1':
  788|      0|			case '2':
  789|      0|			case '3':
  790|      0|			case '4':
  791|      0|			case '5':
  792|      0|			case '6':
  793|      0|			case '7': {
  794|      0|				int k = input[*input_crs] - '0';
  795|      0|				TranslationTableCharacterAttributes a = table->numberedAttributes[k];
  796|      0|				if (!a) {
  797|      0|					// attribute not used before yet: assign it a value
  798|      0|					a = table->numberedAttributes[k] =
  799|      0|							table->nextNumberedCharacterClassAttribute;
  800|      0|					if (a > CTC_UserDefined8) {
  801|      0|						_lou_logMessage(LOU_LOG_ERROR,
  802|      0|								"%s:%d: error: Too many character attributes defined",
  803|      0|								nested->fileName, nested->lineNumber);
  804|      0|						return 0;
  805|      0|					}
  806|      0|					table->nextNumberedCharacterClassAttribute <<= 1;
  807|      0|				}
  808|      0|				attrs1 |= (a >> 16);
  809|      0|				break;
  810|      0|			}
  811|      0|			case '^':
  812|      0|				attrs1 |= (CTC_EndOfInput >> 16);
  813|      0|				break;
  814|      0|
  815|      0|			default:
  816|      0|				return 0;
  817|      0|			}
  818|      0|		}
  819|      0|		EXPR_DATA_0(*expr_crs) = attrs1;
  820|      0|		EXPR_DATA_1(*expr_crs) = attrs0;
  821|      0|
  822|      0|		if (set) (*input_crs)++;
  823|      0|		return *expr_crs += 5;
  824|      0|
  825|      0|	case '[':
  826|      0|
  827|      0|		(*input_crs)++;
  828|      0|		if (*input_crs >= input_max) return 0;
  829|      0|
  830|      0|		/* find closing bracket */
  831|      0|		esc = 0;
  832|      0|		for (input_end = *input_crs; input_end < input_max; input_end++) {
  833|      0|			if (input[input_end] == '\\' && !esc) {
  834|      0|				esc = 1;
  835|      0|				continue;
  836|      0|			}
  837|      0|
  838|      0|			if (input[input_end] == ']' && !esc) break;
  839|      0|			esc = 0;
  840|      0|		}
  841|      0|		if (input_end >= input_max) return 0;
  842|      0|
  843|      0|		if (*expr_crs + 4 + (input_end - *input_crs) >= expr_max) return 0;
  844|      0|
  845|      0|		EXPR_TYPE(*expr_crs) = PTN_CHARS;
  846|      0|
  847|      0|		esc = 0;
  848|      0|		data = EXPR_DATA(*expr_crs);
  849|      0|		for (i = 1; *input_crs < input_end; (*input_crs)++) {
  850|      0|			if (input[*input_crs] == '\\' && !esc) {
  851|      0|				esc = 1;
  852|      0|				continue;
  853|      0|			}
  854|      0|
  855|      0|			esc = 0;
  856|      0|			data[i++] = (widechar)input[*input_crs];
  857|      0|		}
  858|      0|		data[0] = i - 1;
  859|      0|		(*input_crs)++;
  860|      0|		return *expr_crs += 4 + data[0];
  861|      0|
  862|      0|	case '@':
  863|      0|
  864|      0|		(*input_crs)++;
  865|      0|		if (*input_crs >= input_max) return 0;
  866|      0|
  867|      0|		/* find closing bracket */
  868|      0|		if (input[*input_crs] == '[') {
  869|      0|			set = 1;
  870|      0|			(*input_crs)++;
  871|      0|			for (input_end = *input_crs; input_end < input_max; input_end++)
  872|      0|				if (input[input_end] == ']') break;
  873|      0|			if (input_end >= input_max) return 0;
  874|      0|		} else {
  875|      0|			set = 0;
  876|      0|			input_end = *input_crs + 1;
  877|      0|		}
  878|      0|
  879|      0|		if (*expr_crs + 4 + (input_end - *input_crs) >= expr_max) return 0;
  880|      0|
  881|      0|		EXPR_TYPE(*expr_crs) = PTN_HOOK;
  882|      0|
  883|      0|		esc = 0;
  884|      0|		data = EXPR_DATA(*expr_crs);
  885|      0|		for (i = 1; *input_crs < input_end; (*input_crs)++) {
  886|      0|			if (input[*input_crs] == '\\' && !esc) {
  887|      0|				esc = 1;
  888|      0|				continue;
  889|      0|			}
  890|      0|
  891|      0|			esc = 0;
  892|      0|			data[i++] = (widechar)input[*input_crs];
  893|      0|		}
  894|      0|		data[0] = i - 1;
  895|      0|		if (set) (*input_crs)++;
  896|      0|		return *expr_crs += 4 + data[0];
  897|      0|
  898|      0|	case '^':
  899|      0|	case '$':
  900|      0|
  901|      0|		if (*expr_crs + 3 >= expr_max) return 0;
  902|      0|		EXPR_TYPE(*expr_crs) = PTN_END_OF_INPUT;
  903|      0|		(*input_crs)++;
  904|      0|		return *expr_crs += 3;
  905|      0|
  906|      0|	case '\\':
  907|      0|
  908|      0|		(*input_crs)++;
  909|      0|		if (*input_crs >= input_max) return 0;
  910|      0|
  911|      0|	default:
  912|      0|
  913|      0|		if (*expr_crs + 5 >= expr_max) return 0;
  914|      0|		EXPR_TYPE(*expr_crs) = PTN_CHARS;
  915|      0|		EXPR_DATA_0(*expr_crs) = 1;
  916|      0|		EXPR_DATA_1(*expr_crs) = (widechar)input[*input_crs];
  917|      0|		(*input_crs)++;
  918|      0|		return *expr_crs += 5;
  919|      0|	}
  920|      0|}
  921|       |
  922|       |static int
  923|       |pattern_insert_alternate(const widechar *input, const int input_max, int *input_crs,
  924|       |		widechar *expr_data, const int expr_max, widechar *expr_crs, widechar *loop_cnts,
  925|      0|		int expr_insert, TranslationTableHeader *table, const FileInfo *nested) {
  926|      0|	int expr_group, expr_alt, expr_end;
  927|      0|
  928|      0|	if (EXPR_TYPE(*expr_crs) == PTN_START) return 0;
  929|      0|
  930|      0|	if (*expr_crs + 12 >= expr_max) return 0;
  931|      0|
  932|      0|	/* setup alternate expression */
  933|      0|	expr_alt = *expr_crs;
  934|      0|	EXPR_TYPE(expr_alt) = PTN_ALTERNATE;
  935|      0|	EXPR_PRV(expr_alt) = PTN_END;
  936|      0|	EXPR_NXT(expr_alt) = PTN_END;
  937|      0|	*expr_crs += 5;
  938|      0|
  939|      0|	/* setup group expression */
  940|      0|	expr_group = *expr_crs;
  941|      0|	EXPR_TYPE(expr_group) = PTN_GROUP;
  942|      0|	EXPR_PRV(expr_group) = PTN_END;
  943|      0|	EXPR_NXT(expr_group) = PTN_END;
  944|      0|	*expr_crs += 4;
  945|      0|	EXPR_DATA_0(expr_group) = *expr_crs;
  946|      0|
  947|      0|	EXPR_TYPE(*expr_crs) = PTN_ERROR;
  948|      0|	EXPR_PRV(*expr_crs) = PTN_END;
  949|      0|	EXPR_NXT(*expr_crs) = PTN_END;
  950|      0|	if (!pattern_compile_1(input, input_max, input_crs, expr_data, expr_max, expr_crs,
  951|      0|				loop_cnts, table, nested))
  952|      0|		return 0;
  953|      0|	expr_end = *expr_crs;
  954|      0|	EXPR_NXT(expr_end) = expr_group;
  955|      0|
  956|      0|	/* setup last end expression */
  957|      0|	if (*expr_crs + 3 >= expr_max) return 0;
  958|      0|	*expr_crs += 3;
  959|      0|	EXPR_TYPE(*expr_crs) = PTN_END;
  960|      0|	EXPR_NXT(*expr_crs) = PTN_END;
  961|      0|
  962|      0|	/* replace insert expression with group expression using last end expression */
  963|      0|	EXPR_NXT(EXPR_PRV(expr_insert)) = expr_group;
  964|      0|	EXPR_PRV(expr_group) = EXPR_PRV(expr_insert);
  965|      0|
  966|      0|	EXPR_NXT(expr_group) = *expr_crs;
  967|      0|	EXPR_PRV(*expr_crs) = expr_group;
  968|      0|
  969|      0|	/* link alternate and insert expressions before group end expression */
  970|      0|	EXPR_NXT(EXPR_PRV(expr_end)) = expr_alt;
  971|      0|	EXPR_PRV(expr_alt) = EXPR_PRV(expr_end);
  972|      0|
  973|      0|	EXPR_NXT(expr_alt) = expr_insert;
  974|      0|	EXPR_PRV(expr_insert) = expr_alt;
  975|      0|
  976|      0|	EXPR_NXT(expr_insert) = expr_end;
  977|      0|	EXPR_PRV(expr_end) = expr_insert;
  978|      0|
  979|      0|	return *expr_crs;
  980|      0|}
  981|       |
  982|       |/* Compile all expression sequences, resolving character sets, attributes,
  983|       | * groups, nots, and hooks.  Note that unlike the other compile functions, on
  984|       | * returning the expr_crs is set to the last end expression, not after it.
  985|       | */
  986|       |static int
  987|       |pattern_compile_1(const widechar *input, const int input_max, int *input_crs,
  988|       |		widechar *expr_data, const int expr_max, widechar *expr_crs, widechar *loop_cnts,
  989|      0|		TranslationTableHeader *table, const FileInfo *nested) {
  990|      0|	int expr_crs_prv;
  991|      0|
  992|      0|	if (*expr_crs + 6 >= expr_max) return 0;
  993|      0|
  994|      0|	expr_crs_prv = *expr_crs;
  995|      0|
  996|      0|	/* setup start expression */
  997|      0|	EXPR_TYPE(*expr_crs) = PTN_START;
  998|      0|	EXPR_PRV(*expr_crs) = PTN_END;
  999|      0|	*expr_crs += 3;
 1000|      0|	EXPR_NXT(expr_crs_prv) = *expr_crs;
 1001|      0|
 1002|      0|	/* setup end expression */
 1003|      0|	EXPR_TYPE(*expr_crs) = PTN_END;
 1004|      0|	EXPR_PRV(*expr_crs) = expr_crs_prv;
 1005|      0|	EXPR_NXT(*expr_crs) = PTN_END;
 1006|      0|
 1007|      0|	while (*input_crs < input_max) {
 1008|      0|		expr_crs_prv = *expr_crs;
 1009|      0|		if (!pattern_compile_expression(input, input_max, input_crs, expr_data, expr_max,
 1010|      0|					expr_crs, loop_cnts, table, nested))
 1011|      0|			return 0;
 1012|      0|
 1013|      0|		/* setup end expression */
 1014|      0|		if (*expr_crs + 3 >= expr_max) return 0;
 1015|      0|		EXPR_NXT(expr_crs_prv) = *expr_crs;
 1016|      0|		EXPR_TYPE(*expr_crs) = PTN_END;
 1017|      0|		EXPR_PRV(*expr_crs) = expr_crs_prv;
 1018|      0|		EXPR_NXT(*expr_crs) = PTN_END;
 1019|      0|
 1020|      0|		/* insert seqafterexpression before attributes of seqafterchars */
 1021|      0|		// if(EXPR_TYPE(expr_crs_prv) == PTN_ATTRIBUTES)
 1022|      0|		// if(EXPR_DATA_1(expr_crs_prv) & CTC_SeqAfter)
 1023|      0|		// {
 1024|      0|		// 	i = 0;
 1025|      0|		// 	pattern_insert_alternate(table->seqAfterExpression,
 1026|      0|		// 		table->seqAfterExpressionLength, &i, expr_data, expr_max,
 1027|      0|		// 		expr_crs, loop_cnts, expr_crs_prv);
 1028|      0|		// }
 1029|      0|	}
 1030|      0|
 1031|      0|	return *expr_crs;
 1032|      0|}
 1033|       |
 1034|       |/* Resolve optional and loop expressions.
 1035|       | */
 1036|       |static int
 1037|       |pattern_compile_2(
 1038|      0|		widechar *expr_data, int expr_at, const int expr_max, widechar *expr_crs) {
 1039|      0|	int expr_start, expr_end, expr_prv, expr_sub;
 1040|      0|
 1041|      0|	while (EXPR_TYPE(expr_at) != PTN_END) {
 1042|      0|		if (EXPR_TYPE(expr_at) == PTN_GROUP || EXPR_TYPE(expr_at) == PTN_NOT) {
 1043|      0|			if (!pattern_compile_2(expr_data, EXPR_DATA_0(expr_at), expr_max, expr_crs))
 1044|      0|				return 0;
 1045|      0|		}
 1046|      0|
 1047|      0|		if (EXPR_TYPE(expr_at) == PTN_ZERO_MORE || EXPR_TYPE(expr_at) == PTN_ONE_MORE ||
 1048|      0|				EXPR_TYPE(expr_at) == PTN_OPTIONAL) {
 1049|      0|			if (*expr_crs + 6 >= expr_max) return 0;
 1050|      0|
 1051|      0|			/* get previous expressions, there must
 1052|      0|			 * be at least something and a PTN_START */
 1053|      0|			expr_sub = EXPR_PRV(expr_at);
 1054|      0|			if (EXPR_TYPE(expr_sub) == PTN_START) return 0;
 1055|      0|			expr_prv = EXPR_PRV(expr_sub);
 1056|      0|
 1057|      0|			/* create start expression */
 1058|      0|			expr_start = *expr_crs;
 1059|      0|			EXPR_TYPE(expr_start) = PTN_START;
 1060|      0|			EXPR_PRV(expr_start) = PTN_END;
 1061|      0|			EXPR_NXT(expr_start) = expr_sub;
 1062|      0|			*expr_crs += 3;
 1063|      0|
 1064|      0|			/* create end expression */
 1065|      0|			expr_end = *expr_crs;
 1066|      0|			EXPR_TYPE(expr_end) = PTN_END;
 1067|      0|			EXPR_PRV(expr_end) = expr_sub;
 1068|      0|			EXPR_NXT(expr_end) = expr_at;
 1069|      0|			*expr_crs += 3;
 1070|      0|
 1071|      0|			/* relink previous expression before sub expression */
 1072|      0|			EXPR_DATA_0(expr_at) = expr_start;
 1073|      0|			EXPR_NXT(expr_prv) = expr_at;
 1074|      0|			EXPR_PRV(expr_at) = expr_prv;
 1075|      0|
 1076|      0|			/* relink sub expression to start and end */
 1077|      0|			EXPR_PRV(expr_sub) = expr_start;
 1078|      0|			EXPR_NXT(expr_sub) = expr_end;
 1079|      0|		}
 1080|      0|
 1081|      0|		expr_at = EXPR_NXT(expr_at);
 1082|      0|	}
 1083|      0|
 1084|      0|	return 1;
 1085|      0|}
 1086|       |
 1087|       |/* Resolves alternative expressions.
 1088|       | */
 1089|       |static int
 1090|       |pattern_compile_3(
 1091|      0|		widechar *expr_data, int expr_at, const int expr_max, widechar *expr_crs) {
 1092|      0|	int expr_mrk, expr_start, expr_end, expr_sub_start, expr_sub_end;
 1093|      0|
 1094|      0|	while (EXPR_TYPE(expr_at) != PTN_END) {
 1095|      0|		if (EXPR_TYPE(expr_at) == PTN_GROUP || EXPR_TYPE(expr_at) == PTN_NOT ||
 1096|      0|				EXPR_TYPE(expr_at) == PTN_OPTIONAL ||
 1097|      0|				EXPR_TYPE(expr_at) == PTN_ZERO_MORE ||
 1098|      0|				EXPR_TYPE(expr_at) == PTN_ONE_MORE) {
 1099|      0|			if (!pattern_compile_3(expr_data, EXPR_DATA_0(expr_at), expr_max, expr_crs))
 1100|      0|				return 0;
 1101|      0|		}
 1102|      0|
 1103|      0|		if (EXPR_TYPE(expr_at) == PTN_ALTERNATE) {
 1104|      0|			if (*expr_crs + 12 >= expr_max) return 0;
 1105|      0|
 1106|      0|			/* get previous start expression,
 1107|      0|			 * can include alternate expressions */
 1108|      0|			expr_mrk = EXPR_PRV(expr_at);
 1109|      0|			if (EXPR_TYPE(expr_mrk) == PTN_START) return 0;
 1110|      0|			expr_sub_end = expr_mrk;
 1111|      0|			while (EXPR_TYPE(expr_mrk) != PTN_START) expr_mrk = EXPR_PRV(expr_mrk);
 1112|      0|			expr_sub_start = EXPR_NXT(expr_mrk);
 1113|      0|
 1114|      0|			/* create first start expression */
 1115|      0|			expr_start = *expr_crs;
 1116|      0|			EXPR_TYPE(expr_start) = PTN_START;
 1117|      0|			EXPR_PRV(expr_start) = PTN_END;
 1118|      0|			EXPR_NXT(expr_start) = expr_sub_start;
 1119|      0|			*expr_crs += 3;
 1120|      0|
 1121|      0|			/* create first end expression */
 1122|      0|			expr_end = *expr_crs;
 1123|      0|			EXPR_TYPE(expr_end) = PTN_END;
 1124|      0|			EXPR_PRV(expr_end) = expr_sub_end;
 1125|      0|			EXPR_NXT(expr_end) = expr_at;
 1126|      0|			*expr_crs += 3;
 1127|      0|
 1128|      0|			/* relink previous expression before sub expression */
 1129|      0|			EXPR_DATA_0(expr_at) = expr_start;
 1130|      0|			EXPR_NXT(expr_mrk) = expr_at;
 1131|      0|			EXPR_PRV(expr_at) = expr_mrk;
 1132|      0|
 1133|      0|			/* relink sub expression to start and end */
 1134|      0|			EXPR_PRV(expr_sub_start) = expr_start;
 1135|      0|			EXPR_NXT(expr_sub_end) = expr_end;
 1136|      0|
 1137|      0|			/* get following PTN_END or PTN_ALTERNATE expression */
 1138|      0|			expr_mrk = EXPR_NXT(expr_at);
 1139|      0|			if (EXPR_TYPE(expr_mrk) == PTN_END || EXPR_TYPE(expr_mrk) == PTN_ALTERNATE)
 1140|      0|				return 0;
 1141|      0|			expr_sub_start = expr_mrk;
 1142|      0|			while (EXPR_TYPE(expr_mrk) != PTN_END && EXPR_TYPE(expr_mrk) != PTN_ALTERNATE)
 1143|      0|				expr_mrk = EXPR_NXT(expr_mrk);
 1144|      0|			expr_sub_end = EXPR_PRV(expr_mrk);
 1145|      0|
 1146|      0|			/* create first start expression */
 1147|      0|			expr_start = *expr_crs;
 1148|      0|			EXPR_TYPE(expr_start) = PTN_START;
 1149|      0|			EXPR_PRV(expr_start) = PTN_END;
 1150|      0|			EXPR_NXT(expr_start) = expr_sub_start;
 1151|      0|			*expr_crs += 3;
 1152|      0|
 1153|      0|			/* create first end expression */
 1154|      0|			expr_end = *expr_crs;
 1155|      0|			EXPR_TYPE(expr_end) = PTN_END;
 1156|      0|			EXPR_PRV(expr_end) = expr_sub_end;
 1157|      0|			EXPR_NXT(expr_end) = expr_at;
 1158|      0|			*expr_crs += 3;
 1159|      0|
 1160|      0|			/* relink following expression before sub expression */
 1161|      0|			EXPR_DATA_1(expr_at) = expr_start;
 1162|      0|			EXPR_PRV(expr_mrk) = expr_at;
 1163|      0|			EXPR_NXT(expr_at) = expr_mrk;
 1164|      0|
 1165|      0|			/* relink sub expression to start and end */
 1166|      0|			EXPR_PRV(expr_sub_start) = expr_start;
 1167|      0|			EXPR_NXT(expr_sub_end) = expr_end;
 1168|      0|
 1169|      0|			/* check expressions were after alternate and got moved into
 1170|      0|			 * a sub expression, previous expressions already checked */
 1171|      0|			if (!pattern_compile_3(expr_data, EXPR_DATA_1(expr_at), expr_max, expr_crs))
 1172|      0|				return 0;
 1173|      0|		}
 1174|      0|
 1175|      0|		expr_at = EXPR_NXT(expr_at);
 1176|      0|	}
 1177|      0|
 1178|      0|	return 1;
 1179|      0|}
 1180|       |
 1181|       |int EXPORT_CALL
 1182|       |_lou_pattern_compile(const widechar *input, const int input_max, widechar *expr_data,
 1183|      0|		const int expr_max, TranslationTableHeader *table, const FileInfo *nested) {
 1184|      0|	int input_crs;
 1185|      0|
 1186|      0|	input_crs = 0;
 1187|      0|	expr_data[0] = 2;
 1188|      0|	expr_data[1] = 0;
 1189|      0|
 1190|      0|	if (!pattern_compile_1(input, input_max, &input_crs, expr_data, expr_max,
 1191|      0|				&expr_data[0], &expr_data[1], table, nested))
 1192|      0|		return 0;
 1193|      0|
 1194|      0|	/* shift past the last end */
 1195|      0|	expr_data[0] += 3;
 1196|      0|
 1197|      0|	if (!pattern_compile_2(expr_data, 2, expr_max, &expr_data[0])) return 0;
 1198|      0|
 1199|      0|	if (!pattern_compile_3(expr_data, 2, expr_max, &expr_data[0])) return 0;
 1200|      0|
 1201|      0|	return expr_data[0];
 1202|      0|}
 1203|       |
 1204|       |////////////////////////////////////////////////////////////////////////////////
 1205|       |
 1206|       |static void
 1207|       |pattern_reverse_expression(widechar *expr_data, const int expr_start);
 1208|       |
 1209|       |static void
 1210|      0|pattern_reverse_branch(widechar *expr_data, const int expr_at) {
 1211|      0|	widechar expr_swap;
 1212|      0|
 1213|      0|	switch (EXPR_TYPE(expr_at)) {
 1214|      0|	case PTN_ALTERNATE:
 1215|      0|
 1216|      0|		pattern_reverse_expression(expr_data, EXPR_DATA_0(expr_at));
 1217|      0|		expr_swap = EXPR_DATA_0(expr_at);
 1218|      0|		EXPR_DATA_0(expr_at) = EXPR_DATA_1(expr_at);
 1219|      0|		EXPR_DATA_1(expr_at) = expr_swap;
 1220|      0|
 1221|      0|	case PTN_GROUP:
 1222|      0|	case PTN_NOT:
 1223|      0|	case PTN_ONE_MORE:
 1224|      0|	case PTN_ZERO_MORE:
 1225|      0|	case PTN_OPTIONAL:
 1226|      0|
 1227|      0|		pattern_reverse_expression(expr_data, EXPR_DATA_0(expr_at));
 1228|      0|	}
 1229|      0|}
 1230|       |
 1231|       |static void
 1232|      0|pattern_reverse_expression(widechar *expr_data, const int expr_start) {
 1233|      0|	widechar expr_end, expr_crs, expr_prv;
 1234|      0|
 1235|      0|	expr_end = EXPR_NXT(expr_start);
 1236|      0|
 1237|      0|	/* empty expression */
 1238|      0|	if (EXPR_TYPE(expr_end) == PTN_END) return;
 1239|      0|
 1240|      0|	/* find end expression */
 1241|      0|	while (EXPR_TYPE(expr_end) != PTN_END) expr_end = EXPR_NXT(expr_end);
 1242|      0|
 1243|      0|	expr_crs = EXPR_PRV(expr_end);
 1244|      0|	expr_prv = EXPR_PRV(expr_crs);
 1245|      0|
 1246|      0|	/* relink expression before end expression */
 1247|      0|	EXPR_NXT(expr_start) = expr_crs;
 1248|      0|	EXPR_PRV(expr_crs) = expr_start;
 1249|      0|	EXPR_NXT(expr_crs) = expr_prv;
 1250|      0|
 1251|      0|	/* reverse any branching expressions */
 1252|      0|	pattern_reverse_branch(expr_data, expr_crs);
 1253|      0|
 1254|      0|	while (expr_prv != expr_start) {
 1255|      0|		/* shift current expression */
 1256|      0|		expr_crs = expr_prv;
 1257|      0|		expr_prv = EXPR_PRV(expr_prv);
 1258|      0|
 1259|      0|		/* reverse any branching expressions */
 1260|      0|		pattern_reverse_branch(expr_data, expr_crs);
 1261|      0|
 1262|      0|		/* relink current expression */
 1263|      0|		EXPR_PRV(expr_crs) = EXPR_NXT(expr_crs);
 1264|      0|		EXPR_NXT(expr_crs) = expr_prv;
 1265|      0|	}
 1266|      0|
 1267|      0|	/* relink expression after start expression */
 1268|      0|	EXPR_PRV(expr_crs) = EXPR_NXT(expr_crs);
 1269|      0|	EXPR_NXT(expr_crs) = expr_end;
 1270|      0|	EXPR_PRV(expr_end) = expr_crs;
 1271|      0|}
 1272|       |
 1273|       |void EXPORT_CALL
 1274|      0|_lou_pattern_reverse(widechar *expr_data) {
 1275|      0|	pattern_reverse_expression(expr_data, 2);
 1276|      0|}
 1277|       |
 1278|       |////////////////////////////////////////////////////////////////////////////////
 1279|       |
 1280|       |static int
 1281|      0|pattern_check_chars(const widechar input_char, const widechar *expr_data) {
 1282|      0|	int expr_cnt, i;
 1283|      0|
 1284|      0|	expr_cnt = expr_data[0] + 1;
 1285|      0|
 1286|      0|	for (i = 1; i < expr_cnt; i++)
 1287|      0|		if (input_char == expr_data[i]) break;
 1288|      0|
 1289|      0|	if (i == expr_cnt) return 0;
 1290|      0|	return 1;
 1291|      0|}
 1292|       |
 1293|       |static int
 1294|       |pattern_check_attrs(const widechar input_char, const widechar *expr_data,
 1295|      0|		const TranslationTableHeader *table) {
 1296|      0|	int attrs;
 1297|      0|
 1298|      0|	attrs = ((expr_data[0] << 16) | expr_data[1]) & ~(CTC_EndOfInput | CTC_EmpMatch);
 1299|      0|	if (!checkAttr(input_char, attrs, table)) return 0;
 1300|      0|	return 1;
 1301|      0|}
 1302|       |
 1303|       |static int
 1304|       |pattern_check_expression(const widechar *const input, int *input_crs,
 1305|       |		const int input_minmax, const int input_dir, const widechar *const expr_data,
 1306|       |		int (*hook)(const widechar input, const int data_len), widechar *hook_data,
 1307|       |		const int hook_max, int expr_crs, int not, int loop_crs, int *loop_cnts,
 1308|      0|		const TranslationTableHeader *table) {
 1309|      0|	int input_crs_prv, input_start, attrs, ret, i;
 1310|      0|	const widechar *data;
 1311|      0|
 1312|      0|	data = NULL;
 1313|      0|
 1314|      0|	/* save input_crs to know if loop consumed input */
 1315|      0|	input_start = *input_crs;
 1316|      0|
 1317|      0|	CHECK_OUTPUT(START, 0, __LINE__, "check start")
 1318|      0|
 1319|      0|	while (!(EXPR_TYPE(expr_crs) == PTN_END && EXPR_TYPE(expr_crs) == PTN_END)) {
 1320|      0|		/* end of input expression */
 1321|      0|		if (EXPR_TYPE(expr_crs) == PTN_END_OF_INPUT) {
 1322|      0|			if (*input_crs * input_dir >= input_minmax * input_dir) {
 1323|      0|				if (not)
 1324|      0|					CHECK_OUTPUT(RETURN, 0, __LINE__,
 1325|      0|							"end of input failed:  no input and not ")
 1326|      0|				else
 1327|      0|					CHECK_OUTPUT(RETURN, 1, __LINE__, "end of input passed:  no input")
 1328|      0|				return !not;
 1329|      0|			} else {
 1330|      0|				if (not)
 1331|      0|					CHECK_OUTPUT(
 1332|      0|							RETURN, 1, __LINE__, "end of input passed:  input and not")
 1333|      0|				else
 1334|      0|					CHECK_OUTPUT(RETURN, 0, __LINE__, "end of input failed:  input")
 1335|      0|				return not;
 1336|      0|			}
 1337|      0|		}
 1338|      0|
 1339|      0|		/* no more input */
 1340|      0|		if (*input_crs * input_dir >= input_minmax * input_dir) {
 1341|      0|			switch (EXPR_TYPE(expr_crs)) {
 1342|      0|			case PTN_ATTRIBUTES:
 1343|      0|
 1344|      0|				attrs = (EXPR_DATA_0(expr_crs) << 16);
 1345|      0|				if (attrs & CTC_EndOfInput) {
 1346|      0|					if (not) {
 1347|      0|						CHECK_OUTPUT(RETURN, 0, __LINE__,
 1348|      0|								"attributes failed:  end of input attribute:  not")
 1349|      0|						return 0;
 1350|      0|					}
 1351|      0|					CHECK_OUTPUT(RETURN, 1, __LINE__,
 1352|      0|							"attributes passed:  end of input attribute")
 1353|      0|					return 1;
 1354|      0|				}
 1355|      0|				CHECK_OUTPUT(RETURN, 0, __LINE__,
 1356|      0|						"attributes failed:  no end of input attribute")
 1357|      0|				return 0;
 1358|      0|
 1359|      0|			case PTN_ANY:
 1360|      0|			case PTN_CHARS:
 1361|      0|
 1362|      0|				CHECK_OUTPUT(RETURN, 0, __LINE__, "chars failed:  no input")
 1363|      0|				return 0;
 1364|      0|			}
 1365|      0|
 1366|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "no input")
 1367|      0|		}
 1368|      0|
 1369|      0|		switch (EXPR_TYPE(expr_crs)) {
 1370|      0|
 1371|      0|		case PTN_START:
 1372|      0|
 1373|      0|			expr_crs = EXPR_NXT(expr_crs);
 1374|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "start next")
 1375|      0|			break;
 1376|      0|
 1377|      0|		case PTN_GROUP:
 1378|      0|
 1379|      0|			expr_crs = EXPR_DATA_0(expr_crs);
 1380|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "group next")
 1381|      0|			break;
 1382|      0|
 1383|      0|		case PTN_NOT:
 1384|      0|
 1385|      0|			not = !not;
 1386|      0|			expr_crs = EXPR_DATA_0(expr_crs);
 1387|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "not next")
 1388|      0|			break;
 1389|      0|
 1390|      0|		case PTN_ONE_MORE:
 1391|      0|
 1392|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "loop+ start")
 1393|      0|
 1394|      0|		case PTN_ZERO_MORE:
 1395|      0|
 1396|      0|			/* check if loop already started */
 1397|      0|			if (expr_crs == loop_crs) {
 1398|      0|				loop_cnts[EXPR_DATA_1(loop_crs)]++;
 1399|      0|				CHECK_OUTPUT(SHOW, 0, __LINE__, "loop again")
 1400|      0|			} else {
 1401|      0|				/* check if loop nested, wasn't running but has a count */
 1402|      0|				if (loop_cnts[EXPR_DATA_1(expr_crs)]) {
 1403|      0|					CHECK_OUTPUT(SHOW, 0, __LINE__, "loop already running")
 1404|      0|					goto loop_next;
 1405|      0|				}
 1406|      0|
 1407|      0|				/* start loop */
 1408|      0|				loop_crs = expr_crs;
 1409|      0|				loop_cnts[EXPR_DATA_1(loop_crs)] = 1;
 1410|      0|				CHECK_OUTPUT(SHOW, 0, __LINE__, "loop start")
 1411|      0|			}
 1412|      0|
 1413|      0|			/* start loop expression */
 1414|      0|			input_crs_prv = *input_crs;
 1415|      0|			ret = pattern_check_expression(input, input_crs, input_minmax, input_dir,
 1416|      0|					expr_data, hook, hook_data, hook_max, EXPR_DATA_0(expr_crs), not,
 1417|      0|					loop_crs, loop_cnts, table);
 1418|      0|			if (ret) {
 1419|      0|				CHECK_OUTPUT(RETURN, 1, __LINE__, "loop passed")
 1420|      0|				return 1;
 1421|      0|			}
 1422|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "loop failed")
 1423|      0|			*input_crs = input_crs_prv;
 1424|      0|
 1425|      0|			/* check loop count */
 1426|      0|			loop_cnts[EXPR_DATA_1(loop_crs)]--;
 1427|      0|			if (EXPR_TYPE(expr_crs) == PTN_ONE_MORE) {
 1428|      0|				if (loop_cnts[EXPR_DATA_1(loop_crs)] < 1) {
 1429|      0|					CHECK_OUTPUT(RETURN, 0, __LINE__, "loop+ failed")
 1430|      0|					return 0;
 1431|      0|				} else
 1432|      0|					CHECK_OUTPUT(SHOW, 0, __LINE__, "loop+ passed")
 1433|      0|			}
 1434|      0|
 1435|      0|		/* continue after loop */
 1436|      0|		loop_next:
 1437|      0|			expr_crs = EXPR_NXT(expr_crs);
 1438|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "loop next")
 1439|      0|			break;
 1440|      0|
 1441|      0|		case PTN_OPTIONAL:
 1442|      0|
 1443|      0|			/* save current state */
 1444|      0|			input_crs_prv = *input_crs;
 1445|      0|
 1446|      0|			/* start optional expression */
 1447|      0|			CHECK_OUTPUT(CALL, 0, __LINE__, "option start")
 1448|      0|			if (pattern_check_expression(input, input_crs, input_minmax, input_dir,
 1449|      0|						expr_data, hook, hook_data, hook_max, EXPR_DATA_0(expr_crs), not,
 1450|      0|						loop_crs, loop_cnts, table)) {
 1451|      0|				CHECK_OUTPUT(RETURN, 1, __LINE__, "option passed")
 1452|      0|				return 1;
 1453|      0|			}
 1454|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "option failed")
 1455|      0|
 1456|      0|			/* continue after optional expression */
 1457|      0|			*input_crs = input_crs_prv;
 1458|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "no option start")
 1459|      0|			expr_crs = EXPR_NXT(expr_crs);
 1460|      0|			break;
 1461|      0|
 1462|      0|		case PTN_ALTERNATE:
 1463|      0|
 1464|      0|			/* save current state */
 1465|      0|			input_crs_prv = *input_crs;
 1466|      0|
 1467|      0|			/* start first expression */
 1468|      0|			CHECK_OUTPUT(CALL, 0, __LINE__, "or 1 start")
 1469|      0|			if (pattern_check_expression(input, input_crs, input_minmax, input_dir,
 1470|      0|						expr_data, hook, hook_data, hook_max, EXPR_DATA_0(expr_crs), not,
 1471|      0|						loop_crs, loop_cnts, table)) {
 1472|      0|				CHECK_OUTPUT(RETURN, 1, __LINE__, "or 1 passed")
 1473|      0|				return 1;
 1474|      0|			}
 1475|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "or 1 failed")
 1476|      0|
 1477|      0|			/* start second expression (no need to push) */
 1478|      0|			*input_crs = input_crs_prv;
 1479|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "or 2 start")
 1480|      0|			expr_crs = EXPR_DATA_1(expr_crs);
 1481|      0|			break;
 1482|      0|
 1483|      0|		case PTN_ANY:
 1484|      0|
 1485|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "any")
 1486|      0|			*input_crs += input_dir;
 1487|      0|			expr_crs = EXPR_NXT(expr_crs);
 1488|      0|			break;
 1489|      0|
 1490|      0|		case PTN_ATTRIBUTES:
 1491|      0|
 1492|      0|			ret = pattern_check_attrs(
 1493|      0|					input[*input_crs], EXPR_CONST_DATA(expr_crs), table);
 1494|      0|			if (ret && not) {
 1495|      0|				CHECK_OUTPUT(RETURN, 0, __LINE__, "attributes failed:  not");
 1496|      0|				return 0;
 1497|      0|			}
 1498|      0|			if (!ret && !not) {
 1499|      0|				CHECK_OUTPUT(RETURN, 0, __LINE__, "attributes failed");
 1500|      0|				return 0;
 1501|      0|			}
 1502|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "attributes passed")
 1503|      0|			*input_crs += input_dir;
 1504|      0|			expr_crs = EXPR_NXT(expr_crs);
 1505|      0|			break;
 1506|      0|
 1507|      0|		case PTN_CHARS:
 1508|      0|
 1509|      0|			ret = pattern_check_chars(input[*input_crs], EXPR_CONST_DATA(expr_crs));
 1510|      0|			if (ret && not) {
 1511|      0|				CHECK_OUTPUT(RETURN, 0, __LINE__, "chars failed:  not");
 1512|      0|				return 0;
 1513|      0|			}
 1514|      0|			if (!ret && !not) {
 1515|      0|				CHECK_OUTPUT(RETURN, 0, __LINE__, "chars failed");
 1516|      0|				return 0;
 1517|      0|			}
 1518|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "chars passed")
 1519|      0|			*input_crs += input_dir;
 1520|      0|			expr_crs = EXPR_NXT(expr_crs);
 1521|      0|			break;
 1522|      0|
 1523|      0|		case PTN_HOOK:
 1524|      0|
 1525|      0|			if (hook == NULL) {
 1526|      0|				CHECK_OUTPUT(RETURN, 0, __LINE__, "hook failed:  NULL");
 1527|      0|				return 0;
 1528|      0|			}
 1529|      0|
 1530|      0|			/* copy expression data */
 1531|      0|			data = EXPR_CONST_DATA(expr_crs);
 1532|      0|			for (i = 0; i < data[0]; i++) hook_data[i] = data[i + 1];
 1533|      0|
 1534|      0|			/* call hook function */
 1535|      0|			ret = hook(input[*input_crs], data[0]);
 1536|      0|			if (ret && not) {
 1537|      0|				CHECK_OUTPUT(RETURN, 0, __LINE__, "hook failed:  not");
 1538|      0|				return 0;
 1539|      0|			}
 1540|      0|			if (!ret && !not) {
 1541|      0|				CHECK_OUTPUT(RETURN, 0, __LINE__, "hook failed");
 1542|      0|				return 0;
 1543|      0|			}
 1544|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "hook passed")
 1545|      0|			*input_crs += input_dir;
 1546|      0|			expr_crs = EXPR_NXT(expr_crs);
 1547|      0|			break;
 1548|      0|
 1549|      0|		case PTN_END:
 1550|      0|			break;
 1551|      0|
 1552|      0|		default:
 1553|      0|
 1554|      0|			CHECK_OUTPUT(RETURN, 0, __LINE__, "unknown opcode")
 1555|      0|			return 0;
 1556|      0|		}
 1557|      0|
 1558|      0|		/* check end expression  */
 1559|      0|		while (EXPR_TYPE(expr_crs) == PTN_END) {
 1560|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "end")
 1561|      0|
 1562|      0|			/* check for end of expressions */
 1563|      0|			if (EXPR_NXT(expr_crs) == PTN_END) break;
 1564|      0|
 1565|      0|			expr_crs = EXPR_NXT(expr_crs);
 1566|      0|
 1567|      0|			/* returning loop */
 1568|      0|			if (EXPR_TYPE(expr_crs) == PTN_ZERO_MORE ||
 1569|      0|					EXPR_TYPE(expr_crs) == PTN_ONE_MORE) {
 1570|      0|				CHECK_OUTPUT(SHOW, 0, __LINE__, "end loop")
 1571|      0|
 1572|      0|				/* check that loop consumed input */
 1573|      0|				if (*input_crs == input_start) {
 1574|      0|					CHECK_OUTPUT(RETURN, 0, __LINE__, "loop failed:  did not consume")
 1575|      0|					return 0;
 1576|      0|				}
 1577|      0|
 1578|      0|				/* loops do not continue to the next expression */
 1579|      0|				break;
 1580|      0|			}
 1581|      0|
 1582|      0|			/* returning not */
 1583|      0|			if (EXPR_TYPE(expr_crs) == PTN_NOT) not = !not;
 1584|      0|
 1585|      0|			expr_crs = EXPR_NXT(expr_crs);
 1586|      0|
 1587|      0|			CHECK_OUTPUT(SHOW, 0, __LINE__, "end next")
 1588|      0|		}
 1589|      0|
 1590|      0|		CHECK_OUTPUT(SHOW, 0, __LINE__, "check next")
 1591|      0|	}
 1592|      0|
 1593|      0|	CHECK_OUTPUT(RETURN, 1, __LINE__, "check passed:  end of expression");
 1594|      0|	return 1;
 1595|      0|}
 1596|       |
 1597|       |static int
 1598|       |pattern_check_hook(const widechar *input, const int input_start, const int input_minmax,
 1599|       |		const int input_dir, const widechar *expr_data,
 1600|       |		int (*hook)(const widechar input, const int data_len), widechar *hook_data,
 1601|      0|		const int hook_max, const TranslationTableHeader *table) {
 1602|      0|	int input_crs, ret, *loop_cnts;
 1603|      0|
 1604|      0|	input_crs = input_start;
 1605|      0|	loop_cnts = malloc(expr_data[1] * sizeof(int));
 1606|      0|	memset(loop_cnts, 0, expr_data[1] * sizeof(int));
 1607|      0|	ret = pattern_check_expression(input, &input_crs, input_minmax, input_dir, expr_data,
 1608|      0|			hook, hook_data, hook_max, 2, 0, 0, loop_cnts, table);
 1609|      0|	free(loop_cnts);
 1610|      0|	return ret;
 1611|      0|}
 1612|       |
 1613|       |int EXPORT_CALL
 1614|       |_lou_pattern_check(const widechar *input, const int input_start, const int input_minmax,
 1615|       |		const int input_dir, const widechar *expr_data,
 1616|      0|		const TranslationTableHeader *table) {
 1617|       |#ifdef CHECK_OUTPUT_DEFINED
 1618|       |	pattern_output(expr_data, table);
 1619|       |#endif
 1620|       |	return pattern_check_hook(
 1621|      0|			input, input_start, input_minmax, input_dir, expr_data, NULL, NULL, 0, table);
 1622|      0|}
 1623|       |
 1624|       |////////////////////////////////////////////////////////////////////////////////

/home/vito/MASTER_CSI/S2/TER/fuzzing/liblouis/liblouis/utils.c:
    1|       |/* liblouis Braille Translation and Back-Translation Library
    2|       |
    3|       |   Based on the Linux screenreader BRLTTY, copyright (C) 1999-2006 by The
    4|       |   BRLTTY Team
    5|       |
    6|       |   Copyright (C) 2004, 2005, 2006 ViewPlus Technologies, Inc. www.viewplus.com
    7|       |   Copyright (C) 2004, 2005, 2006 JJB Software, Inc. www.jjb-software.com
    8|       |   Copyright (C) 2016 Mike Gray, American Printing House for the Blind
    9|       |   Copyright (C) 2016 Davy Kager, Dedicon
   10|       |
   11|       |   This file is part of liblouis.
   12|       |
   13|       |   liblouis is free software: you can redistribute it and/or modify it
   14|       |   under the terms of the GNU Lesser General Public License as published
   15|       |   by the Free Software Foundation, either version 2.1 of the License, or
   16|       |   (at your option) any later version.
   17|       |
   18|       |   liblouis is distributed in the hope that it will be useful, but
   19|       |   WITHOUT ANY WARRANTY; without even the implied warranty of
   20|       |   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
   21|       |   Lesser General Public License for more details.
   22|       |
   23|       |   You should have received a copy of the GNU Lesser General Public
   24|       |   License along with liblouis. If not, see <http://www.gnu.org/licenses/>.
   25|       |*/
   26|       |
   27|       |/**
   28|       | * @file
   29|       | * @brief Common utility functions
   30|       | */
   31|       |
   32|       |#include <stddef.h>
   33|       |#include <stdlib.h>
   34|       |#include <stdio.h>
   35|       |#include <stdarg.h>
   36|       |#include <string.h>
   37|       |#include <ctype.h>
   38|       |#include <sys/stat.h>
   39|       |
   40|       |#include "internal.h"
   41|       |#include "config.h"
   42|       |
   43|       |/* Contributed by Michel Such <michel.such@free.fr> */
   44|       |#ifdef _WIN32
   45|       |
   46|       |/* Adapted from BRLTTY code (see sys_progs_wihdows.h) */
   47|       |
   48|       |#include <shlobj.h>
   49|       |
   50|       |static void *
   51|       |reallocWrapper(void *address, size_t size) {
   52|       |	if (!(address = realloc(address, size)) && size) _lou_outOfMemory();
   53|       |	return address;
   54|       |}
   55|       |
   56|       |static char *
   57|       |strdupWrapper(const char *string) {
   58|       |	char *address = strdup(string);
   59|       |	if (!address) _lou_outOfMemory();
   60|       |	return address;
   61|       |}
   62|       |
   63|       |char *EXPORT_CALL
   64|       |lou_getProgramPath(void) {
   65|       |	char *path = NULL;
   66|       |	HMODULE handle;
   67|       |
   68|       |	if ((handle = GetModuleHandle(NULL))) {
   69|       |		DWORD size = 0X80;
   70|       |		char *buffer = NULL;
   71|       |
   72|       |		while (1) {
   73|       |			buffer = reallocWrapper(buffer, size <<= 1);
   74|       |
   75|       |			{
   76|       |				// As the "UNICODE" Windows define may have been set at compilation,
   77|       |				// This call must be specifically GetModuleFilenameA as further code
   78|       |				// expects it to be single byte chars.
   79|       |				DWORD length = GetModuleFileNameA(handle, buffer, size);
   80|       |
   81|       |				if (!length) {
   82|       |					printf("GetModuleFileName\n");
   83|       |					exit(3);
   84|       |				}
   85|       |
   86|       |				if (length < size) {
   87|       |					buffer[length] = 0;
   88|       |					path = strdupWrapper(buffer);
   89|       |
   90|       |					while (length > 0)
   91|       |						if (path[--length] == '\\') break;
   92|       |
   93|       |					strncpy(path, path, length + 1);
   94|       |					path[length + 1] = '\0';
   95|       |					break;
   96|       |				}
   97|       |			}
   98|       |		}
   99|       |
  100|       |		free(buffer);
  101|       |	} else {
  102|       |		printf("GetModuleHandle\n");
  103|       |		exit(3);
  104|       |	}
  105|       |
  106|       |	return path;
  107|       |}
  108|       |#endif
  109|       |/* End of MS contribution */
  110|       |
  111|       |static widechar
  112|      0|toLowercase(widechar c, const TranslationTableHeader *table) {
  113|      0|	static TranslationTableOffset offset;
  114|      0|	static TranslationTableCharacter *character;
  115|      0|	offset = table->characters[_lou_charHash(c)];
  116|      0|	while (offset) {
  117|      0|		character = (TranslationTableCharacter *)&table->ruleArea[offset];
  118|      0|		if (character->value == c) {
  119|      0|			if (character->mode & CTC_UpperCase) {
  120|      0|				const TranslationTableCharacter *c = character;
  121|      0|				if (c->basechar)
  122|      0|					c = (TranslationTableCharacter *)&table->ruleArea[c->basechar];
  123|      0|				while (1) {
  124|      0|					if ((c->mode & (character->mode & ~CTC_UpperCase)) ==
  125|      0|							(character->mode & ~CTC_UpperCase))
  126|      0|						return c->value;
  127|      0|					if (!c->linked) break;
  128|      0|					c = (TranslationTableCharacter *)&table->ruleArea[c->linked];
  129|      0|				}
  130|      0|			}
  131|      0|			return character->value;
  132|      0|		}
  133|      0|		offset = character->next;
  134|      0|	}
  135|      0|	return c;
  136|      0|}
  137|       |
  138|       |unsigned long int EXPORT_CALL
  139|      0|_lou_stringHash(const widechar *c, int lowercase, const TranslationTableHeader *table) {
  140|      0|	if (!lowercase)
  141|      0|		return (((unsigned long int)c[0] << 8) + (unsigned long int)c[1]) % HASHNUM;
  142|      0|	else
  143|      0|		return (((unsigned long int)toLowercase(c[0], table) << 8) +
  144|      0|					   (unsigned long int)toLowercase(c[1], table)) %
  145|      0|				HASHNUM;
  146|      0|}
  147|       |
  148|       |unsigned long int EXPORT_CALL
  149|      0|_lou_charHash(widechar c) {
  150|      0|	return (unsigned long int)c % HASHNUM;
  151|      0|}
  152|       |
  153|       |const char *EXPORT_CALL
  154|      0|_lou_showString(widechar const *chars, int length, int forceHex) {
  155|      0|	/* Translate a string of characters to the encoding used in character
  156|      0|	 * operands */
  157|      0|	static char scratchBuf[MAXSTRING];
  158|      0|	int bufPos = 0;
  159|      0|	scratchBuf[bufPos++] = '\'';
  160|      0|
  161|      0|	for (int charPos = 0; (charPos < length) && (bufPos < (MAXSTRING - 2));
  162|      0|			charPos += 1) {
  163|      0|		widechar c = chars[charPos];
  164|      0|
  165|      0|		if (!forceHex && isASCII(c)) {
  166|      0|			scratchBuf[bufPos++] = (char)c;
  167|      0|		} else {
  168|      0|			char hexbuf[20];
  169|      0|			int hexLength;
  170|      0|			char escapeLetter;
  171|      0|
  172|      0|			int leadingZeros;
  173|      0|			int hexPos;
  174|      0|			hexLength = sprintf(hexbuf, "%x", c);
  175|      0|			switch (hexLength) {
  176|      0|			case 1:
  177|      0|			case 2:
  178|      0|			case 3:
  179|      0|			case 4:
  180|      0|				escapeLetter = 'x';
  181|      0|				leadingZeros = 4 - hexLength;
  182|      0|				break;
  183|      0|			case 5:
  184|      0|				escapeLetter = 'y';
  185|      0|				leadingZeros = 0;
  186|      0|				break;
  187|      0|			case 6:
  188|      0|			case 7:
  189|      0|			case 8:
  190|      0|				escapeLetter = 'z';
  191|      0|				leadingZeros = 8 - hexLength;
  192|      0|				break;
  193|      0|			default:
  194|      0|				escapeLetter = '?';
  195|      0|				leadingZeros = 0;
  196|      0|				break;
  197|      0|			}
  198|      0|			if ((bufPos + leadingZeros + hexLength + 4) >= (MAXSTRING - 2)) break;
  199|      0|			scratchBuf[bufPos++] = '\\';
  200|      0|			scratchBuf[bufPos++] = escapeLetter;
  201|      0|			for (hexPos = 0; hexPos < leadingZeros; hexPos++) scratchBuf[bufPos++] = '0';
  202|      0|			for (hexPos = 0; hexPos < hexLength; hexPos++)
  203|      0|				scratchBuf[bufPos++] = hexbuf[hexPos];
  204|      0|		}
  205|      0|	}
  206|      0|	scratchBuf[bufPos++] = '\'';
  207|      0|	scratchBuf[bufPos] = 0;
  208|      0|	return scratchBuf;
  209|      0|}
  210|       |
  211|       |/**
  212|       | * Mapping between braille dot and textual representation as used in dots operands
  213|       | */
  214|       |static const intCharTupple dotMapping[] = {
  215|       |	{ LOU_DOT_1, '1' },
  216|       |	{ LOU_DOT_2, '2' },
  217|       |	{ LOU_DOT_3, '3' },
  218|       |	{ LOU_DOT_4, '4' },
  219|       |	{ LOU_DOT_5, '5' },
  220|       |	{ LOU_DOT_6, '6' },
  221|       |	{ LOU_DOT_7, '7' },
  222|       |	{ LOU_DOT_8, '8' },
  223|       |	{ LOU_DOT_9, '9' },
  224|       |	{ LOU_DOT_10, 'A' },
  225|       |	{ LOU_DOT_11, 'B' },
  226|       |	{ LOU_DOT_12, 'C' },
  227|       |	{ LOU_DOT_13, 'D' },
  228|       |	{ LOU_DOT_14, 'E' },
  229|       |	{ LOU_DOT_15, 'F' },
  230|       |	{ 0, 0 },
  231|       |};
  232|       |
  233|       |/**
  234|       | * Print out dot numbers
  235|       | *
  236|       | * @return a string containing the dot numbers. The longest possible
  237|       | * output is "\123456789ABCDEF0/"
  238|       | */
  239|       |const char *EXPORT_CALL
  240|      0|_lou_unknownDots(widechar dots) {
  241|      0|	static char buffer[20];
  242|      0|
  243|      0|	int k = 0;
  244|      0|	buffer[k++] = '\\';
  245|      0|
  246|      0|	for (int mappingPos = 0; dotMapping[mappingPos].key; mappingPos++) {
  247|      0|		if (dots & dotMapping[mappingPos].key) buffer[k++] = dotMapping[mappingPos].value;
  248|      0|	}
  249|      0|
  250|      0|	if (k == 1) buffer[k++] = '0';
  251|      0|	buffer[k++] = '/';
  252|      0|	buffer[k] = 0;
  253|      0|	return buffer;
  254|      0|}
  255|       |
  256|       |/**
  257|       | * Translate a sequence of dots to the encoding used in dots operands.
  258|       | */
  259|       |const char *EXPORT_CALL
  260|      0|_lou_showDots(widechar const *dots, int length) {
  261|      0|	int bufPos = 0;
  262|      0|	static char scratchBuf[MAXSTRING];
  263|      0|	for (int dotsPos = 0; dotsPos < length && bufPos < (MAXSTRING - 1); dotsPos++) {
  264|      0|		for (int mappingPos = 0; dotMapping[mappingPos].key; mappingPos++) {
  265|      0|			if ((dots[dotsPos] & dotMapping[mappingPos].key) &&
  266|      0|					(bufPos < (MAXSTRING - 1)))
  267|      0|				scratchBuf[bufPos++] = dotMapping[mappingPos].value;
  268|      0|		}
  269|      0|		if ((dots[dotsPos] == LOU_DOTS) && (bufPos < (MAXSTRING - 1)))
  270|      0|			scratchBuf[bufPos++] = '0';
  271|      0|		if ((dotsPos != length - 1) && (bufPos < (MAXSTRING - 1)))
  272|      0|			scratchBuf[bufPos++] = '-';
  273|      0|	}
  274|      0|	scratchBuf[bufPos] = 0;
  275|      0|	return scratchBuf;
  276|      0|}
  277|       |
  278|       |/**
  279|       | * Mapping between character attribute and textual representation
  280|       | */
  281|       |static const intCharTupple attributeMapping[] = {
  282|       |	{ CTC_Space, 's' },
  283|       |	{ CTC_Letter, 'l' },
  284|       |	{ CTC_Digit, 'd' },
  285|       |	{ CTC_Punctuation, 'p' },
  286|       |	{ CTC_UpperCase, 'U' },
  287|       |	{ CTC_LowerCase, 'u' },
  288|       |	{ CTC_Math, 'm' },
  289|       |	{ CTC_Sign, 'S' },
  290|       |	{ CTC_LitDigit, 'D' },
  291|       |	{ CTC_UserDefined9, 'w' },
  292|       |	{ CTC_UserDefined10, 'x' },
  293|       |	{ CTC_UserDefined11, 'y' },
  294|       |	{ CTC_UserDefined12, 'z' },
  295|       |	{ 0, 0 },
  296|       |};
  297|       |
  298|       |/**
  299|       | * Show attributes using the letters used after the $ in multipass
  300|       | * opcodes.
  301|       | */
  302|       |char *EXPORT_CALL
  303|      0|_lou_showAttributes(TranslationTableCharacterAttributes a) {
  304|      0|	int bufPos = 0;
  305|      0|	static char scratchBuf[MAXSTRING];
  306|      0|	for (int mappingPos = 0; attributeMapping[mappingPos].key; mappingPos++) {
  307|      0|		if ((a & attributeMapping[mappingPos].key) && bufPos < (MAXSTRING - 1))
  308|      0|			scratchBuf[bufPos++] = attributeMapping[mappingPos].value;
  309|      0|	}
  310|      0|	scratchBuf[bufPos] = 0;
  311|      0|	return scratchBuf;
  312|      0|}
  313|       |
  314|       |void EXPORT_CALL
  315|      0|_lou_outOfMemory(void) {
  316|      0|	_lou_logMessage(LOU_LOG_FATAL, "liblouis: Insufficient memory\n");
  317|      0|	exit(3);
  318|      0|}
  319|       |
  320|       |#ifdef DEBUG
  321|       |void EXPORT_CALL
  322|       |_lou_debugHook(void) {
  323|       |	char *hook = "debug hook";
  324|       |	printf("%s\n", hook);
  325|       |}
  326|       |#endif
  327|       |
  328|       |static const int validTranslationModes[] = { noContractions, compbrlAtCursor, dotsIO,
  329|       |	compbrlLeftCursor, ucBrl, noUndefined, partialTrans };
  330|       |
  331|       |int EXPORT_CALL
  332|      0|_lou_isValidMode(int mode) {
  333|      0|	// mask out all valid mode bits. If you end up with some bits set
  334|      0|	// then the input isn't valid. See
  335|      0|	// https://en.wikipedia.org/wiki/Material_nonimplication
  336|      0|	for (int i = 0; i < (sizeof(validTranslationModes) / sizeof(*validTranslationModes));
  337|      0|			i++)
  338|      0|		mode &= ~validTranslationModes[i];
  339|      0|	return !mode;
  340|      0|}
  341|       |
  342|       |/* Map char to dots according to North American Braille Computer Code (NABCC) */
  343|       |widechar EXPORT_CALL
  344|      0|_lou_charToFallbackDots(widechar c) {
  345|      0|	static const unsigned char charToDots[] = {
  346|      0|		/* ASCII characters 0X00-0X1F - control characters.
  347|      0|		 * These won't be referenced so we have room for data.
  348|      0|		 * These groups must be in descending order.
  349|      0|		 * Each group contains the following four bytes:
  350|      0|		 * 1) The first character to which this block applies.
  351|      0|		 * 2) The bits to remove from the character.
  352|      0|		 * 3) The bits to add to the character.
  353|      0|		 * 4) The dots to add to the braille pattern.
  354|      0|		 */
  355|      0|		// clang-format off
  356|      0|		0X7F, 0X20, 0X00, LOU_DOT_7,
  357|      0|		0X60, 0X20, 0X00, 0,
  358|      0|		0X5F, 0X00, 0X00, 0,
  359|      0|		0X40, 0X00, 0X00, LOU_DOT_7,
  360|      0|		0X20, 0X00, 0X00, 0,
  361|      0|		0X00, 0X00, 0X40, LOU_DOT_7 | LOU_DOT_8,
  362|      0|
  363|      0|		// ASCII characters 0X20-0X3F - digits and common symbols.
  364|      0|		[' '] = 0,
  365|      0|		['!'] = LOU_DOT_2 | LOU_DOT_3 | LOU_DOT_4 | LOU_DOT_6,
  366|      0|		['"'] = LOU_DOT_5,
  367|      0|		['#'] = LOU_DOT_3 | LOU_DOT_4 | LOU_DOT_5 | LOU_DOT_6,
  368|      0|		['$'] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_4 | LOU_DOT_6,
  369|      0|		['%'] = LOU_DOT_1 | LOU_DOT_4 | LOU_DOT_6,
  370|      0|		['&'] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_3 | LOU_DOT_4 | LOU_DOT_6,
  371|      0|		['\''] = LOU_DOT_3,
  372|      0|		['('] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_3 | LOU_DOT_5 | LOU_DOT_6,
  373|      0|		[')'] = LOU_DOT_2 | LOU_DOT_3 | LOU_DOT_4 | LOU_DOT_5 | LOU_DOT_6,
  374|      0|		['*'] = LOU_DOT_1 | LOU_DOT_6,
  375|      0|		['+'] = LOU_DOT_3 | LOU_DOT_4 | LOU_DOT_6,
  376|      0|		[','] = LOU_DOT_6,
  377|      0|		['-'] = LOU_DOT_3 | LOU_DOT_6,
  378|      0|		['.'] = LOU_DOT_4 | LOU_DOT_6,
  379|      0|		['/'] = LOU_DOT_3 | LOU_DOT_4,
  380|      0|		['0'] = LOU_DOT_3 | LOU_DOT_5 | LOU_DOT_6,
  381|      0|		['1'] = LOU_DOT_2,
  382|      0|		['2'] = LOU_DOT_2 | LOU_DOT_3,
  383|      0|		['3'] = LOU_DOT_2 | LOU_DOT_5,
  384|      0|		['4'] = LOU_DOT_2 | LOU_DOT_5 | LOU_DOT_6,
  385|      0|		['5'] = LOU_DOT_2 | LOU_DOT_6,
  386|      0|		['6'] = LOU_DOT_2 | LOU_DOT_3 | LOU_DOT_5,
  387|      0|		['7'] = LOU_DOT_2 | LOU_DOT_3 | LOU_DOT_5 | LOU_DOT_6,
  388|      0|		['8'] = LOU_DOT_2 | LOU_DOT_3 | LOU_DOT_6,
  389|      0|		['9'] = LOU_DOT_3 | LOU_DOT_5,
  390|      0|		[':'] = LOU_DOT_1 | LOU_DOT_5 | LOU_DOT_6,
  391|      0|		[';'] = LOU_DOT_5 | LOU_DOT_6,
  392|      0|		['<'] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_6,
  393|      0|		['='] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_3 | LOU_DOT_4 | LOU_DOT_5 | LOU_DOT_6,
  394|      0|		['>'] = LOU_DOT_3 | LOU_DOT_4 | LOU_DOT_5,
  395|      0|		['?'] = LOU_DOT_1 | LOU_DOT_4 | LOU_DOT_5 | LOU_DOT_6,
  396|      0|
  397|      0|		// ASCII characters 0X40-0X5F - letters and other symbols.
  398|      0|		['@'] = LOU_DOT_4,
  399|      0|		['A'] = LOU_DOT_1,
  400|      0|		['B'] = LOU_DOT_1 | LOU_DOT_2,
  401|      0|		['C'] = LOU_DOT_1 | LOU_DOT_4,
  402|      0|		['D'] = LOU_DOT_1 | LOU_DOT_4 | LOU_DOT_5,
  403|      0|		['E'] = LOU_DOT_1 | LOU_DOT_5,
  404|      0|		['F'] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_4,
  405|      0|		['G'] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_4 | LOU_DOT_5,
  406|      0|		['H'] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_5,
  407|      0|		['I'] = LOU_DOT_2 | LOU_DOT_4,
  408|      0|		['J'] = LOU_DOT_2 | LOU_DOT_4 | LOU_DOT_5,
  409|      0|		['K'] = LOU_DOT_1 | LOU_DOT_3,
  410|      0|		['L'] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_3,
  411|      0|		['M'] = LOU_DOT_1 | LOU_DOT_3 | LOU_DOT_4,
  412|      0|		['N'] = LOU_DOT_1 | LOU_DOT_3 | LOU_DOT_4 | LOU_DOT_5,
  413|      0|		['O'] = LOU_DOT_1 | LOU_DOT_3 | LOU_DOT_5,
  414|      0|		['P'] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_3 | LOU_DOT_4,
  415|      0|		['Q'] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_3 | LOU_DOT_4 | LOU_DOT_5,
  416|      0|		['R'] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_3 | LOU_DOT_5,
  417|      0|		['S'] = LOU_DOT_2 | LOU_DOT_3 | LOU_DOT_4,
  418|      0|		['T'] = LOU_DOT_2 | LOU_DOT_3 | LOU_DOT_4 | LOU_DOT_5,
  419|      0|		['U'] = LOU_DOT_1 | LOU_DOT_3 | LOU_DOT_6,
  420|      0|		['V'] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_3 | LOU_DOT_6,
  421|      0|		['W'] = LOU_DOT_2 | LOU_DOT_4 | LOU_DOT_5 | LOU_DOT_6,
  422|      0|		['X'] = LOU_DOT_1 | LOU_DOT_3 | LOU_DOT_4 | LOU_DOT_6,
  423|      0|		['Y'] = LOU_DOT_1 | LOU_DOT_3 | LOU_DOT_4 | LOU_DOT_5 | LOU_DOT_6,
  424|      0|		['Z'] = LOU_DOT_1 | LOU_DOT_3 | LOU_DOT_5 | LOU_DOT_6,
  425|      0|		['['] = LOU_DOT_2 | LOU_DOT_4 | LOU_DOT_6,
  426|      0|		['\\'] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_5 | LOU_DOT_6,
  427|      0|		[']'] = LOU_DOT_1 | LOU_DOT_2 | LOU_DOT_4 | LOU_DOT_5 | LOU_DOT_6,
  428|      0|		['^'] = LOU_DOT_4 | LOU_DOT_5,
  429|      0|		['_'] = LOU_DOT_4 | LOU_DOT_5 | LOU_DOT_6
  430|      0|		// clang-format on
  431|      0|	};
  432|      0|
  433|      0|	if (c >= 0X80) c = '?';
  434|      0|	widechar dots = LOU_DOTS;
  435|      0|
  436|      0|	{
  437|      0|		const unsigned char *p = charToDots;
  438|      0|		while (*p > c) p += 4;
  439|      0|
  440|      0|		c &= ~*++p;
  441|      0|		c |= *++p;
  442|      0|		dots |= *++p;
  443|      0|	}
  444|      0|
  445|      0|	dots |= charToDots[c];
  446|      0|	return dots;
  447|      0|}

/home/vito/MASTER_CSI/S2/TER/fuzzing/liblouis/tests/fuzzing/fuzz_translate.c:
    1|       |#include <stdlib.h>
    2|       |#include <stdint.h>
    3|       |#include <stdio.h>
    4|       |
    5|       |#include <liblouis.h>
    6|       |
    7|       |#define BUF_MAX 4096
    8|       |
    9|       |#define LANGUAGE	"en"
   10|       |
   11|       |int initialized = 0;
   12|       |
   13|       |
   14|       |
   15|       |
   16|       |static widechar inputText[BUF_MAX];
   17|       |static widechar outputText[BUF_MAX];
   18|       |static int inputLen , outputLen;
   19|       |
   20|       |static void
   21|       |__attribute__((destructor))
   22|       |free_ressources(void)
   23|      0|{
   24|      0|	lou_free();
   25|      0|}
   26|       |
   27|       |logcallback
   28|       |avoid_log(logLevels level, const char *msg)
   29|      0|{
   30|      0|	(void) level;
   31|      0|	(void) msg;
   32|      0|}
   33|       |
   34|       |extern int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size);
   35|       |
   36|       |int
   37|       |LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
   38|      0|{
   39|      0|	if (!initialized)
   40|      0|	{
   41|      0|		lou_registerLogCallback(avoid_log);
   42|      0|		initialized = 1;
   43|      0|	}
   44|      0|
   45|      0|	if (!_lou_extParseChars(data, inputText))  {
   46|      0|		return -1;
   47|      0|	}
   48|      0|	inputLen = size;
   49|      0|	static const char table_default[] = "chardefs.cti";
   50|      0|	lou_translateString(table_default, inputText, &inputLen, outputText, &outputLen, NULL, NULL, ucBrl);
   51|      0|
   52|      0|	return 0;
   53|      0|}

